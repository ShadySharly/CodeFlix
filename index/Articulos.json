  [
      {
        "id": 1,
        "autor": "Mokhtar Ebrahim",
        "pagina": "likegeeks",
        "fecha": "02/02/2019",
        "titulo": "Tutorial para utilizar un arreglo en Python con NumPy",
        "link": "https://likegeeks.com/es/tutorial-python-con-numpy/",
        "contenido": "Skip to content Buscar ‚Ä¶ Like Geeks INICIO LINUX ADMINISTRACI√ìN DEL SERVIDOR DESARROLLO WEB PYTHON DESARROLLO IOS CONSEJOS DE TECNOLOG√çA PYTHON Tutorial para utilizar un arreglo en Python con NumPy Mokhtar EbrahimPublicada: febrero 2, 2019√öltima actualizaci√≥n: marzo 28, 2019 NumPy es un m√≥dulo / biblioteca de Python que se utiliza para c√°lculos cient√≠ficos en Python. En este tutorial, aprender√°s c√≥mo realizar muchas operaciones en arreglos NumPy, como a√±adir, eliminar, ordenar y manipular elementos de muchas maneras. NumPy proporciona un objeto el cual es un arreglo multidimensional y otras matrices derivadas, como matrices enmascaradas o matrices"
      },
      {
        "id": 2,
        "autor": "Kiko Correoso",
        "pagina": "pybonacci",
        "fecha": "14/05/2012",
        "titulo": "Manual de introducci√≥n a matplotlib.pyplot (I): Primeros pasos",
        "link": "https://pybonacci.org/2012/05/14/manual-de-introduccion-a-matplotlib-pyplot-i/",
        "contenido": "Saltar al contenido ALTERNAR LA NAVEGACI√ìN Manual de introducci√≥n a matplotlib.pyplot (I): Primeros pasos por Kiko Correoso2012-05-14Tutoriales7 comentarios Etiquetas:gr√°ficosmatplotlibmatplotlib.pyplotpyplotpythontutorial matplotlib.pyplot Este art√≠culo se actualiz√≥ el 2020/04/18 para usar las √∫ltimas versiones de las bibliotecas que se comentan. Esto pretende ser un tutorial del m√≥dulo pyplot de la librer√≠a matplotlib. El tutorial lo dividiremos de la siguiente forma (que podr√° ir cambiando a medida que vayamos avanzando). Primeros pasos Creando ventanas, manejando ventanas y configurando la sesi√≥n Configuraci√≥n del gr√°fico Tipos de gr√°fico I Tipos de gr√°fico II Tipos de gr√°fico III Tipos de gr√°fico IV Texto y anotaciones (arrow, annotate, table, text‚Ä¶) Herramientas estad√≠sticas (acorr, cohere, csd,  psd, specgram, spy, xcorr, ‚Ä¶) Eventos e interactividad (connect, disconnect, ginput, waitforbuttonpress‚Ä¶) Miscel√°nea [Para este tutorial se ha usado python 3.7.6, ipython 7.13.0, numpy 1.17.2 y matplotlib 3.1.1] En todo momento supondremos que se ha iniciado la sesi√≥n y se ha hecho import matplotlib.pyplot as plt import numpy as np 1 2 import matplotlib.pyplot as plt import numpy as np Para empezar diremos que hay tres formas de usar la librer√≠a Matplotlib: La podemos usar desde python usando el m√≥dulo pylab. El m√≥dulo pylab pretende mostrar un entorno de trabajo parecido al de matlab mezclando las librer√≠as numpy y matplotlib. Es la forma menos pyth√≥nica de usar matplotlib y se obtiene usando: from pylab import * 1 from pylab import * Normalmente solo se recomienda para hacer pruebas r√°pidas desde la l√≠nea de comandos. Una segunda forma, que es la que veremos en este tutorial, es usando el m√≥dulo pyplot. import matplotlib.pyplot as plt 1 import matplotlib.pyplot as plt Por √∫ltimo, la forma m√°s recomendable y pyth√≥nica, pero m√°s compleja, ser√≠a usar matplotlib mediante la interfaz orientada a objetos. Cuando se programa con matplotlib, no mientras se trabaja interactivamente, esta es la forma que permite tener m√°s control sobre el c√≥digo. Quiz√° veamos esto en el futuro si alguno nos animamos/os anim√°is a escribir sobre ello. Absolutamente todo lo que vamos a usar en este tutorial y que est√° relacionado con matplotlib.pyplot lo podr√©is encontrar documentado y detallado aqu√≠. Como he comentado, todo lo que vamos a ver est√° en el anterior enlace, pero no todo lo que est√° en el anterior enlace lo vamos a ver. Por ejemplo, en el √≠ndice ver√©is que he tachado los puntos 9 y 10, las funciones estad√≠sticas y las funciones que permiten meter algo de interactividad en los gr√°ficos dentro de pyplot. Las funciones estad√≠sticas incluidas son pocas, algunas son complejas y muy espec√≠ficas y las veo poco coherentes como grupo dentro de pyplot, para ello ya tenemos scipy y estas funciones estar√≠an mejor ah√≠ para separar lo que es ‚Äògr√°ficar‚Äô (en espa√±ol de Sud√°merica existe la palabra) de lo que es analizar datos. Para interactividad con los gr√°ficos tenemos el m√≥dulo matplotlib.widgets, much√≠simo m√°s completo. Para que quede claro desde un principio, las dos zonas principales donde se dibujar√°n cosas o sobre las que se interactuar√° ser√°n: figure, que es una instancia de matplotlib.figure.Figure. Y es la ventana donde ir√° el o los gr√°ficos en s√≠: axes, que es una instancia de matplotlib.axes.Axes, que es el gr√°fico en s√≠ donde se dibujar√° todo lo que le digamos y est√° localizada dentro de una figure. Para lo primero (figure) usaremos la palabra ‚Äòventana‚Äô mientras que para lo segundo (axes) usaremos la palabra ‚Äògr√°fico‚Äô. Si quieres puedes pasar a la siguiente secci√≥n. ANTERIOR C√≥mo crear una matriz tridiagonal en Python con NumPy y SciPy SIGUIENTE Manual de introducci√≥n a matplotlib.pyplot (II): Creando y manejando ventanas y configurando la sesi√≥n 7 comentarios en ¬´Manual de introducci√≥n a matplotlib.pyplot (I): Primeros pasos¬ª JUANLU001 el 2012-05-25 a las 18:23 Kiko, ¬øte parece si a√±ades o me das permiso para a√±adir la etiqueta ¬´python¬ª a tus entradas? Es para que salgan aqu√≠ http://es.wordpress.com/#!/read/topic/python/ ¬°Muchas gracias por estos tutoriales! Estoy aprendiendo un mont√≥n üòõ Responder Pingback: Pybonacci estrena canal en Youtube ¬´ Pybonacci Pingback: Bitacoras.com Pingback: Rese√±a del libro ‚ÄúLearning NumPy Array‚Äù de Ivan Idris | Pybonacci Pingback: Pybonacci estrena canal en Youtube | Pybonacci AN√ìNIMO el 2014-12-27 a las 23:42 Buen d√≠a, agradeci√©ndole por los tutoriales. Mi consulta es la siguiente, Puedo cambiar el tama√±o del texto en las gr√°ficas que sale por defecto?? como en los ejes x,y en leyendas etc?? Responder KIKO el 2014-12-28 a las 10:02 Le puedes echar un ojo a http://matplotlib.org/api/matplotlib_configuration_api.html#matplotlib.rc Unas l√≠neas m√°s abajo en el enlace ver√°s como configurar la fuente de texto. Puedes configurar casi cualquier aspecto de matplotlib de forma permanente usando los par√°metros rc de configuraci√≥n, http://matplotlib.org/users/customizing.html. Responder Deja una respuesta Tu direcci√≥n de correo electr√≥nico no ser√° publicada. Los campos obligatorios est√°n marcados con * Comentario Nombre * Correo electr√≥nico * Web Guarda mi nombre, correo electr√≥nico y web en este navegador para la pr√≥xima vez que comente. Captcha matem√°tico ‚àí one = two Python, ciencia, comunidad y conocimiento libre | üÑØ  "
      },
      {
        "id": 3,
        "autor": "Andrea Aranda",
        "pagina": "crehana",
        "fecha": "06/04/2021",
        "titulo": "15 librer√≠as Python m√°s populares para ser el mejor programador este 2021",
        "link": "https://www.crehana.com/cl/blog/web/librerias-python/",
        "contenido": "Dentro del internet, Python se convirti√≥ en uno de los lenguajes de programaci√≥n con mayor demanda y aceptaci√≥n en el mercado, no solo a nivel comercial sino tambi√©n empresarial. El uso de las librer√≠as Python se volvieron m√°s populares gracias a su flexibilidad y eficiencia al crear aplicaciones de escritorio. Son librer√≠as muy √∫tiles que te ayudar√°n a convertirte en el mejor programador. Podr√°s ser capaz de desarrollar aplicaciones web, apps, datos, operaciones y m√°s. Si tienes conocimientos de programaci√≥n y quieres conocer cu√°les son las mejores librer√≠as Python, entonces este blog es para ti. üòä ¬°Comencemos! ¬øQu√© son las librer√≠as de programaci√≥n? En los espacios inform√°ticos, una librer√≠a o biblioteca es el conjunto de implementos funcionales que te ayudan a codificar lenguajes de programaci√≥n para crear una interfaz independiente. Las librer√≠as tienen la libertad de ser utilizadas por otros programas independientes y simult√°neamente. A su vez, se pueden apoyar mutuamente entre librer√≠as para definir o refinar el comportamiento de la biblioteca original. Tambi√©n se la coloca en disposici√≥n de otra tecnolog√≠a o lenguaje de programaci√≥n. Seg√∫n el v√≠nculo que se quiera establecer, las bibliotecas tienen la capacidad de vincularse a otros programas o librer√≠as seg√∫n la clasificaci√≥n que tenga. La gran mayor√≠a de sistemas operativos actuales proporcionan librer√≠as para implementar c√≥digos que se usan en cualquier aplicaci√≥n moderna. que-son-librerias-programacion Fuente: Unsplash ¬øQu√© son las librer√≠as Python? El lenguaje Python presenta una sintaxis y sem√°ntica referente a la biblioteca est√°ndar. Existen muchos componentes opcionales que se incluyen en las distribuciones de Python y esto le permite al sistema contar con la portabilidad de los programas. Las librer√≠as Python son amplias, con gran cantidad de producciones en contenidos. Consta de m√≥dulos que permiten el acceso de funcionalidades del sistema como entrada y salida de archivos, soluciones estandarizadas a problemas de programaci√≥n, etc. Los m√≥dulos en Python se encargan de alentar y reforzar la portabilidad de programas que separan especificaciones de la plataforma y conseguir APIs neutrales. que-son-librerias-python Fuente: Unsplash Dependiendo del sistema operativo que tengas puedes conseguir diferentes funciones. Por ejemplo, para el sistema Windows se incluye la biblioteca est√°ndar completa junto con componentes adicionales. Un plus para las librer√≠as Python es que cuenta con una colecci√≥n de miles de componentes como programas individuales, m√≥dulos, paquetes, frameworks, aplicaciones y mucho m√°s que encuentras en Python Package Index. ¬°Desarrolla tu p√°gina web! Descarga esta lista de etiquetas HTML y propiedades CSS para conocer sobre lenguajes de programaci√≥n listas-html-css-crehana ¬øC√≥mo instalar librer√≠as Python? Al crear tus propios programas en Python debes hacer uso de librer√≠as y m√≥dulos externos que necesitas instalar en tu computadora. En este paso a paso encontrar√°s el proceso de instalar librer√≠as Python con el uso del m√≥dulo ‚Äúpip‚Äù y el m√©todo ‚Äú.main()‚Äù. Es muy sencillo si trabajas con la versi√≥n 3.7 de Python, ya que te ayudar√° a emplear todas sus funcionalidades de manera exitosa. ¬øListo? ü§© Paso 1: Encontrar archivos Scripts y pip Antes de comenzar la operaci√≥n, debes asegurarte que tienes la versi√≥n de Python correcta, de lo contrario no encontrar√°s las carpetas que mencionaremos a continuaci√≥n. Dir√≠gete a la carpeta Python y en su interior dale clic a ‚ÄúScripts‚Äù. Encontrar√°s varios m√≥dulos del sistema, pero solo nos interesa abrir el que se llama ‚Äúpip‚Äù. archivos-scripts-librerias-python Fuente: Programaci√≥nPython Paso 2: Copiar ruta de direcci√≥n Dentro del archivo ‚Äúpip‚Äù encontrar√°s un c√≥digo, el cual deber√°s pegar en el cmd del sistema que tengas. Una vez que este paso est√° hecho, introduce la orden ‚Äúpip install‚Äù con el nombre de la librer√≠a o m√≥dulo que quieres instalar. ruta-direccion-librerias-python Fuente: Programaci√≥nPython Paso 3: Ejecutar la orden Una vez que se haya colocado la orden de instalar ‚Äúpip‚Äù se proceder√° a iniciar la instalaci√≥n. Si has seguido todos los pasos en el orden indicado, no vas a presentar ning√∫n problema. ¬°Listo! Ya sabes instalar librer√≠as Python en el computador, con libre acceso para futuros proyectos. ejecutar-orden-librerias-python Fuente: Programaci√≥nPython Tipos de librer√≠as de programaci√≥n Las librer√≠as Python pueden ser utilizadas para muchas √°reas de programaci√≥n. Cada sistema cuenta con diferentes procesos que necesitan de un tipo de biblioteca espec√≠fica para resolver dicha funci√≥n. Te presentamos algunos tipos de librer√≠as de programaci√≥n para que elijas la que mejor se acomoda a tus necesidades. ‚úÖ Visualizaci√≥n: Para entender mejor los datos y tener una mejor comprensi√≥n del problema, las librer√≠as Python de visualizaci√≥n m√°s recomendadas son: Matplotlib, Bokeh y Seaborn. ‚úÖ C√°lculo Num√©rico: La preparaci√≥n de datos y c√°lculo de atributos relevantes sirven para enfrentar problemas gracias al an√°lisis de datos. Las m√°s usadas son: NumPy, SciPy, Pandas y Numba. ‚úÖ Machine Learning: La construcci√≥n de este modelo consume poco tiempo gracias al aprendizaje autom√°tico que te brindan librer√≠as como Scikit-Learn. ‚úÖ Deep Learning: Este tipo de librer√≠as Python tienen un aprendizaje profundo y se reflejan en bibliotecas como TensorFlow, Keras, PyTorch. ‚úÖ Inteligencia Artificial Explicable: Aplica m√©todos y t√©cnicas tecnol√≥gicas que aplican inteligencia artificial para brindar resultados eficientes. La librer√≠a m√°s usada es SHAP. ‚úÖ Procesamiento de Lenguaje Natural: Utiliza el c√°lculo de frecuencias normalizadas y construir modelos con datos de texto. Las m√°s usadas son: Gensim, SpaCy y NLTK. tipos-librerias-python Fuente: Unsplash 15 mejores librer√≠as Python ¬°Ahora s√≠! La informaci√≥n que estabas esperando. ü§© Si manejas el lenguaje de programaci√≥n, estas librer√≠as Python te ser√°n muy √∫tiles. ¬°Lo mejor de todo es que estas librer√≠as son totalmente gratuitas! 1. Matplotlib Matplotlib es una de las librer√≠as Python m√°s usadas, gracias a su procesamiento y generador de gr√°ficos con amplia calidad. Puedes publicar estos datos de manera f√≠sica bajo impresi√≥n como tambi√©n digitalmente. Utiliza trazados 2D y muchos tipos de gr√°ficos que se crean con pocas l√≠neas de c√≥digo. Algunos ejemplos son: histogramas, diagramas de barras, espectros de potencia, series temporales, diagramas de errores, etc. marplotlib-librerias-python Fuente: Matplotlib 2. Seaborn Seaborn es una librer√≠a gr√°fica especializada en la visualizaci√≥n de datos estad√≠sticos. Dentro de sus principales caracter√≠sticas se encuentra una interfaz de alto nivel, atractiva e interactiva. Al ser de tipo visualizaci√≥n, este se considera como el aspecto m√°s importante y fundamental en su funcionamiento, ya que se pone en pr√°ctica al momento de esclarecer los datos. Es compatible con otras librer√≠as Python como Pandas y Matplotlib. seaborn-librerias-python Fuente: Seaborn 3. Boken Bokeh te ayuda a visualizar los datos desde una perspectiva m√°s interactiva dentro de un navegador web. Puedes crear gr√°ficos elegantes y vers√°tiles, gracias a sus desarrolladores de buen rendimiento. Logras trabajar con datos que llegan en tiempo real. boken-librerias-python Fuente: Boken 4. NumPy NumPy te permite crear una estructura universal de datos para facilitar su an√°lisis e intercambio de varios algoritmos. Al igual que varias librer√≠as Python, esta implementa vectores multidimensionales y matrices que almacenan una cantidad de datos grande. A su vez, posee funciones matem√°ticas de alto nivel y utiliza estructuras de datos. numpy-librerias-python Fuente: NumPy 5. SciPy SciPy te permite crear rutinas num√©ricas con estructura de datos. Es sencillo de usar y operar, incorpora las siguientes funciones: optimizaci√≥n, integraci√≥n num√©rica, √°lgebra lineal, estad√≠stica, transformadas de Fourier, etc. scipy-librerias-python Fuente: SciPy 6. Pandas Pandas es una de las librer√≠as Python m√°s √∫til y direccionada a los datos cient√≠ficos. Sus principales datos se conforman por Series de datos y el DataFrame para dos dimensiones. Se utiliza m√°s en campos como finanzas, ciencias sociales, estad√≠stica e ingenier√≠a. Es sencillo de usar y accesible para manipular datos. pandas-librerias-python Fuente: Pandas 7. Numba Numba es una librer√≠a de programaci√≥n que traduce funciones optimizadas, gracias al est√°ndar industrial LLVM. Sus algoritmos num√©ricos alcanzan una velocidad muy alta en su ejecuci√≥n. Solo necesitas un compilador de C/CC++ para optimizar la velocidad de tu c√≥digo. La herramienta es inteligente para hacerse cargo de todo el proceso, tan solo aplica uno de los decoradores para automatizar la secuencia. numba-librerias-python Fuente: Numba 8. Scikit-Learn Scikit-Learn es una de las librer√≠as Python que cuenta con Machine Learning y an√°lisis de datos. Es una herramientas muy f√°cil de usar gracias a sus m√∫ltiples t√©cnicas de aprendizaje autom√°tico. Puedes utilizarlo para resolver problemas de clasificaci√≥n y de regresi√≥n, tales como m√°quinas de vectores de soporte, √°rboles de decisi√≥n, regresi√≥n lineal y polin√≥mica, clustering, reducci√≥n de dimensionalidad, etc. Su interfaz es simple y consistente, se puede moldear solo con una l√≠nea de c√≥digo. scikitlearn-librerias-python Fuente: Scikit-Learn 9. TensorFlow TensorFlow forma parte de las librer√≠as Python que fue desarrollada por Google. Te permite realizar c√°lculos num√©ricos gracias a diagramas de flujo de datos. El proceso consta de codificar un grafo compuesto por nodos que son operaciones matem√°ticas, junto con aristas que representan los tensores. Esta librer√≠a de programaci√≥n se usa para varias aplicaciones de c√°lculo cient√≠fico como Deep Learning. tensorflow-librerias-python Fuente: TensorFlow 10. Keras Keras cuenta con un alto nivel en su interfaz de trabajo, gracias a las redes neuronales. Su principal caracter√≠stica es la facilidad de uso. Comparte funciones similares a otras librer√≠as Python como TensorFlow y CNTK, pero esta librer√≠a en particular puede calcular si una idea va a tener buenos resultados. keras-librerias-python Fuente: Keras 11. PyTorch PyTorch fue desarrollada por Facebook. Te ayuda a obtener un c√°lculo num√©rico eficiente en c√≥digos CPU y GPUs. Es una librer√≠a de programaci√≥n que gracias a las tarjetas gr√°ficas puedes ejecutar tu c√≥digo mucho m√°s r√°pido. Utiliza c√°lculos matriciales y derivadas masivas, utiliza el aprendizaje profundo conocido como Deep Learning. pytorch-librerias-python Fuente: PyTorch 12. SHAP SHAP es una librer√≠a Python que trabaja con Inteligencia Artificial Explicable. Forma parte de las t√©cnicas de Machine Learning, ya que realiza c√°lculos en el campo te√≥rico de juegos, estudiando las variables con m√°s influencia en sus predicciones. Al igual que varias librer√≠as Python, SHAP te ayuda a entender las decisiones en modelos de redes neuronales, puestas en pr√°ctica a nivel individual y global. shap-librerias-python Fuente: SHAP 13. NLTK NLTK, conocida como Natural Language Toolkit por sus siglas en ingl√©s, es una de las librer√≠as m√°s antiguas. Hasta el d√≠a de hoy se utiliza gracias a la eficiencia que posee en las tareas de procesamiento. Incorpora la lematizaci√≥n, tokenizaci√≥n, exclusi√≥n de palabras irrelevantes y mucho m√°s. Se utiliza como herramienta de estudio y ense√±anza. nltk-librerias-python Fuente: NLTK 14. Gensim Gensim se caracteriza por ser una librer√≠a de lenguaje natural. Su mayor diferencial es el modelado de temas, ya que puede identificar autom√°ticamente el fondo de un conjunto de documentos. Puedes importar presentaciones de vectores y construir an√°lisis de similitud al momento de realizar b√∫squedas. gensim-librerias-python Fuente: Gensim 15. SpaCy SpaCy tambi√©n es una librer√≠a de procesamiento natural, pero esta tiene una caracter√≠stica mucho m√°s diferenciadora. Es la biblioteca m√°s r√°pida que existe en el mercado. Te permite enviar, rastrear y diseccionar paquetes de red. Puedes construir herramientas para sondear, escanear y atacar redes. Funciona con tareas de aprendizaje autom√°tico. spacy-librerias-python Fuente: SpaCy ¬øTe interesa alguna de estas librer√≠as Python? Todas son recomendadas al 100%, ya que son muy f√°ciles de manejar, te dan millones de beneficios y funcionalidades en su uso y optimizan los procesos que quieras implementar. Esperamos hayas disfrutado este blog tanto como nosotros. Antes de terminar queremos recomendarte este curso online para que conozcas m√°s sobre el lenguaje de programaci√≥n y el desarrollo web front end, con las herramientas de HTML y CSS. Esperemos te parezca interesante"
      },
      {
        "id": 4,
        "autor": "Jes√∫s Utrera Burgal",
        "pagina": "enmilocalfunciona",
        "fecha": "20/06/2018",
        "titulo": "Deep Learning b√°sico con Keras (Parte 1)",
        "link": "https://enmilocalfunciona.io/deep-learning-basico-con-keras-parte-1/",
        "contenido": "Keras es un framework de alto nivel para el aprendizaje, escrito en Python y capaz de correr sobre los frameworks TensorFlow, CNTK, o Theano. Fue desarrollado con el objeto de facilitar un proceso de experimentaci√≥n r√°pida. Lo que haremos en este experimento es entrenar modelos de clasificaci√≥n de im√°genes. Esto consiste en dada una serie de im√°genes etiquetadas, reconocer una imagen y asignarle dicha etiqueta (por ejemplo, si es la foto de un gato, el modelo reconocer√° que hay un gato). En este primer art√≠culo entrenaremos una red neuronal sencilla y, a partir de √©ste, iremos viendo unos cuantos algoritmos conocidos de deep learning y haremos unas cuantas comparativas. El objetivo de esta serie de art√≠culos es facilitar una gu√≠a sencilla de programaci√≥n en Python usando Keras para entrenar modelos de aprendizaje supervisado para un conjunto de datos concreto. Obviamente, los experimentos est√°n realizados con fines educativos por lo que el proceso de entrenamiento ser√° un proceso r√°pido y los resultados no estar√°n depurados. Enlace al art√≠culo original. Importando las librer√≠as necesarias En primer lugar, vamos a importar las librer√≠as necesarias. Importaremos las librer√≠as de numpy, TensorFlow (√©ste ser√° el framework sobre el que correr√° Keras), Keras y unas librer√≠as necesarias Scikit Learn, Pandas, etc. import numpy as np = 42 from scipy import misc from PIL import Image import glob import matplotlib.pyplot as plt import scipy.misc from matplotlib.pyplot import imshow %matplotlib inline from IPython.display import SVG import cv2 import seaborn as sn import pandas as pd import pickle from keras import layers from keras.layers import Flatten, Input, Add, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D, AveragePooling2D, MaxPooling2D, GlobalMaxPooling2D, Dropout from keras.models import Sequential, Model, load_model from keras.preprocessing import image from keras.preprocessing.image import load_img from keras.preprocessing.image import img_to_array from keras.applications.imagenet_utils import decode_predictions from keras.utils import layer_utils, np_utils from keras.utils.data_utils import get_file from keras.applications.imagenet_utils import preprocess_input from keras.utils.vis_utils import model_to_dot from keras.utils import plot_model from keras.initializers import glorot_uniform from keras import losses import keras.backend as K from keras.callbacks import ModelCheckpoint from sklearn.metrics import confusion_matrix, classification_report import tensorflow as tf Preparando el conjunto de datos Para el experimento, usaremos el conjunto de datos ampliamente usado CIFAR-100. Este conjunto de datos consta de 600 im√°genes por cada clase de un total de 100 clases. Se divide en 500 im√°genes para entrenamiento y 100 im√°genes para validaci√≥n por cada clase. Las 100 clases est√°n agrupadas en 20 superclases. Cada imagen tiene una etiqueta fina (la clase, de entre las 100, a la que pertenece) y una etiqueta gruesa (correspondiente a su superclase). El framework de Keras incluye el m√≥dulo para descargarlo directamente: from keras.datasets import cifar100 (x_train_original, y_train_original), (x_test_original, y_test_original) = cifar100.load_data(label_mode='fine') Actualmente, hemos descargado los datasets de entrenamiento y validaci√≥n. x_train_original y x_test_original son los conjuntos de datos con l√°s im√°genes de entrenamiento y validaci√≥n respectivamente, mientras que y_train_original y y_test_original son los datasets con las etiquetas. Veamos la forma de y_train_original: array([[19], [29], [ 0], ..., [ 3], [ 7], [73]]) Como se puede ver, se trata de un array donde cada n√∫mero se corresponde con la etiqueta concreta. Lo primero que hay que hacer es convertir este array en su versi√≥n one-hot-encoding (ver wikipedia). y_train = np_utils.to_categorical(y_train_original, 100) y_test = np_utils.to_categorical(y_test_original, 100) El siguiente paso es ver los datos de entrenamiento (xtrainoriginal) array([[[255, 255, 255], [255, 255, 255], [255, 255, 255], ..., [195, 205, 193], [212, 224, 204], [182, 194, 167]], [[255, 255, 255], [254, 254, 254], [254, 254, 254], ..., [170, 176, 150], [161, 168, 130], [146, 154, 113]], [[255, 255, 255], [254, 254, 254], [255, 255, 255], ..., [189, 199, 169], [166, 178, 130], [121, 133,  87]], ..., [[148, 185,  79], [142, 182,  57], [140, 179,  60], ..., [ 30,  17,   1], [ 65,  62,  15], [ 76,  77,  20]], [[122, 157,  66], [120, 155,  58], [126, 160,  71], ..., [ 22,  16,   3], [ 97, 112,  56], [141, 161,  87]], [[ 87, 122,  41], [ 88, 122,  39], [101, 134,  56], ..., [ 34,  36,  10], [105, 133,  59], [138, 173,  79]]], dtype=uint8) Bien, representa la imagen en los 3 canales RGB de 256 p√≠xeles. Vamos a verla: imgplot = plt.imshow(x_train_original[3]) plt.show() Lo que haremos a continuaci√≥n, es normalizar las im√°genes. Esto es, dividiremos cada elemento de x_train_original y xtestoriginal por el numero de p√≠xeles, es decir, 255. Con esto obtenemos que el array comprender√° valores de entre 0 y 1. Con esto el entrenamiento suele aportar mejores resultados. x_train = x_train_original/255 x_test = x_test_original/255 Preparando el entorno El siguiente paso es definir ciertos par√°metros sobre el experimento en Keras. Lo primero ser√° especificar a Keras d√≥nde se encuentran los canales. En un array de im√°genes, pueden venir como √∫ltimo indice o como el primero. Esto se conoce como canales primero (channels first) o canales al final (channels last). En nuestro caso, vamos a definirlos al final. K.set_image_data_format('channels_last') Lo siguiente que vamos a especificar es la fase del experimento. En este caso, la fase ser√° de entrenamiento: K.set_learning_phase(1) Entrenando una red neuronal sencilla En primer lugar, vamos a entrenar una red neuronal sencilla. Definimos un procedimiento que nos devuelva una red neuronal: def create_simple_nn(): model = Sequential() model.add(Flatten(input_shape=(32, 32, 3), name=Input_layer)) model.add(Dense(1000, activation='relu', name=Hidden_layer_1)) model.add(Dense(500, activation='relu', name=Hidden_layer_2)) model.add(Dense(100, activation='softmax', name=Output_layer)) return model La instrucci√≥n Flatten convierte los elementos de la matriz de imagenes de entrada en un array plano. Luego, con la instrucci√≥n Dense, a√±adimos una capa oculta (hidden layer) de la red neuronal. La primera tendr√° 1000 nodos, la segunda 500 y la tercera (capa de salida) 100. Para la funci√≥n de activaci√≥n usaremos en las capas ocultas ReLu y para la capa de salida SoftMax. Una vez definido el modelo, lo compilamos especificando la funci√≥n de optimizaci√≥n, la de coste o p√©rdida y las m√©tricas que usaremos. En este caso, usaremos la funci√≥n de optimizaci√≥n de descenso de gradiente estoc√°stico (stochactic gradient descent), la funci√≥n de p√©rdida de entrop√≠a cruzada (categorical cross entropy) y, para las m√©tricas, accuracy (o tasa de acierto) y mse (media de los errores cuadr√°ticos). Todas √©stas funciones ya vienen preimplementadas en Keras. snn_model = create_simple_nn() snn_model.compile(loss='categorical_crossentropy', optimizer='sgd', metrics=['acc', 'mse']) Una vez hecho esto, vamos a ver un resumen del modelo creado. snn_model.summary() _________________________________________________________________ Layer (type)                 Output Shape              Param # ================================================================= Input_layer (Flatten)        (None, 3072)              0 _________________________________________________________________ Hidden_layer_1 (Dense)       (None, 1000)              3073000 _________________________________________________________________ Hidden_layer_2 (Dense)       (None, 500)               500500 _________________________________________________________________ Output_layer (Dense)         (None, 100)               50100 ================================================================= Total params: 3,623,600 Trainable params: 3,623,600 Non-trainable params: 0 _________________________________________________________________ Podemos ver que, para ser un modelo simple de red neuronal, tiene que entrenar m√°s de 3 millones de par√°metros. Esta ser√° la raz√≥n por la que existe el aprendizaje profundo, ya que para entrenar redes muy complejas se necesitar√≠a entrenar de esta forma grandes cantidades de par√°metros. Ahora s√≥lo queda entrenar, para ello, haremos lo siguiente: snn = snn_model.fit(x=x_train, y=y_train, batch_size=32, epochs=10, verbose=1, validation_data=(x_test, y_test), shuffle=True) Le decimos a Keras que queremos usar para entrenar el dataset im√°genes normalizadas de entrenamiento con el array de etiquetas one-hot-encoding. Usaremos batches o bloques de 32 (reduciendo la necesidad de memoria) y daremos 10 vueltas completas (o epochs). Usaremos los datos para validar xtest e ytest. El proceso de entrenamiento lo iremos viendo a continuaci√≥n hasta terminar. El resultado del entrenamiento se guarda en la variable snn, de la cual, extraeremos el hist√≥rico de los datos del entrenamiento: Train on 50000 samples, validate on 10000 samples Epoch 1/10 50000/50000 [==============================] - 16s 318us/step - loss: 4.1750 - acc: 0.0740 - mean_squared_error: 0.0097 - val_loss: 3.9633 - val_acc: 0.1051 - val_mean_squared_error: 0.0096 Epoch 2/10 50000/50000 [==============================] - 15s 301us/step - loss: 3.7919 - acc: 0.1298 - mean_squared_error: 0.0095 - val_loss: 3.7409 - val_acc: 0.1427 - val_mean_squared_error: 0.0094 Epoch 3/10 50000/50000 [==============================] - 15s 294us/step - loss: 3.6357 - acc: 0.1579 - mean_squared_error: 0.0093 - val_loss: 3.6429 - val_acc: 0.1525 - val_mean_squared_error: 0.0093 Epoch 4/10 50000/50000 [==============================] - 15s 301us/step - loss: 3.5300 - acc: 0.1758 - mean_squared_error: 0.0092 - val_loss: 3.6055 - val_acc: 0.1626 - val_mean_squared_error: 0.0093 Epoch 5/10 50000/50000 [==============================] - 15s 300us/step - loss: 3.4461 - acc: 0.1904 - mean_squared_error: 0.0091 - val_loss: 3.5030 - val_acc: 0.1812 - val_mean_squared_error: 0.0092 Epoch 6/10 50000/50000 [==============================] - 15s 301us/step - loss: 3.3714 - acc: 0.2039 - mean_squared_error: 0.0090 - val_loss: 3.4600 - val_acc: 0.1912 - val_mean_squared_error: 0.0091 Epoch 7/10 50000/50000 [==============================] - 15s 301us/step - loss: 3.3050 - acc: 0.2153 - mean_squared_error: 0.0089 - val_loss: 3.4329 - val_acc: 0.1938 - val_mean_squared_error: 0.0091 Epoch 8/10 50000/50000 [==============================] - 15s 300us/step - loss: 3.2464 - acc: 0.2275 - mean_squared_error: 0.0089 - val_loss: 3.3965 - val_acc: 0.2013 - val_mean_squared_error: 0.0090 Epoch 9/10 50000/50000 [==============================] - 15s 301us/step - loss: 3.1902 - acc: 0.2361 - mean_squared_error: 0.0088 - val_loss: 3.3371 - val_acc: 0.2133 - val_mean_squared_error: 0.0089 Epoch 10/10 50000/50000 [==============================] - 15s 299us/step - loss: 3.1354 - acc: 0.2484 - mean_squared_error: 0.0087 - val_loss: 3.3233 - val_acc: 0.2154 - val_mean_squared_error: 0.0089 Aunque hemos evaluado durante el entrenamiento, podr√≠amos evaluarlo frente a otro dataset, por lo que expongo a continuaci√≥n c√≥mo hacerlo en Keras: evaluation = snn_model.evaluate(x=x_test, y=y_test, batch_size=32, verbose=1) evaluation 10000/10000 [==============================] - 1s 127us/step [3.323309226989746, 0.2154, 0.008915210169553756] Veamos las m√©tricas obtenidas para el entrenamiento y validaci√≥n gr√°ficamente (para ello usamos la librer√≠a matplotlib): plt.figure(0) plt.plot(snn.history['acc'],'r') plt.plot(snn.history['val_acc'],'g') plt.xticks(np.arange(0, 11, 2.0)) plt.rcParams['figure.figsize'] = (8, 6) plt.xlabel(Num of Epochs) plt.ylabel(Accuracy) plt.title(Training Accuracy vs Validation Accuracy) plt.legend(['train','validation']) plt.figure(1) plt.plot(snn.history['loss'],'r') plt.plot(snn.history['val_loss'],'g') plt.xticks(np.arange(0, 11, 2.0)) plt.rcParams['figure.figsize'] = (8, 6) plt.xlabel(Num of Epochs) plt.ylabel(Loss) plt.title(Training Loss vs Validation Loss) plt.legend(['train','validation']) plt.show() "
      },
      {
        "id": 5,
        "autor": "research.iac.es",
        "fecha": "00/00/2019",
        "titulo": "La librer√≠a cient√≠fica Scipy",
        "link": "http://research.iac.es/sieinvens/python-course/source/scipy.html",
        "contenido": "Scipy es el paquete cient√≠fico (es decir, un m√≥dulo que tiene otros m√≥dulos) m√°s completo, que incluye interfases a librer√≠as cient√≠ficas muy conocidas como LAPACK, BLAS u ODR entre muchas otras . Si importamos scipy para tener su espacio de nombres y consultamos la ayuda, vemos todos los m√≥dulos que posee: In [1]: import scipy In [2]: help(scipy) cluster                      --- Vector Quantization / Kmeans fftpack                      --- Discrete Fourier Transform algorithms integrate                    --- Integration routines interpolate                  --- Interpolation Tools io                           --- Data input and output lib                          --- Python wrappers to external libraries lib.lapack                   --- Wrappers to LAPACK library linalg                       --- Linear algebra routines misc                         --- Various utilities that don't have another home. ndimage                      --- n-dimensional image package odr                          --- Orthogonal Distance Regression optimize                     --- Optimization Tools signal                       --- Signal Processing Tools sparse                       --- Sparse Matrices sparse.linalg                --- Sparse Linear Algebra sparse.linalg.dsolve         --- Linear Solvers sparse.linalg.dsolve.umfpack --- :Interface to the UMFPACK library: Conjugate Gradient Method (LOBPCG) sparse.linalg.eigen.lobpcg   --- Locally Optimal Block Preconditioned Conjugate Gradient Method (LOBPCG) [*] special                      --- Airy Functions [*] lib.blas                     --- Wrappers to BLAS library [*] sparse.linalg.eigen          --- Sparse Eigenvalue Solvers [*] stats                        --- Statistical Functions [*] lib                          --- Python wrappers to external libraries [*] lib.lapack                   --- Wrappers to LAPACK library [*] integrate                    --- Integration routines [*] ndimage                      --- n-dimensional image package [*] linalg                       --- Linear algebra routines [*] spatial                      --- Spatial data structures and algorithms special                      --- Airy Functions stats                        --- Statistical Functions Ajustes lineales y no lineales Si simplemente necesitamos hacer ajustes b√°sicos de polinomios, lo podemos hacer f√°cilmente s√≥lo con numpy: # Librer√≠a numpy import numpy as np # Datos experimentales x = np.array([ 0.,  1.,  2.,  3.,  4.]) y = np.array([ 10.2 ,  12.1,  15.5 ,  18.3,  20.6 ]) # Ajuste a una recta (polinomio de grado 1) p = np.polyfit(x, y, 1) print(p) # imprime [ 2.7   9.94] en este ejemplo np.polyfit() devuelve la lista de par√°metros p de la recta, por lo que el modelo lineal f(x)=ax+b de nuestros datos ser√°: y(x)=p0x+p1=2.7x+9.94 Ahora podemos dibujar los datos experimentales y la recta ajustada: from matplotlib import pyplot as plt # Valores de y calculados del ajuste y_ajuste = p[0]*x + p[1] # Dibujamos los datos experimentales p_datos, = plt.plot(x, y, 'b.') # Dibujamos la recta de ajuste p_ajuste, = plt.plot(x, y_ajuste, 'r-') plt.title('Ajuste lineal por minimos cuadrados') plt.xlabel('Eje X') plt.ylabel('Eje Y') plt.legend(('Datos experimentales', 'Ajuste lineal'), loc=upper left) plt.show() ../_images/polyfit.png Como se ve en este ejemplo, la salida por defecto de np.polyfit() es un array con los par√°metros del ajuste. Sin embargo, si se pide una salida detalla con el par√°metro full=True (por defecto full=False), el resultado es una tupla con el array de par√°metros, el residuo, el rango, los valores singulares y la condici√≥n relativa. Nos interesa especialmente el residuo del ajuste, que es la suma cuadr√°tica de todos los res√≠duos ‚àëni=1|yi‚àíf(xi)|2. Para el ejemplo anterior tendr√≠amos lo siguiente: # Ajuste a una recta, con salida completa resultado = np.polyfit(x, y, 1, full=True) print(resultado) Imprime tupla (array([ 2.7 ,  9.94]),                 # Par√°metros del ajuste array([ 0.472]),                       # Suma de residuos 2,                                     # Rango de la matriz del sistema array([ 2.52697826,  0.69955764]),     # Valores singulares 1.1102230246251565e-15)                # rcond Ajuste de funciones generales Si queremos hacer un ajuste general, no necesariamente polin√≥mico, debemos usar alguno de los m√©todos del paquete optimize, que contiene varios optimizadores locales y globales. El m√°s com√∫n es leastsq que, al ser un optimizador, hay que definir previamente una funci√≥n residuo que es la que realmente se va minimizar. import numpy as np from matplotlib import pyplot as plt from scipy.optimize import leastsq # Datos de laboratorio datos_y = np.array([ 2.9, 6.1, 10.9, 12.8, 19.2]) datos_x = np.array([ 1.0, 2.0, 3.0, 4.0, 5.0]) # Funci√≥n para calcular los residuos, donde # se calcula (datos - modelo) def residuos(p, y, x): error  = y - (p[0]*x + p[1]) return error # Par√°metros iniciales estimados # y = p0[0]*x  + p0[0] p0 = [2.0, 0.0] # Hacemos  el ajuste por minimos cuadrados con leastsq(). El primer par√°metro # es la funcion de residuos, luego los par√°metro iniciales y una tupla con los # argumentos de la funcion de residuos, en este caso, datos_y y datos_x en # ese orden, porque as√≠ se defini√≥ la funci√≥n de error ajuste = leastsq(residuos, p0, args=(datos_y, datos_x)) # El resultado es una lista, cuyo primer elemento es otra # lista con los par√°metros del ajuste print(ajuste[0]) # array([ 3.93, -1.41]) Veamos otro ejemplo para ajustar una funci√≥n seno: import numpy as np from matplotlib import pyplot as plt from scipy.optimize import leastsq from scipy import random # Generamos unos datos artificiales para hacer el ejemplo # A datos_y se le a√±ade ruido que simula error de # medida, a√±adiendole un valor aleatorio datos_x = np.arange(0, 0.1, 0.003) A, k, theta = 10.0, 33.3, pi/5.0 y_real = A*np.sin(2*np.pi*k*datos_x + theta) datos_y = y_real + 2*random.randn(len(datos_x)) # Ahora se trata de ajustar estos datos una funci√≥n # modelo tipo senoidal A*sin(2*pi*k*x + theta) # Defino la funcion de residuos def residuos(p, y, x): A, k, theta = p error = y - A*np.sin(2*np.pi*k*x + theta) return error # Par√°metros iniciales # y = p[0]*np.sin(2*np.pi*p[1]*x + p[2]) # Si estos se alejan mucho del valor real # la soluci√≥n no converger√° p0 = [8.0, 40.0, pi/3] # hacemos  el ajuste por minimos cuadrados ajuste = leastsq(residuos, p0, args=(datos_y, datos_x)) # El resultado es una lista, cuyo primer elemento es otra # lista con los par√°metros del ajuste. print(ajuste[0]) # array([ -9.787095  ,  32.91201348,  -2.3390355 ] # Ahora muestro los datos y el ajuste gr√°ficamente plot(datos_x, datos_y, 'o')  # datos # Defino la funcion modelo, para representarla gr√°ficamente def funcion(x, p): return p[0]*np.sin(2*np.pi*p[1]*x + p[2]) # genero datos a partir del modelo para representarlo x1 = arange(0, datos_x.max(), 0.001)  # array con muchos puntos de x y1 = funcion(x1, ajuste[0])           # valor de la funcion modelo en los x plt.plot(x1, y1, 'r-') plt.xlabel('Eje X') plt.ylabel('Eje Y') plt.title('Ajuste de funcion seno con leastsq') plt.legend(('Datos', 'Ajuste lineal')) plt.show() ../_images/leastsq.png Este ejemplo es bastante alaborado porque hemos usado un optimizador general para hacer un ajuste, pero podemos usar curve_fit() para ahorrarnos la funci√≥n residuo. La anterior es una manera artesanal de hacer el ajuste, al construir la funci√≥n de error. Para un ajuste de datos from scipy.optimize import curve_fit curve_fit(funcion, datos_x, datos_y, p0) (array([ -9.787095  ,  32.91201348,  -2.3390355 ]), array([[ 0.20148401, -0.00715614,  0.00215931], [-0.00715614,  0.07184634, -0.02241144], [ 0.00215931, -0.02241144,  0.00925902]])) Vamo a probar esto con una ley de decaimiento exponencial: # Cargo los datos experimentales a un array # Los datos est√°n delimitados por ; y uso unpack # para que ponga primero las columas y pueda desenpaquetarlas # en  variables tiempo, masa, error = np.loadtxt(medidas_radio.txt, delimiter=;, unpack=True) # Compruebo como ser ven los datos plot(tiempo, masa, '.') def decaimiento(x, a, b): Ley de decaimiento exponencial return a * exp(-b*x) # Ajuste de los datos # curve_fit devuelve dos variables, los par√°metros del ajuste y # la matriz de covarianza popt, pcov = curve_fit(decaimiento, tiempo, masa) # Ahora creo una curva te√≥rica a partir del modelo ajustado times = np.arange(0, 100, 0.1) model = decaimiento(times, *popt) plt.plot(times, model, '-r') plt.legend(('Medidas', 'Ajuste')) plt.xlabel(Tiempo (s)) plt.ylabel(Masa (g)) plt.title(Ajuste de decaimiento exponencial) # Guardo la grafica plt.savefig(ajuste.png) # Para mostrar la gr√°fica por pantalla plt.show() ../_images/ajuste-exp.png Interpolaci√≥n de datos El m√≥dulo interpolate contiene rutinas de interpolaci√≥n basadas en la conocida librer√≠a FITPACK en Fortran; resulta muy √∫til en partes de datos donde no hay suficientes medidas. Los interpoladores funcionan creando una funci√≥n interpoladora de orden predefinido, usando los datos de medidas. Luego se aplica esta funci√≥n de interpolaci√≥n a un array de datos m√°s denso que la muestre. Consideremos los datos senoidales que vimos antes: from scipy.interpolate import interp1d interpolador_lineal = interp1d(datos_x, datos_y) interpolador_cubico = interp1d(datos_x, datos_y, kind='cubic') x_inter = linspace(0.01, 0.09, 500) y_inter_l = interpolador_lineal(x_inter) y_inter_c = interpolador_cubico(x_inter) plt.plot(datos_x, datos_y, 'ok', label=Datos) plt.plot(x_inter, y_inter_l, 'r', label=Interpolaci√≥n lineal) plt.plot(x_inter, y_inter_c, 'y', label=Interpolaci√≥n c√∫bico) # Si usamos InterpolatedUnivariateSpline podemos interpolar fuera # del rango de los datos from scipy.interpolate import InterpolatedUnivariateSpline # Array de valores m√°s denso que los datos originales, pero # dentro del rango de los datos x_inter = np.linspace(-0.01, 0.11, 500) interpolador = InterpolatedUnivariateSpline(datos_x, datos_y, k=2) y_inter_u = interpolador(x_inter) plot(x_inter, y_inter_u, 'k', lw=0.5, label=Interpolador univariable) xlim(-0.003, 0.102) ylim(-14, 15) legend() Aunque este es el m√©todo m√°s usado para interpolar, tiene el problema que no permite interpolar puntos fuera del rango de las medidas. Esto se puede resolver con la funci√≥n InterpolatedUnivariateSpline() ../_images/interp_univar.png Integraci√≥n num√©rica Intentemos integrar num√©ricamente la integral: ‚à´2‚àí22‚àóexp(‚àíx25) dx def func1(x): return 2.0*exp(-x**2/5.0) # integraci√≥n entre -2 y +2 int1, err1 = integrate.quad(func1, -2, +2) print(int1,err1) (6.294530963693763, 6.9883332051087914e-14) Si ahora hacemos la misma integral pero desde ‚àí‚àû hasta +‚àû obtendremos toda el √°rea bajo la curva definida en el integrando: # integraci√≥n entre -infinito y +infinito In [10]: int2, err2 = integrate.quad(func1, -Inf, +Inf) # y el resultado obtenido es: In [11]: print(int1, err1) (7.9266545952120211, 7.5246691415403668e-09) Manipulaci√≥n de arrays 2D: im√°genes El m√≥dulo ndimage ofrece manipulaci√≥n y filtrado b√°sicos de im√°genes, dados como array de numpy. In [20]: from scipy import misc In [21]: from scipy import ndimage as nd In [22]: img = misc.face(gray=True) In [23]: shifted_img = nd.shift(img, (50, 50)) In [24]: shifted_img2 = nd.shift(img, (50, 50), mode='nearest') In [25]: rotated_img = nd.rotate(img, 30) In [26]: cropped_img = img[50:-50, 50:-50] In [27]: zoomed_img = nd.zoom(img, 2)  # Interpola la imagen In [28]: zoomed_img.shape # (1536, 2048) In [30]: noisy_img = np.copy(img).astype(np.float) In [31]: noisy_img += img.std()*0.5*np.random.standard_normal(img.shape) In [32]: blurred_img = nd.gaussian_filter(noisy_img, sigma=3) In [33]: median_img = nd.median_filter(blurred_img, size=5) In [34]: from scipy import signal In [35]: wiener_img = signal.wiener(blurred_img, (5,5)) In [40]: plt.subplot(221) In [41]: plt.imshow(img) In [42]: plt.subplot(222) In [43]: plt.imshow(blurred_img) In [44]: plt.subplot(223) In [45]: plt.imshow(median_img) In [46]: plt.subplot(224) In [47]: plt.imshow(wiener_img) ../_images/ndimage_filters.png Para m√°s utilidades de manipulaci√≥n de im√°genes m√°s sofisticadas conviene usar http://scikit-image.org o http://opencv.org M√≥dulo de constantes f√≠sicas Scipy contiene un pr√°ctico m√≥dulo de constantes f√≠sicas. In [1]: from scipy import constants as C In [2]: C.c  # Velocidad de la luz en m/s Out[2]: 299792458.0 In [4]: C.e  # Carga del electr√≥n Out[4]: 1.602176565e-19 In [6]: C.atmosphere Out[7]: 101325.0 In [7]: C.mmHg Out[7]: 133.32236842105263 In [8]: C.Julian_year Out[8]: 31557600.0 In [9]: C.Avogadro Out[9]: 6.02214129e+23 In [10]: C.parsec Out[10]: 3.0856775813057292e+16 In [11]: C.Stefan_Boltzmann Out[11]: 5.670373e-08 In [13]: C.convert_temperature(np.array([0, 100.0]), 'Celsius', 'Kelvin')  # Conversor temps Out[13]: array([ 273.15,  373.15]) In [14]: C.day  # Dia en segundos Out[14]: 86400.0 In [15]: C.pico  # Prefijos del SI Out[15]: 1e-12 In [16]: C.oz Out[16]: 0.028349523124999998 In [17]: # Constantes f√≠sicas de CODATA 2014 In [18]: C.find('atm') Out[18]: ['standard atmosphere'] In [19]: C.physical_constants['standard atmosphere'] Out[19]: (101325.0, 'Pa', 0.0)"
      },
      {
        "id": 6,
        "autor": "Na8",
        "pagina": "Aprende Machine Learning",
        "fecha": "30/05/2019",
        "titulo": "Interpretaci√≥n de Modelos de Machine Learning",
        "link": "https://www.aprendemachinelearning.com/interpretacion-de-modelos-de-machine-learning/",
        "contenido": "Descifrar las decisiones tomadas por la m√°quina La interpretaci√≥n de las decisiones tomadas por nuestros algoritmos de Machine Learning pasa a un plano muy importante: para comprender el modelo y mejorarlo, evitar ‚Äúbiases‚Äù (√≥ descubrirlos), para justificar nuestra confianza en el modelo y hasta legalmente pues es requerido por leyes como la GDPR -para decisiones delicadas como puede ser dar √≥ no un cr√©dito a una persona-. Si nuestro algoritmo tuviera que detectar enfermedades y suponiendo que logramos una tasa de aciertos del 90% ¬øno te parecer√≠a l√≥gico comprender c√≥mo lo ha hecho? ¬øes puro azar? ¬øest√° teniendo en cuenta combinaciones de caracter√≠sticas que nosotros no contemplamos? Si de peque√±o eras curioso y quer√≠as sabes c√≥mo funcionaban las cosas: relojes, autos, √≥ hasta el mism√≠simo ordenador‚Ä¶ ser√°s un poco como yo‚Ä¶ y‚Ä¶ no siempre nos convence el concepto de ‚Äúcaja negra‚Äù. Abriendo la Caja negra El concepto de caja negra a veces es muy beneficioso, en sistemas decimos ‚Äúyo al m√©todo le tiro estos par√°metros y me devuelve true √≥ false‚Äù. Genial, con eso nos basta. Podemos trabajar en equipos distribuidos, intercambiar interfaces y listo. Podemos confiar en otras librer√≠as √≥ paquetes ‚Äúsin saber c√≥mo lo hacen‚Äù pero que nos resuelven problemas. Y las encajamos como piezas de un puzzle. Los algoritmos de Machine Learning, hasta ahora funcionaban muy de ese modo. Es decir, podemos hacer una red neuronal de 10 capas con 80 neuronas cada una, dropout, recurrencia y que nos d√© unas buenas clasificaciones. Pero ¬øqu√© pasa por dentro? ¬øc√≥mo hizo? ¬øes magia?‚Ä¶ esas oscuras √©pocas de incertidumbre deben acabar y deberemos tomar control de porqu√© se hacen las cosas como se hacen. ¬øQue hay dentro de la caja negra? Explainable Machine Learning Interpretar el Modelos en Machine Learning es la habilidad de explicar su funcionamiento √≥ presentarlo de manera comprensible al humano. ¬øPor qu√© es importante interpretar los modelos? Imaginemos que nuestro algoritmo decidir√° a qu√© empleado le daremos un ascenso, dadas sus caracter√≠sticas e historia en la empresa. Y luego de entrenar el modelo vemos que ‚Äúaparentemente da buenos resultados‚Äù pero‚Ä¶ todas las elecciones para puestos gerenciales son siempre para hombres y ninguna mujer‚Ä¶. mmmm.. sospechoso, ¬øno? Ese modelo ‚Äúaprendi√≥‚Äù que durante los √∫ltimos 10 a√±os, los cargos gerenciales de esa empresa siempre fueron para hombres. Si ese algoritmo pasa a producci√≥n, estar√° discriminando a las mujeres e impidiendo su ascenso. Entonces ¬øC√≥mo hacemos para interpretar el modelo? Respuesta corta: con otro modelo que ayude a los humanos a interpretar los procesos. Hay que decir que modelos como ‚Äú1 √°rbol de decisi√≥n peque√±o‚Äù √≥ clasificaci√≥n lineal, pueden llegar a interpretarse por su gr√°fica y/o f√≥rmula (repito: si son sencillos). Sin embargo un Random Forest √≥ las Redes Neuronales son complejas y pr√°cticamente imposibles de comprender <<de un vistazo>>. Los beneficios de la ‚Äúinterpretabilidad de los modelos ‚Äúson: Dar confiabilidad en los resultados. Ayudar en el Debugging. Informar a la Ingenier√≠a de Caracter√≠sticas (Feature Engineer). Detectar necesidad de colectar nuevas muestras. Ayudar a una persona en la toma de decisiones. Mayor seguridad/robustez en el modelo obtenido. T√©cnicas de Interpretaci√≥n de modelos Del an√°lisis de los modelos podemos obtener: Caracter√≠sticas m√°s importantes (features) Para una predicci√≥n en particular del modelo, el efecto que tuvo en ella cada caracter√≠stica Efecto de cada caracter√≠stica en el global de las predicciones del modelo Veamos algunas de esas t√©cnicas y qu√© librer√≠as de Python nos brindan estas funcionalidades: 1- Permutation Importance ¬øCuales de las features piensa el modelo que son m√°s importantes? ¬øQu√© Caracter√≠sticas tienen mayor impacto en las predicciones? Estos conceptos son conocidos como ‚ÄúFeature Importante‚Äù y ‚ÄúPermutation Importance‚Äù y nos sirven para calcular nuestras caracter√≠sticas de entrada al modelo. Nos sirve para poder ver cuando nuestro modelo est√° funcionando de manera contra-intuitiva y tambi√©n para demostrar a terceros cuando el funcionamiento es correcto. Para hacer Permutation Importante debemos primero entrenar un modelo y ‚Äúencajarlo‚Äù (fit). Luego tomamos el set de validaci√≥n y tomamos las features una por vez: por ejemplo, tomamos la primer columna de entrada y mezclamos todos sus valores entre sus filas (pero el resto de features se mantienen igual). Entonces hacemos predicci√≥n usando el mismo modelo entrenado y deber√≠an empeorar los resultados. Si ‚Äúdesmejoran mucho‚Äù es que esa feature era muy importante. En cambio, si no afecta demasiado, tampoco variar√°n mucho las predicciones obtenidas y quiere decir que esa caracter√≠stica no es relevante. Y as√≠ lo hacemos con todas las caracter√≠sticas, desordenando de a una a la vez. Podemos utilizar la librer√≠a ELI5 para Python para visualizar la Permutation Importance 2- Partial Dependence Plots (PDP) Los PDPs muestran el efecto marginal de una o dos caracter√≠sticas que tienen sobre la predicci√≥n dictada por un modelo. Los PDPs muestran c√≥mo afectan las distintas caracter√≠sticas a las predicciones. El PDP puede mostrar la relaci√≥n entre nuestra variable de salida y una √≥ dos caracter√≠sticas de entrada. Lo que hacemos en tomar de a una sola fila, e ir variando los valores de una sola de las features (que queremos investigar) contra un modelo YA entrenado. Entonces veremos en que intervalos esa caracter√≠stica afecta a los resultados del modelo. Lo podemos hacer hasta con 2 variables a la vez usando ‚Äú2D Partial Plots‚Äù y visualizarlo. Para esto podemos utilizar la librer√≠a PDPBox 3-SHAP Values (en predicciones individuales) SHAP viene de ‚ÄúShapley Additive exPlanation‚Äù y est√° basado en la teor√≠a de Juegos para explicar c√≥mo cada uno de los jugadores que intervienen en un ‚Äújuego colaborativo‚Äù contribuyen en el √©xito de la partida. Con esto podemos comprender una predicci√≥n y como impacta cada feature. Podemos decir que la interpretabilidad que nos ofrecen los valores SHAP es de las mejores. De manera muy sencilla -e incompleta- de c√≥mo se calculan estos valores podemos imaginar a una grupo de desarrolladores, testers, arquitectos y managers (features) que trabajan en conjunto (‚Äújuegan‚Äù/colaboran) para crear un Sistema de Software y queremos saber cu√°nto contribuy√≥ cada uno de ellos en su producci√≥n. Lo que haremos es ir intercalando a los participantes en diversos ‚Äúorden de aparaci√≥n‚Äù ABCD, ABDC, ADBC, etc. e ir midiendo la <<contribuci√≥n marginal>> de cada participante cada vez. Con ello sacar el promedio de cada uno y tendremos los valores Shapley que nos indican cu√°nto contribuyo cada jugador a conseguir el resultado obtenido. Supongamos que tenemos que explicar a una persona por qu√© se ha rechazado su solicitud de un cr√©dito -esto es, una √∫nica predicci√≥n, y no ‚Äúel accuracy global‚Äù del modelo- los valores SHAP nos muestran cuales caracter√≠sticas que alimentan al modelo <<empujan>> a la denegaci√≥n (√≥ aceptaci√≥n) esa petici√≥n en concreto. Utilizamos la librer√≠a SHAP para python para obtener estos valores. 4- Usos avanzados de Shap (comprensi√≥n global) Si recopilamos muchos valores Shap podremos tener una mejor comprensi√≥n del modelo en su conjunto. De all√≠ aparecen las gr√°ficas ‚ÄúShap Summary Plot‚Äù y ‚ÄúShap Dependence Contribution Plot‚Äù. Shap Summary Plot Calculando los Shap Values de cada muestra, podemos obtener esta Visualizaci√≥n que nos muestra cuales caracter√≠sticas son las m√°s importantes y el rango de valores donde afecta al set de datos. Shap Dependence Contribution Plot Esta gr√°fica es similar a la de los PDPs (vistos en el punto 2) pero nos dan mucho mayor detalle. No puedo dejar de mencionar a una gran librer√≠a para ML Interpretability llamada LIME (Local Interpretable Model Explanation) y que nos ofrece comprensi√≥n a humanos para modelos de NLP (destacando visualmente palabras en el texto) y para im√°genes clasificadas por una CNN (mostrando las √°reas en donde ‚Äúmira‚Äù la red). Tambi√©n mencionar otra Librer√≠a Python llamada Skater -es de Oracle- y aunque a√∫n est√° en desarrollo, provee de buenas herramientas. Conclusi√≥n La importancia de la interpretabilidad de los modelos de Machine Learning es crucial para poder justificar y comprender las predicciones y/o resultados obtenidos y hasta legalmente. Es curioso que necesitemos ‚Äúmodelos que expliquen como funcionan los modelos‚Äù para poder ‚Äúbajar‚Äù a entendimiento humano la complejidad de lo que ocurre en nuestras m√°quinas de aprendizaje. Finalmente, aplicando diversos m√©todos, Permutation Importance, los PDP y los Shap Values logramos obtener transparencia en nuestro desarrollo y un panorama claro sobre c√≥mo funciona nuestro engranaje para obtener los resultados. Suscribe al Blog Recibe los nuevos art√≠culos sobre Aprendizaje Autom√°tico, teor√≠a y el c√≥digo Python Email: Your email address here NOTA: algunos usuarios reportaron que el email de confirmaci√≥n a la suscripci√≥n entraron en la carpeta SPAM. Te sugiero que revises y recomiendo agregar el remitente a tus contactos. Gracias! Recursos Adicionales Te recomiendo sobre todo y para pasar al C√≥digo este curso completo en Kaggle: Machine Learning Explainability Algunos art√≠culos y videos sobre Interpretaci√≥n de Modelos (en ingl√©s) Libro muy bueno! Interpretable Machine Learning art√≠culo Hands-on Machine Learning Model Interpretation (art√≠culo) Interpretable Machine Learning Video (1:30hs) Open the black box: an intro to model interpretability Video (1:30hs) Interpretable ML for Computer Vision One Method to Rule Them All: Shap Values Derisking ML and Artifitial Intelligence The Mythos of Model Interpretability"
      },
      {
        "id": 7,
        "autor": "Jose Martinez Heras",
        "pagina": "IArtificial.net",
        "fecha": "10/10/2020",
        "titulo": "15 Librer√≠as de Python para Machine Learning",
        "link": "https://www.iartificial.net/librerias-de-python-para-machine-learning/",
        "contenido": "Estas son las 15 mejores librer√≠as de python para Machine Learning. Temas: Visualizaci√≥n, C√°lculo Num√©rico, An√°lisis de Datos, Aprendizaje Autom√°tico, Deep Learning, Inteligencia Artificial Explicable, Procesamiento del Lenguaje Natural y mucho m√°s. Todas las librer√≠as de python que vamos a ver son gratuitas. Librer√≠as de Python para Visualizaci√≥n Una de las fases del proceso de Machine Learning m√°s importantes es entender el problema que vamos a resolver. Una forma que tenemos de mejorar nuestra comprensi√≥n del problema es entender mejor los datos. La visualizaci√≥n de datos nos ayuda a entender mejor tanto los datos y como el problema. As√≠ mismo, la visualizaci√≥n de datos ser√° tambi√©n muy √∫til para comprender los resultados y analizar los errores. Aunque hay muchas librer√≠as en python para la visualizaci√≥n de datos, nos vamos a concentrar en: matplotlib, seaborn y bokeh por el momento. Matplotlib matplotlib es la librer√≠a gr√°fica de python est√°ndar y la m√°s conocida Matplotlib es la librer√≠a gr√°fica de python est√°ndar y la m√°s conocida. Puedes usar matplotlib para generar gr√°ficos de calidad necesaria para publicarlas tanto en papel como digitalmente. Con matplotlib puedes crear muchos tipos de gr√°ficos: series temporales, histogramas, espectros de potencia, diagramas de barras, diagramas de errores, etc. Si quieres ver de lo que matplotlib es capaz, mira sus gr√°ficos de ejemplo y su galer√≠a de gr√°ficos. Seaborn seaborn es una librer√≠a gr√°fica basada en matplotlib especializada en la visualizaci√≥n de datos estad√≠sticos Seaborn es una librer√≠a gr√°fica basada en matplotlib, especializada en la visualizaci√≥n de datos estad√≠sticos. Se caracteriza por ofrecer un interfaz de alto nivel para crear gr√°ficos estad√≠sticos visualmente atractivos e informativos. Seaborn considera la visualizaci√≥n como un aspecto fundamental a la hora de explorar y entender los datos. Se integra muy bien con la librer√≠a de manipulaci√≥n de datos pandas. Si quieres ver de lo que seaborn es capaz, mira su galer√≠a de ejemplos. Tambi√©n ofrecen un tutorial en ingl√©s. Bokeh Bokeh es una librer√≠a de gr√°fica para visualizar datos de forma interactiva en un navegador web Bokeh es una librer√≠a para visualizar datos de forma interactiva en un navegador web. Con bokeh podemos crear gr√°ficos vers√°tiles, elegantes e interactivos. Los desarrolladores de bokeh buscan un buen rendimiento con gran cantidad de datos, incluso con datos que vayan llegando en tiempo real. Si quieres ver de lo que bokeh es capaz, mira su galer√≠a de ejemplos. Tambi√©n puedes consultar su manual de usuario en ingl√©s. Librer√≠as de Python para C√°lculo Num√©rico y An√°lisis de Datos Otra de las fases del proceso de Machine Learning que m√°s tiempo consumen es la preparaci√≥n de datos y el c√°lculo de atributos relevantes o caracter√≠sticas (features). NumPy, SciPy y Pandas son las librer√≠as de python ideales para an√°lisis de datos y computaci√≥n num√©rica. Seguramente tambi√©n nos enfrentaremos a problemas que no requieren el uso de aprendizaje autom√°tico sino s√≥lo el an√°lisis de datos. Por supuesto, tambi√©n podemos usar estas librer√≠as en estos casos. NumPy Numpy es una librer√≠a num√©rica que proporciona estructuras de datos universal y funciones matem√°ticas de alto nivel NumPy proporciona una estructura de datos universal que posibilita el an√°lisis de datos y el intercambio de datos entre distintos algoritmos. Las estructuras de datos que implementa son vectores multidimensionales y matrices con capacidad para gran cantidad de datos. Adem√°s, esta librer√≠a proporciona funciones matem√°ticas de alto nivel que operan en estas estructuras de datos. Para aprender m√°s, sigue el tutorial de NumPy (en ingl√©s). SciPy SciPy proporciona rutinas num√©ricas eficientes f√°ciles de usar y opera en las mismas estructuras de datos proporcionadas por NumPy. Por ejemplo, con SciPy puedes realizar: integraci√≥n num√©rica, optimizaci√≥n, interpolaci√≥n, transformadas de Fourier, √°lgebra lineal, estad√≠stica, etc. Para aprender m√°s, sigue el tutorial de SciPy (en ingl√©s). Pandas pandas es una librer√≠a de python para la manipulaci√≥n de datos y el an√°lisis de datos Pandas es una de las librer√≠as de python m√°s √∫tiles para los cient√≠ficos de datos. Las estructuras de datos principales en pandas son Series para datos en una dimensi√≥n y DataFrame para datos en dos dimensiones. Estas son las estructuras de datos m√°s usadas en muchos campos tales como finanzas, estad√≠stica, ciencias sociales y muchas √°reas de ingenier√≠a. Pandas destaca por lo f√°cil y flexible que hace la manipulaci√≥n de datos y el an√°lisis de datos. Para aprender m√°s, puedes mirar la documentaci√≥n de pandas (en ingl√©s). Numba Numba Numba traduce funciones escritas en python to c√≥digo m√°quina optimizado a la hora de ejecutarse. Lo consigue usando el est√°ndar industrial LLVM como librer√≠a de compilaci√≥n. Los algoritmos num√©ricos compilados con Numba pueden alcanzar velocidades de ejecuci√≥n tan altas como las de C o FORTRAN. As√≠ que si te interesa optimizar la velocidad de tu c√≥digo, no tienes por qu√© compilar c√≥digo por separado, ni tan siquiera necesitas tener el compilador de C/C++ instalado. S√≥lo aplica uno de los decoradores de Numba a tu funci√≥n de python y Numba har√° el resto. Para saber m√°s, puedes consultar la documentaci√≥n de Numba (en ingl√©s) Librer√≠as de Python para Machine Learning Cuando vimos las fases del proceso de Machine Learning, vimos que construir el modelo de Machine Learning consum√≠a relativamente poco tiempo. Esto es as√≠ porque ya existen librer√≠as de aprendizaje autom√°tico. Hay varias, Scikit-Learn es la m√°s utilizada. scikit-learn scikit-learn es una librer√≠a de python para machine learning scikit-learn es una librer√≠a de python para Machine Learning y An√°lisis de Datos. Est√° basada en NumPy, SciPy y Matplotlib. La ventajas principales de scikit-learn son su facilidad de uso y la gran cantidad de t√©cnicas de aprendizaje autom√°tico que implementa. Con scikit-learn podemos realizar aprendizaje supervisado y no supervisado. Podemos usarlo para resolver problemas tanto de clasificaci√≥n y como de regresi√≥n. Es muy f√°cil de usar porque tiene una interfaz simple y muy consistente. El interfaz es muy f√°cil de aprender. Te das cuenta que el interfaz es consistente cuando puedes cambiar de t√©cnica de machine learning cambiando s√≥lo una l√≠nea de c√≥digo. Otro punto a favor de scikit-learn es que los valores de los hiper-par√°metros tienen unos valores por defecto adecuados para la mayor√≠a de los casos. Estas son algunas de las t√©cnicas de aprendizaje autom√°tico que podemos usar con scikit-learn: regresi√≥n lineal y polin√≥mica regresi√≥n log√≠stica m√°quinas de vectores de soporte √°rboles de decisi√≥n bosques aleatorios (random forests) agrupamiento (clustering) modelos basados en instancias clasificadores bayesianos reducci√≥n de dimensionalidad detecci√≥n de anomal√≠as etc. Para aprender m√°s, puedes mirar la documentaci√≥n de scikit-learn (en ingl√©s). Librer√≠as de Python para Deep Learning Aunque el Deep Learning se engloba dentro del Machine Learning, he puesto las librer√≠as de python para aprendizaje profundo al mismo nivel. La raz√≥n es que √∫ltimamente, el deep learning es el mayor responsable de la reciente popularidad del machine learning. TensorFlow TensorFlow es una librer√≠a de c√≥digo abierto para deep learning y aprendizaje autom√°tico TensorFlow es una librer√≠a de python, desarrollada por Google, para realizar c√°lculos num√©ricos mediante diagramas de flujo de datos. Esto puede chocar un poco al principio, porque en vez de codificar un programa, codificaremos un grafo. Los nodos de este grafo ser√°n operaciones matem√°ticas y las aristas representan los tensores (matrices de datos multidimensionales). Con esta computaci√≥n basada en grafos, TensorFlow puede usarse para deep learning y otras aplicaciones de c√°lculo cient√≠fico. Si te est√°s preguntando por qu√© necesitamos dise√±ar un grafo en vez de un programa, es por la flexibilidad de ejecuci√≥n que TensorFlow permite. Por ejemplo, el grafo que representa la red neuronal profunda y sus datos, se podr√° ejecutar en una o varias CPU o GPU en un PC, en un servidor o en un m√≥vil. Para aprender m√°s, puedes mirar el tutorial de TensorFlow (en ingl√©s). Keras Con Keras es muy f√°cil experimentar con deep learning y obtener resultados r√°pidamente Keras es un interfaz de alto nivel para trabajar con redes neuronales. El interfaz de Keras es mucho m√°s f√°cil de usar que el de TensorFlow. Esta facilidad de uso es su principal caracter√≠stica. Con Keras es muy f√°cil comprobar si nuestras ideas tendr√°n buenos resultados r√°pidamente. Keras utiliza otras librer√≠as de deep learning (TensorFlow, CNTK o Theano) de forma transparente para hacer el trabajo que le digamos. Para aprender m√°s, puedes mirar la documentaci√≥n de Keras (en ingl√©s). PyTorch PyTorch es una librer√≠a para deep learning en python PyTorch es una librer√≠a de python, desarrollada por Facebook, que permite el c√°lculo num√©rico eficiente en CPU y GPUs. Puedes pensar en PyTorch como una librer√≠a que te la las capacidades de NumPy en una GPU. En otras palabras, si tu tarjeta gr√°fica tiene un procesador gr√°fico (por ejemplo, una NVIDIA moderna), tu c√≥digo se puede ejecutar unas ¬°10 ‚Äì 20 veces m√°s r√°pido! El aprendizaje profundo (deep learning) usa c√°lculos matriciales y de derivadas masivos y paralelizables en GPUs. Por eso, PyTorch tambi√©n se especializa en deep learning. Para aprender m√°s, puedes mirar los tutoriales de PyTorch y su documentaci√≥n (ambos en ingl√©s). Librer√≠as de Python para IA explicable SHAP SHAP SHAP es una librer√≠a para realizar Inteligencia Artificial Explicable (XAI por sus siglas in ingl√©s eXplainable Artificial Intelligence). Utiliza c√°lculos del campo de la teor√≠a de juegos para averiguar qu√© variables tienen m√°s influencia en las predicciones de las t√©cnicas de machine learning. SHAP permite entender c√≥mo se toman las decisiones en modelos de caja negra (random forest o redes neuronales). Puedes obtener explicaciones tanto para predicciones individuales como de forma global. Su API es bastante f√°cil de usar. Librer√≠as de Python para Procesamiento de Lenguaje Natural Algunas de las librer√≠as que hemos visto se pueden usar tambi√©n para algunas de las fases del procesamiento del lenguaje natural. Por ejemplo, scikit-learn puede usarse para calcular frecuencias normalizadas de los t√©rminos que aparece en documentos. Las librer√≠as de deep learning y scikit-learn tambi√©n permiten construir modelos de machine learning con datos de texto, una vez estos se hayan convertido a un formato est√°ndar. En  este apartado, vamos a ver las librer√≠as que est√°n principalmente dedicadas al procesamiento del lenguaje natural. NLTK: Natural Language Toolkit NLTK es una de las librer√≠as m√°s antiguas en python para procesamiento de lenguaje natural. Sigue siendo muy √∫til para tareas de preprocesado de texto tales como la tokenizaci√≥n, lematizaci√≥n, exclusi√≥n de palabras irrelevantes, etc. NLTK tambi√©n se usa mucho como herramienta de estudio y ense√±anza de procesamiento del lenguaje. Para aprender m√°s, puedes leer el libro de NLTK (en ingl√©s). gensim gensim es una librer√≠a para modelar temas, calcular similaridad y otras tareas de procesamiento de lenguaje natural gensim es una librer√≠a para el procesamiento de lenguaje natural creada por Radim ≈òeh≈Ø≈ôek. El punto fuerte de Gensim es el modelado de temas. Es decir, puede identificar autom√°ticamente de que tratan un conjunto de documentos. Adem√°s, Gensim es √∫til para construir o importar representaciones de vectores distribuidas tales como word2vec. Tambi√©n podemos usar Gensim para analizar la similaridad entre documentos, lo que es muy √∫til cuando realizamos b√∫squedas. Para aprender m√°s, mira los tutoriales de Gensim (en ingl√©s). spaCy spaCy es una librer√≠a de python para procesamiento de lenguaje natural spaCy es la librer√≠a de procesamiento natural m√°s r√°pida que existe. Est√° dise√±ada para usarse en aplicaciones reales y extraer informaci√≥n relevante. spaCy tambi√©n es muy √∫til para preparar texto para otras tareas de aprendizaje autom√°tico. Por ejemplo, podemos preparar los datos para usarlos con TensorFlow, PyTorch, scikit-learn, Gensim, etc. Con spaCy tambi√©n vamos a poder construir modelos ling√º√≠sticos estad√≠sticos sofisticados para muchos de los problemas de procesamiento de lenguaje natural. Para saber m√°s, mira la documentaci√≥n de spaCy (en ingl√©s). Jupyter Notebook jupyter notebook es una aplicaci√≥n web para crear documentos que contiene c√≥digo, ecuaciones, visualizaciones y texto. Jupyter Notebook es una aplicaci√≥n web para crear documentos que contienen c√≥digo, ecuaciones, visualizaciones y texto. Puedes usar Jupyter notebooks para limpiar datos, transformarlos, realizar simulaciones num√©ricas, modelos estad√≠sticos, visualizaciones de datos, machine learning y mucho m√°s. A efectos pr√°cticos es como una consola interactiva de python en un navegador que permite la ejecuci√≥n de c√≥digo python, visualizaci√≥n de datos y gr√°ficos, y documentar lo que est√©s haciendo. Jupyter no es en realidad una librer√≠a de python. Sin embargo, ya que estamos viendo cu√°les son las herramientas que m√°s usa un cient√≠fico de datos, la lista no estar√≠a ni mucho menos completa sin Jupyter. Utilizo Jupyter constantemente para probar ideas y construir prototipos simples. No lo recomiendo cuando el c√≥digo sea m√°s complejo o cuando queramos crear librer√≠as con nuestro trabajo para reutilizarlo en otros proyectos. Anaconda Anaconda es una distribuci√≥n de python con las librer√≠as m√°s usadas por los cient√≠ficos de datos Anaconda es una distribuci√≥n de python para C√°lculo Num√©rico, An√°lisis de Datos y Machine Learning. Contiene las librer√≠as m√°s usadas por los cient√≠ficos de datos. Adem√°s hace muy f√°cil la instalaci√≥n de otras librer√≠as que puedas necesitar. Con Anaconda tambi√©n es posible crear varios entornos de trabajo si est√°s trabajando en varios proyectos . Esto puede ser √∫til, por ejemplo, si uno de los proyectos necesita python 3 y el otro python 2. O si est√°s trabajando en un proyecto que necesita unas librer√≠as espec√≠ficas o que tengan una versi√≥n espec√≠fica. A no ser que tengas que trabajar con aplicaciones antiguas, te recomiendo que utilices la distribuci√≥n de Anaconda con Python 3. Ve a la secci√≥n de descargas para conseguirla. Para m√°s informaci√≥n, puedes seguir la documentaci√≥n de Anaconda. Resumen Hemos visto las mejores librer√≠as de python para: visualizaci√≥n c√°lculo num√©rico an√°lisis de datos manipulaci√≥n de datos machine learning deep learning inteligencia artificial explicable procesamiento de lenguaje natural. Jupyter Notebook no es una librer√≠a, pero un entorno web que va a facilitarnos mucho la vida. Con Jupyter podemos probar nuestras ideas y ver los resultados de forma muy intuitiva, a la vez que lo documentamos. Finalmente, la forma m√°s f√°cil de instalar todas estas librer√≠as es instalar Anaconda. Anaconda va a instalar muchas de estas librer√≠as. El resto, podr√°s instalarlas manualmente cuando las necesites. Esta lista de librer√≠as no tiene por objetivo ser completa, si no s√≥lo indicar cu√°les librer√≠as de Machine Learning son m√°s √∫tiles ‚Ä¶ por lo menos para m√≠. Si tu librer√≠a favorita no est√° en la lista, te invito a que la pongas en los comentarios. Suscr√≠bete"
      },
      {
        "id": 8,
        "autor": "Ricardo Romo",
        "pagina": "ricardoromo",
        "fecha": "06/03/2020",
        "titulo": "Las 7 Librer√≠as mas importantes de Python",
        "link": "https://ricardoromo.co/2020/7-librerias-para-python-que-deberias-conocer/",
        "contenido": "Python es hoy en d√≠a uno de los lenguajes de programaci√≥n m√°s importantes en el mundo del desarrollo, ya sea por su facilidad para aprender, su comunidad o su gran cantidad de paquetes y librer√≠as. Precisamente de las librer√≠as es de lo que hablaremos en este art√≠culo, tanto si ya eres un desarrollador avanzado o si apenas estas empezando, te mostrar√© unas cuantas librer√≠as que podr√≠an serte √∫tiles a la hora de escribir c√≥digo en python. 1. Pprint Empezamos con una utilidad muy sencilla, la podemos usar para imprimir de una manera m√°s legible, algunas estructuras complejas en python, como las listas o los diccionarios. Esto puede ser √∫til al hacer debug a nuestros c√≥digos ya que representa de una manera m√°s ordenada estas estructuras de datos. Lo puedes ver f√°cilmente en este c√≥digo de ejemplo: import pprint diccionario = {'usuarios':{'user1':{'nombre':'Ricardo', 'edad':30, 'puesto':'director'}, 'user2':{'nombre':'Juan', 'edad':40, 'puesto':'ejecutivo'}, 'user3':{'nombre':'Carlos', 'edad':60, 'puesto':'director'}}} print('-'*10,'Impresion Normal','-'*10) print(diccionario) print() print('-'*10,'Impresion con Pprint','-'*10) pprint.pprint(diccionario) Pprint hace parte de la librer√≠a est√°ndar de python, por lo cual no es necesario descargar nada. 2. PyQt Con esta librer√≠a puedes darle una interfaz gr√°fica a tus proyectos, PyQt es un framework de aplicaciones Qt multiplataforma. Puedes crear f√°cilmente una interfaz gr√°fica para tu aplicaci√≥n, ya sea escribiendo c√≥digo o utilizando el editor gr√°fico Qt Designer. A mi parecer es m√°s √∫til usar el editor gr√°fico, de esta manera separas la l√≥gica del dise√±o y ahorras bastante tiempo en el desarrollo de la interfaz. PyQT-MrBootloader Interfaz ya creada PyQT-Designer Dise√±ador grafico Para instalar PyQt es necesario tener Anaconda o Miniconda instalado, en este art√≠culo, en la √∫ltima parte te ense√±o como instalar anaconda en linux, en windows solo es necesario descargar el instalador. Una vez configurada anaconda, corremos los siguientes comandos: conda update ‚Äìall conda install qt conda install pyqt Te recomiendo este articulo si te interesa saber mas sobre esta librer√≠a y como crear tus primeras interfaces. Instalar PyQt 3. Collections Esta es una serie de utilidades que hace parte de las librer√≠as est√°ndar del lenguaje, contiene estructuras y tipos de datos que mejoran el rendimiento y a√±ade otras funci√≥n a los tipos de datos nativos de python, como tuplas, diccionarios, arreglos y contadores. Collections tambien hace parte de la librer√≠a est√°ndar de python, por lo que no es necesario instalarla. Este es un ejemplo muy sencillo de un contador, retorna un diccionario con los elementos ordenados de mayor a menor seg√∫n su frecuencia en la lista y cuantas veces aparece. 4. Pandas Como la librer√≠a Collections, pandas es una librer√≠a ofrece estructuras de datos y operaciones orientadas al an√°lisis de datos, es una extensi√≥n a la librer√≠a numpy por lo cual su rendimiento aumenta en comparaci√≥n con los tipos de datos nativos de python. Entre las estructuras nuevas que a√±ade est√°n las Series y DataFrames que una herramienta fundamental para los cient√≠ficos en an√°lisis de datos. Instalar Pandas 5. BeautifulSoup Es una librer√≠a muy utilizada para el web scraping ya que te permite descargar el documento html de una p√°gina y te permite navegar entre las etiquetas. De esta manera puedes extraer informaci√≥n de manera  autom√°tica de los sitios web. Es una librer√≠a muy sencilla con una documentaci√≥n bastante amigable para los principiantes. Instalar BeautifulSoup 6. Scrapy Scrapy m√°s que una librer√≠a es un framework completo para web scraping, es mucho m√°s r√°pido, m√°s que beautifulsoup o cualquier otra librer√≠a para web scraping, consumiendo menos recursos. La contra es que no tiene una documentaci√≥n muy amigable con los principiantes. Decidirse por uno u otro depende del proyecto, recomiendo leer este art√≠culo para tener una perspectiva m√°s amplia sobre estas librer√≠as. Instalar Scrapy 7. PyInstaller Algunas veces hemos querido exportar nuestro c√≥digo a un solo archivo ejecutable, para poder compartirlo aprovechando la caracter√≠stica multiplataforma de python para ser ejecutado tanto en linux, mac o windows. En ese sentido, esta librer√≠a permite empaquetar nuestra c√≥digo y dependencias en una sola carpeta, para que podamos usarla en cualquier otra m√°quina sin preocuparnos del entorno. La utilizaci√≥n es muy sencilla solo tienes que ubicarte en el directorio de la aplicaci√≥n y usar el siguiente comando: pyinstaller <Nombre del script>.py Luego de esto tendr√°s una carpeta llamada¬ªdist¬ª donde estar√° el ejecutable que podr√°s llevar a todos lados."
      },
      {
        "id": 9,
        "autor": "Monty Shokeen",
        "pagina": "envaotuts+",
        "fecha": "09/01/2017",
        "titulo": "M√≥dulos Matem√°ticos en Python: Math y Cmath",
        "link": "https://code.tutsplus.com/es/tutorials/mathematical-modules-in-python-math-and-cmath--cms-26913",
        "contenido": "Cuando escribimos programas en nuestra vida diaria, usualmente nos encontramos con situaciones en donde necesitamos usar un poco de matem√°ticas para hacer una tarea. Como otros lenguajes de programaci√≥n, Python proporciona varios operadores para realizar c√°lculos b√°sicos como * para multiplicaci√≥n, % para m√≥dulos y // para divisi√≥n. Si est√°s escribiendo un programa para realizar tareas espec√≠ficas como estudiar movimiento peri√≥dico o simular circuitos el√©ctricos, necesitar√°s trabajar con funciones trigonom√©tricas as√≠ como n√∫meros complejos. Mientras que no puedes usar estas funciones directamente, puedes acceder a ellas incluyendo dos m√≥dulos matem√°ticos primero. Estos m√≥dulos son math y cmath. El primero te da acceso a funciones hiperb√≥licas, trigonom√©tricas y logar√≠tmicas para n√∫meros reales mientras que la √∫ltima te permite trabajar con n√∫meros complejos. En este tutorial, recorrer√© todas las funciones importantes ofrecidas por estos m√≥dulos. A menos que se mencione expl√≠citamente, todos los valores devueltos son flotantes. Funciones Aritm√©ticas Estas funciones realizan varias operaciones aritm√©ticas como calcular el valor superior, inferior o absoluto de un n√∫mero usando las funciones floor(x), ceil(x), y fabs(x) respectivamente. La funci√≥n ceil(x) devolver√° el entero m√°s peque√±o que sea mayor qu√© o igual a x. De manera similar, floor(x) devuelve el entero m√°s grande menor qu√© o igual a x. La funci√≥n fabs(x) devuelve el valor absoluto de x. Tambi√©n puedes realizar operaciones no triviales como calcular el factorial de un n√∫mero usando factorial(x). Un factorial es el producto de un entero y todos los enteros positivos menores que este. Es usado extensivamente cuando se trabaja con combinaciones y permutaciones. Tambi√©n puede ser usado para calcular el valor de las funciones seno y coseno. 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 import math def getsin(x): multiplier = 1 result = 0 for i in range(1,20,2): result += multiplier*pow(x,i)/math.factorial(i) multiplier *= -1 return result getsin(math.pi/2) # returns 1.0 getsin(math.pi/4) # returns 0.7071067811865475 Otra funci√≥n √∫til en el m√≥dulo math es gcd(x,y), la cu√°l te da el m√°ximo com√∫n divisor (MCD) de dos n√∫meros x y y. Cuando x y y no son cero, esta funci√≥n regresa el entero positivo m√°s grande que divida tanto a x como a y. Puedes usarlo indirectamente para calcular el m√≠nimo com√∫n m√∫ltiplo de dos n√∫meros usando la siguiente f√≥rmula: 1 gcd(a, b) x lcm(a, b) = a x b Aqu√≠ hay unas cuantas de las funciones aritm√©ticas que Python ofrece: 1 2 3 4 5 6 7 8 9 import math math.ceil(1.001)    # returns 2 math.floor(1.001)   # returns 1 math.factorial(10)  # returns 3628800 math.gcd(10,125)    # returns 5 math.trunc(1.001)   # returns 1 math.trunc(1.999)   # returns 1 Funciones Trigonom√©tricas Estas funciones relacionan los √°ngulos de un tri√°ngulo a sus lados. Tienen muchas aplicaciones, incluyendo el estudio de tri√°ngulos y el modelado de fen√≥menos peri√≥dicos como el sonido y ondas de luz. Ten en mente que el √°ngulo que proporcionas est√° en radianes. Puedes calcular sin(x), cos(x), y tan(x) directamente usando este m√≥dulo. Sin embargo, no hay f√≥rmula directa para calcular cosec(x), sec(x), y cot(x), pero su valor es igual al rec√≠proco del valor devuelto por sin(x), cos(x), y tan(x) respectivamente. En lugar de calcular el valor de funciones trigonom√©tricas como cierto √°ngulo, tambi√©n puedes hacer el c√°lculo inverso y calcular el √°ngulo al que tienen un valor dado usando asin(x), acos(x), and atan(x). ¬øEst√°s familiarizado con el teorema de Pit√°goras? Este establece que el cuadrado de la hipotenusa (el lado opuesto del √°ngulo derecho) es igual a la suma de los cuadrados de los otros dos lados. La hipotenusa es tambi√©n el lado m√°s grande de un tri√°ngulo rect√°ngulo. El m√≥dulo math proporciona la funci√≥n hypot(a,b) para calcular la longitud de la hipotenusa. 1 2 3 4 5 6 7 8 9 import math math.sin(math.pi/4)    # returns 0.7071067811865476 math.cos(math.pi)      # returns -1.0 math.tan(math.pi/6)    # returns 0.5773502691896257 math.hypot(12,5)       # returns 13.0 math.atan(0.5773502691896257) # returns 0.5235987755982988 math.asin(0.7071067811865476) # returns 0.7853981633974484 Funciones Hiperb√≥licas Las funciones hiperb√≥licas son an√°logas a las funciones trigonom√©tricas que est√°n basadas en una hip√©rbole en lugar de un c√≠rculo. En trigonometr√≠a, los puntos (cos b, sin b) representan los puntos de un c√≠rculo unitario. En caso de funciones hiperb√≥licas, los puntos (cosh b, sinh b) representan los puntos que forman la mitad derecha de una hip√©rbola equil√°tera. Justo como las funciones trigonom√©tricas, puedes calcular el valor de sinh(x), cosh(x), y tanh(x) directamente. El resto de los valores pueden ser calculados usando varias relaciones entra estos tres valores. Tambi√©n hay otras funciones como asinh(x), acosh(x), and atanh(x), lac cuales pueden ser usadas para culcular la inversa de los valores hiperb√≥licos correspondientes. 1 2 3 4 5 6 7 8 9 import math math.sinh(math.pi)    # returns 11.548739357257746 math.cosh(math.pi)    # returns 11.591953275521519 math.cosh(math.pi)    # returns 0.99627207622075 math.asinh(11.548739357257746)   # returns 3.141592653589793 math.acosh(11.591953275521519)   # returns 3.141592653589793 math.atanh(0.99627207622075)     # returns 3.141592653589798 Ya que math.pi es igual a alrededor de 3.141592653589793, cuando usamos asinh() en el valor devuelto por sinh(math.pi), obtuvimos nuestro œÄ de vuelta. Funciones Exponenciales y Logaritmicas Probablemente estar√°s lidiando con exponentes y logaritmos m√°s seguido que con funciones hiperb√≥licas y trigonom√©tricas. Afortunadamente, el m√≥dulo math proporciona muchas funciones para ayudarnos a calcular logaritmos. Puedes usar log(x,[base]) para calcular el log de un n√∫mero dado x a la base dada. Si dejas fuera el argumento opcional de base, el log de x es calculado a la base e. Aqu√≠, e es una constante matem√°tica cuyo valor es 2.71828182.... y puede ser accedida usando math.e. Por cierto, Python tambi√©n te permite acceder a otra constante œÄ usando math.pi. Si quieres calcular los valores logar√≠tmicos base 2 o base 10, usar log2(x) y log10(x) revolver√° resultados m√°s precisos que log(x, 2) y log(x, 10). Ten en mente que no hay funci√≥n log3(x), as√≠ que tendr√°s que seguir usando log(x, 3) para calcular valores logar√≠tmicos log(x,3). Lo mismo aplica para todas las dem√°s bases. Si el valor cuyo logaritmo est√°s calculando es bastante cercano a 1, puedes usar log1p(x). El 1p en log1p significa 1 m√°s. As√≠ pues, log1p(x) calcula log(1+x) en donde x es cercano a cero. Sin embargo, los resultados son m√°s precisos con loglp(x). Tambi√©n puedes calcular el valor de un n√∫mero x elevado a la potencia y usando pow(x, y). Antes de computar las potencias, esta funci√≥n convierte ambos argumentos a tipo float. Si quieres que el resultado final se compute en potencias enteras exactas, deber√≠as usar la funci√≥n integrada pow() o el operador **. Tambi√©n puedes computar la ra√≠z cuadrada de cualquier n√∫mero dado x usando sqrt(x), pero la misma cosa tambi√©n puede ser lograda usando pow(x, 0.5). 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 import math math.exp(5)                      # returns 148.4131591025766 math.e**5                        # returns 148.4131591025765 math.log(148.41315910257657)     # returns 5.0 math.log(148.41315910257657, 2)  # returns 7.213475204444817 math.log(148.41315910257657, 10) # returns 2.171472409516258 math.log(1.0000025)              # returns 2.4999968749105643e-06 math.log1p(0.0000025)            # returns 2.4999968750052084e-06 math.pow(12.5, 2.8)              # returns 1178.5500657314767 math.pow(144, 0.5)               # returns 12.0 math.sqrt(144)                   # returns 12.0 Advertisement N√∫meros Complejos Los n√∫meros complejos son almacenados inicialmente usando coordenadas rectangulares o Cartesianas. Un n√∫mero complejo z ser√° representado en coordenadas Cartesianas como z = x + iy, en donde x representa la parte real y y representa la parte imaginaria. Otra manera de representarlos es usando coordenadas polares. En este caso, el n√∫mero complejo ser√≠a definido por una combinaci√≥n de los m√≥dulos r y √°ngulo de fase phi. El m√≥dulo r es la distancia entre el n√∫mero complejo z y el origen. El √°ngulo phi es el √°ngulo contrario medido en radianes desde el eje x positivo al segmento de l√≠nea uniendo a z y el origen. Mientras lidiamos con n√∫meros complejos, el m√≥dulo cmath puede ser de gran ayuda. El m√≥dulo de un n√∫mero complejo puede ser calculado usando la funci√≥n integrada abs() y su fase puede ser calculada usando la funci√≥n phase(z) disponible en el m√≥dulo cmath. Puedes convertir un n√∫mero complejo en forma rectangular a forma polar usando polar(z), la cu√°l devolver√° un par (r, phi), en donde r es abs(z) y phi es phase(z). De manera similar, puedes convertir un n√∫mero complejo en forma polar a rectangular usando rect(r, phi). El n√∫mero complejo devuelto por esta funci√≥n es r * (math.cos(phi) + math.sin(phi)*1j). 01 02 03 04 05 06 07 08 09 10 import cmath cmath.polar(complex(1.0, 1.0)) # returns (1.4142135623730951, 0.7853981633974483) cmath.phase(complex(1.0, 1.0)) # returns 0.7853981633974483 abs(complex(1.0, 1.0)) # returns 1.4142135623730951 El m√≥dulo cmath tambi√©n nos permite usar funciones matem√°ticas regulares con n√∫meros complejos. Por ejemplo, puedes calcular la ra√≠z cuadrada de un n√∫mero complejo usando sqrt(z) o su coseno usando cos(z). 1 2 3 4 5 6 7 import cmath cmath.sqrt(complex(25.0, 25.0)) # returns (5.49342056733905+2.2754493028111367j) cmath.cos(complex(25.0, 25.0)) # returns (35685729345.58163+4764987221.458499j) Los n√∫meros complejos tienen muchas aplicaciones como modelado de circuitos el√©ctricos, din√°mica de fluidos, y an√°lisis de se√±ales. Si necesitas trabajar en cualquiera de estas cosas, el m√≥dulo cmath no te decepcionar√°. Ideas Finales Todas estas funciones que discutimos arriba tienen sus aplicaciones espec√≠ficas. Por ejemplo, puedes usar la funci√≥n factorial (x) para resolver problemas de permutaci√≥n. Puedes usar las funciones trigonom√©tricas para resolver un vector en coordenadas Cartesianas. Tambi√©n puedes usar funciones trigonom√©tricas para simular funciones peri√≥dicas como sonido y ondas de luz. De manera similar, la curva de una cuerda colgando entre dos postes puede ser determinada usando una funci√≥n hiperb√≥lica. Ya que todas estas funciones est√°n disponibles directamente en el m√≥dulo math, hace m√°s f√°cil crear peque√±os programas que realicen estas tareas. Espero que hayas disfrutado este tutorial. Si tienes alguna pregunta, h√°zmelo saber en los comentarios."
      },
      {
        "id": 10,
        "autor": "Jos√© Luis Chac√≥n",
        "pagina": "profile",
        "fecha": "22/03/2021",
        "titulo": "Introducci√≥n a Pandas, la librer√≠a de Python para trabajar con datos",
        "link": "https://profile.es/blog/pandas-python/",
        "contenido": "En este post te contamos qu√© es Pandas, por qu√© utilizarla y cu√°les son las principales caracter√≠sticas de esta librer√≠a de Python. ¬øQu√© es Pandas? Pandas es una muy popular librer√≠a de c√≥digo abierto dentro de los desarrolladores de Python, y sobre todo dentro del √°mbito de Data Science y Machine Learning, ya que ofrece unas estructuras muy poderosas y flexibles que facilitan la manipulaci√≥n y tratamiento de datos. Pandas surgi√≥ como necesidad de aunar en una √∫nica librer√≠a todo lo necesario para que un analista de datos pudiese tener en una misma herramienta todas las funcionalidades que necesitaba en su d√≠a a d√≠a, como son: cargar datos, modelar, analizar, manipular y prepararlos. Pandas, la librer√≠a de Python para analizar datos Estructuras de datos en Pandas Las dos estructuras de datos principales dentro del paquete Pandas son: Series: array unidimensional etiquetado capaz de almacenar cualquier tipo de dato. DataFrame: estructura bidimensional con columnas que pueden ser tambi√©n de cualquier tipo. Estas columnas son a su vez Series. Estructuras de datos en Pandas Dado que vivimos en un mundo en el que los datos son de muy distintas categor√≠as, Pandas se realiz√≥ con el objetivo de poder tratar con el mayor n√∫mero posible de casu√≠sticas entre tipos de datos. Es muy simple cargar datos desde diferentes tipos de archivos (csv, json, html, etc.), as√≠ como guardarlos. A continuaci√≥n, se mostrar√° un ejemplo de c√≥mo cargar datos desde un .csv con una sola l√≠nea: Cargar datos desde un csv con Pandas Analizar datos con Pandas A d√≠a de hoy, aunque no seamos todav√≠a del todo conscientes, vivimos en un mundo en el que podemos sacar informaci√≥n muy valiosa de los datos, aunque a priori no la conozcamos. El principal problema que nos encontramos es que, a simple vista, no somos capaces de obtener ese conocimiento, por eso necesitamos de herramientas como Pandas que nos ayuden en este proceso. A continuaci√≥n se enumeran funciones muy valiosas de Pandas que pueden ayudarnos para hacer un an√°lisis en profundidad de los datos con los que se est√© trabajando: head(n): Esta funci√≥n devuelve las primeras n filas de nuestro DataFrame. An√°lisis de datos en Pandas head(n) tail(n): Devuelve las n √∫ltimas filas de nuestro DataFrame. An√°lisis de datos en Pandas tail(n) describe(): Esta funci√≥n da estad√≠sticas descriptivas incluyendo aquellas que resumen la tendencia central, dispersi√≥n y la forma de la distribuci√≥n de los datos. An√°lisis de datos en Pandas describe() Filtrado y manipulaci√≥n de datos con Pandas Hasta ahora el art√≠culo se ha centrado en algunos res√∫menes e informaci√≥n b√°sica del conjunto de datos que estamos usando como ejemplo, sin tener en cuenta la estructura de datos que tenemos. Pandas nos permite obtener columnas o filas de nuestros datos de forma muy f√°cil e intuitiva. Adem√°s, podemos hacer una exploraci√≥n bas√°ndonos en condiciones tal como veremos a continuaci√≥n. Seleccionar columnas o filas espec√≠ficas ¬øQu√© pasa si s√≥lo estamos interesados en una columna de nuestro conjunto de datos? Con Pandas podemos usar los corchetes ‚Äú[]‚Äù para extraer cualquier columna. Seleccionar columnas en Pandas En el caso de querer extraer solamente una fila tenemos dos opciones: .loc: para extraer por nombre de fila .iloc: para extraer por el √≠ndice num√©rico Para extraer por ejemplo la fila cuyo √≠ndice es 0, se har√≠a con la siguiente instrucci√≥n: Extraer una fila en Pandas Selecciones condicionales Con Pandas tambi√©n podemos hacer selecciones condicionales como, por ejemplo, cu√°les son las filas que tienen una edad mayor a 45. Para este tipo de cuestiones es necesario tomar una columna de nuestro DataFrame y aplicarle una condici√≥n booleana. Selecciones condicionales en Pandas Tambi√©n se pueden realizar tratamientos m√°s sofisticados combinando varios operadores booleanos. Por ejemplo, para saber qu√© pasajeros tienen una edad mayor de 45 a√±os y son mujeres deber√≠amos utilizar la siguiente l√≠nea de c√≥digo: Selecciones condicionales complejas en Pandas Gr√°ficos en Pandas Otra de las ventajas de Pandas es que viene integrado con Matplotlib, una librer√≠a muy conocida para hacer gr√°ficas. Por lo que se puede realizar de forma muy c√≥moda y sencilla cualquier gr√°fico directamente a partir de un DataFrame o Series. La funci√≥n que se usa para realizar gr√°ficos es plot(). Esta funci√≥n cuenta con un par√°metro de entrada, ‚Äúkind‚Äù, que sirve para especificar el tipo de gr√°fico que se desea obtener a partir de un DataFrame o Series. A continuaci√≥n se enumeran las opciones disponibles para este par√°metro: area: gr√°ficos de √°reas bar: diagramas de barras verticales barh: diagramas de barras horizontales box: diagrama de cajas y bigotes hexbin: para diagramas hexagonales hist: histograma kde: gr√°ficos de estimaci√≥n kernel de la densidad density: alias para ‚Äúkde‚Äù line: gr√°ficos de l√≠neas pie: diagrama de tartas scatter: diagrama de dispersi√≥n Por ejemplo, para visualizar un histograma con la distribuci√≥n de la variable ‚ÄúAge‚Äù, deber√≠amos usar la funci√≥n plot y el par√°metro ‚Äúkind‚Äù con valor ‚Äúhist‚Äù: Gr√°fico histograma en Pandas Adem√°s del tipo de gr√°fico que queremos obtener, se pueden modificar muchos detalles de estilo, como los colores, los nombres de los ejes, el tama√±o, etc. Conclusiones La gran cantidad de datos que estamos generando continuamente hace necesario tener herramientas potentes que permitan sacar el m√°ximo provecho de ellos. Pandas es una librer√≠a de c√≥digo abierto que surgi√≥ para hacer m√°s f√°cil todo el ciclo de vida de cualquier dato, desde que este es generado hasta que es aprovechado. Permite, de forma f√°cil e intuitiva realizar operaciones capaces de gestionar y manipular cualquier tipo de informaci√≥n sin importar el formato, y sobre todo de una forma r√°pida y eficaz. Esto hace que Pandas se haya convertido en el mejor amigo de cualquier curioso por los datos. ¬øHas utilizado alguna vez Pandas? ¬øUsas otra librer√≠a para trabajar con datos? ¬°Comparte tu experiencia! Si no quieres perderte m√°s contenidos como √©ste, ¬°suscr√≠bete a nuestro canal de YouTube! Art√≠culos relacionados"
      },
      {
        "id": 11,
        "autor": "Manuel Zaforas",
        "fecha": "00/00/2017",
        "titulo": "C√≥mo implementar microservicios con Python en minutos",
        "link": "https://www.paradigmadigital.com/dev/implementar-microservicios-python-minutos/",
        "contenido": "Las arquitecturas software orientadas a microservicios se est√°n convirtiendo en un standard para la construcci√≥n de aplicaciones modernas desplegadas continuamente en plataformas Cloud. Martin Fowler, uno de los firmantes del Manifiesto √Ågil y una de las personas m√°s influyentes en el mundo del software, profundiz√≥ en el concepto de arquitecturas orientadas a microservicios en este art√≠culo de obligada lectura. Sin duda este nuevo estilo de arquitectura se est√° imponiendo en entornos donde las necesidades de escalabilidad son muy fuertes y el dise√±o en componentes independientes es una gran ventaja a la hora de abordar problemas complejos. En Paradigma hemos escrito varios art√≠culos profundizando en diferentes aspectos a tener en cuenta a la hora de enfrentarse a arquitecturas orientadas a microservicios como la orquestaci√≥n, la monitorizaci√≥n o el despliegue. En este art√≠culo, sin embargo, queremos profundizar en una de las grandes ventajas de los microservicios: el poliglotismo. ¬øPor qu√© desarrollar microservicios en Python? Uno de los principios de este estilo de arquitectura es que los servicios deben de tender a ser lo m√°s cohesionados posibles, minimizando al m√°ximo el acoplamiento entre ellos. La comunicaci√≥n entre los servicios se ha de implementar a trav√©s de mecanismos ligeros, preferiblemente APIs basados en HTTP, como por ejemplo APIs RESTful/JSON. Estos sistemas de comunicaci√≥n agn√≥sticos nos abren la puerta a que podamos desarrollar cada microservicio con el lenguaje y las herramientas que m√°s nos convenga en cada caso. Por ejemplo, si en un microservicio en concreto el rendimiento es un aspecto cr√≠tico, podemos escoger lenguajes de bajo nivel que nos permitan afinar m√°s este aspecto como C, C++ o Go. Sin embargo en otros casos nos interesar√° escoger lenguajes de alto o nivel o que implementen ciertas caracter√≠sticas particulares, como Python, Ruby, Groovy o Scala, que nos permitan avanzar m√°s r√°pido o se acomoden mejor al servicio que deben implementar. Llegados a este punto debemos plantearnos qu√© opciones o plataformas pueden ser interesantes a la hora de implementar estos servicios que exponen APIs REST m√°s all√° de los lenguajes que nos ofrece la JVM y de los frameworks habituales en el ecosistema Java, en ocasiones demasiado pesados. Sin duda una de las mejores opciones a tener en cuenta es usar un lenguaje de alto nivel como Python, del que podemos aprovechar muchas de sus ventajas ya que es un lenguaje interpretado y de tipado din√°mico. Python es ampliamente utilizado, por lo que tiene una gran base de programadores. Combina m√∫ltiples paradigmas de programaci√≥n como el orientado a objetos y el funcional. Adem√°s, su sintaxis est√° orientada escribir menos l√≠neas de c√≥digo pero m√°s claras que otros lenguajes, lo que facilita enormemente su mantenimiento. Por otro lado, existen excelentes frameworks y bibliotecas muy asentados y orientados al desarrollo de APIs REST y sistemas de comunicaci√≥n basados en HTTP, lo que es perfecto para la construcci√≥n de microservicios. Algunos de los frameworks m√°s interesantes para construir APIs REST son: Django + REST Framework Django + Tastypie Flask + Flask-RESTFul Falcon Ejemplo Vamos a ver un ejemplo de c√≥mo construir en pocas l√≠neas un peque√±o microservicio que exponga un API REST para manejar ‚Äúcustomers‚Äù con Django y REST Framework. En este caso vamos a tener que definir los siguientes elementos, cada uno en un fichero Python: Modelo: Aqu√≠ definiremos las propiedades y m√©todos de nuestro modelo de clientes. Vista: En este apartado implementaremos la funcionalidad que queremos ofrecer asociada en este microservicio en torno al recurso ‚ÄúCustomer‚Äù. Router: En este punto asociaremos la l√≥gica definida en el punto anterior en rutas y m√©todos HTTP concretos. Serializador: Es necesario definir el formato y estructura de los datos que recibe y devuelve nuestro API. Test: Aqu√≠ podemos definir un conjunto de tests que validen nuestra API. models.py En este fichero vamos a definir c√≥mo ser√° nuestro modelo ‚ÄúCustomer‚Äù, esto lo hacemos a trav√©s de la definici√≥n de una clase que herede de ‚ÄúModel‚Äù. Esta clase incluir√° una serie de propiedades y sus tipos de datos que ser√°n los atributos que tendr√° un cliente. El ORM de Django convertir√° esta informaci√≥n en una tabla en la base de datos que elijamos. from django.db.models import Model, UUIDField, CharField, EmailField, DateTimeField class Customer(Model): id = UUIDField(primary_key=True) name = CharField(max_length=45) surname = CharField(max_length=45) phone = CharField(max_length=45) email = EmailField() views.py from rest_framework import viewsets from customer.models import Customer from customer.serializers import CustomerSerializer class CustomerViewSet(viewsets.ModelViewSet): model = Customer queryset = Customer.objects.all() serializer_class = CustomerSerializer En la vista le indicamos a Django que queremos basarnos en el modelo ‚ÄúCustomer‚Äù, que hemos definido para construir un API asociada a este modelo. Al heredar de ‚ÄúModelViewSet‚Äù el API que expondremos ser√° CRUD y ofrecer√° los siguientes m√©todos: POST /api/customers/ GET /api/customers/ PUT /api/customers/{pk}/ DELETE /api/customers/{pk}/ GET /api/customers/{pk}/ PATCH /api/customers/{pk}/ Adem√°s le indicamos que para la representaci√≥n del recurso ‚ÄúCustomer‚Äù debe de usar la clase ‚ÄúCustomerSerializer‚Äù. urls.py from rest_framework.routers import DefaultRouter from customer.views import CustomerViewSet router = DefaultRouter() router.register('customers', CustomerViewSet, 'Customer') urlpatterns = router.urls En el fichero de URLs se define el punto desde el cual colgar√° el API de customer, en este caso ser√° en /customers/ y desde aqu√≠ colgar√°n el resto de URLs asociadas a este recurso. serializers.py from rest_framework import serializers from customer.models import Customer class CustomerSerializer(serializers.ModelSerializer): class Meta: model = Customer Los serializadores nos permiten implementar cambios en la representaci√≥n y serializaci√≥n de los recursos, limitar la informaci√≥n que devolver√° el API y con qu√© estructura. En este caso dejamos que el framework infiera del modelo los campos y los renderice todos de acuerdo a su tipo de datos. Esta ser√≠a la opci√≥n predeterminada. tests.py from django.core.urlresolvers import reverse from rest_framework import status from rest_framework.test import APITestCase from customer.models import Customer class AccountTests(APITestCase): def test_create_customer(self): url = reverse('customer-list') data = { 'id': '550e8400-e29b-41d4-a716-446655440000', 'name': 'John', 'surname': 'Smith', 'email': 'jsmith@test.com', 'phone': '609148275' } response = self.client.post(url, data, format='json') self.assertEqual(response.status_code, status.HTTP_201_CREATED) self.assertEqual(Customer.objects.count(), 1) self.assertEqual(Customer.objects.get().name, 'John') Por √∫ltimo definiremos un juego de tests que pruebe nuestra API. En este caso, a modo de ejemplo, definiremos un √∫nico test que env√≠e una petici√≥n POST con un body de ejemplo y haga las siguientes comprobaciones: Que el c√≥digo HTTP devuelto sea 201. Que se haya insertado un objeto customer en la base de datos. Que el nombre de este objeto sea ‚ÄúJohn‚Äù que era el nombre que hab√≠amos incluido en el body de la petici√≥n POST. Documentaci√≥n del API Podemos navegar por el API que acabamos de generar usando la herramienta que nos viene incluida con Django Rest Framework. django-rest-framework Tambi√©n podemos activar f√°cilmente otros sistemas de documentaci√≥n de APIs como Swagger que se integran perfectamente con Django a trav√©s del paquete django-rest-swagger. swagger Conclusi√≥n El estilo de arquitectura orientado a microservicios nos permite integrar diferentes lenguajes y frameworks, de esta forma podemos aprovechar lo mejor de cada uno. Python es un lenguaje moderno y muy potente para el desarrollo r√°pido de microservicios. Adem√°s, combinado con los frameworks y herramientas del ecosistema Python, lo convierten, sin duda, en una alternativa muy interesante."
      },
      {
        "id": 12,
        "autor": "Dilan Coss        ",
        "fecha": "01/06/2018",
        "titulo": "Crear un API y una aplicaci√≥n web con Flask",
        "link": "https://blog.nearsoftjobs.com/crear-un-api-y-una-aplicaci%C3%B3n-web-con-flask-6a76b8bf5383",
        "contenido": "e sido un intern en Nearsoft por casi 3 meses, y se nos dio la tarea de contribuir en repositorios open source. Uno de los repositorios que escog√≠ fue Flask, por lo que tuve investigar c√≥mo se utiliza y las cosas que puedes llegar a lograr utiliz√°ndolo. ¬øQu√© es flask? Flask es un micro framework utilizado para crear aplicaciones web. Se considera micro porque es un proyecto minimalista y no depende de muchas cosas para ser utilizado, lo que significa que como desarrollador debes encargarte de la base de datos que utilizar√°s, as√≠ como cualquier otra herramienta. En este blog s√≥lo se cubrir√°n caracter√≠sticas principales de Flask, para ver lo sencillo que es hacer una API y una aplicaci√≥n web, por lo que no se necesita instalar muchas cosas. Existe una librer√≠a de Flask llamada ‚Äúflask_restful‚Äù enfocada en realizar APIs, que se utilizar√° para la realizaci√≥n de nuestra API. Se realizar√° un ejercicio de hola mundo, en caso de que quieras continuar y aprender con un mejor ejemplo, seguir√° un ejercicio que obtenga informaci√≥n de Twitter. Creaci√≥n de la API Lo primero que debes hacer es instalar lo necesario de Flask para hacer este ejercicio; son los siguientes comandos en tu consola: pip install -U Flask pip install flask_restful Ahora crea un archivo que se llame ‚Äúapi.py‚Äù. En este archivo debes importar lo que acabas de instalar, de la siguiente forma: from flask import Flask from flask_restful import Resource, Api Se puede realizar una API con la librer√≠a normal de Flask pero a la larga resulta m√°s f√°cil utilizar la librer√≠a que ya est√° especializada para realizarlas. Por lo que agregaremos las siguientes l√≠nea de c√≥digo donde crear√°s una instancia de Flask y le damos la instancia de Flask a API: app = Flask(__name__) api = Api(app) Si quisi√©ramos hacer un hola mundo se hace de la siguiente forma: class Hello(Resource): def get(self, name): return {Hello:name} Estamos diciendo que la clase Hello hereda de Resource, que es lo utiliza Flask para saber cu√°l ruta se asocia con cada clase, de igual forma el m√©todo dentro de la clase indica qu√© tipo de operaci√≥n se realizar√°. En nuestro caso es solo un get, y aplica de igual forma si quisi√©ramos utilizar otra operaci√≥n, el m√©todo se llamar√≠a put, post, etc. Agregamos el recurso a la API y la asociamos con la ruta, con la siguiente l√≠nea de c√≥digo: api.add_resource(Hello, ‚Äò/hello/<name>‚Äô) Para poder correr la aplicaci√≥n de la forma python api.py deber√°s agregar lo siguiente: if __name__ == ‚Äò__main__‚Äô: app.run(debug=True) Para poder hacer cambios mientras est√© corriendo la aplicaci√≥n de manera opcional podemos darle el par√°metro debug como verdadero. Ahora si corremos nuestro proyecto desde la consola con: python api.py Podemos acceder en nuestro navegador la siguiente ruta: http://localhost:5000/hello/world Lo que nos entregar√° lo siguiente: Listo, ya tenemos nuestra API funcionando, es un ejemplo muy sencillo, pero se puede extender a cosas m√°s complejas. Creaci√≥n de la aplicaci√≥n web Ahora realizaremos una aplicaci√≥n web con Flask, la cual va a consumir la API que acabamos de hacer. En otro proyecto crea un archivo llamado webapp.py en el cual importaremos Flask y haremos una instancia de la misma, tambi√©n importaremos requests para consumir nuestra API. pip install requests Importamos lo necesario: from flask import Flask import requests Con esto ya podemos explicar c√≥mo funcionan las rutas. Las rutas en Flask generalmente se utilizan con decoradores, en donde se pasan los par√°metros del m√©todo de REST (GET, POST, PUT, DELETE) y la ruta que aparece en el navegador. Un decorador toma la funci√≥n que est√© debajo y a√±adir√° m√°s funcionalidades a la misma. Si quisi√©ramos hacer un m√©todo que nos regrese el resultado de nuestra API, ponemos el siguiente c√≥digo: @app.route('/hello/<name>') def hello(name): info = requests.get('http://localhost:5000/hello/'+name) return info.text El decorador @app.route tiene la ruta que se acceder√° en el navegador, as√≠ como los par√°metros adicionales que utilizaremos. Aqu√≠ no especificamos los m√©todos, ya que s√≥lo lo utilizaremos para un get, despu√©s se crear√° el m√©todo que recibe los par√°metros. Utilizamos la librer√≠a requests para consumir la funci√≥n de la API. De igual forma agregamos: if __name__ == '__main__': app.run(debug=True, host='0.0.0.0', port=80) Pero esta vez, como vamos a estar corriendo 2 aplicaciones con Flask, a √©sta le asignaremos otro puerto. S√≥lo queda ejecutar el archivo con: python webapp.py En caso de que te salga permiso denegado, corre el comando con Sudo. Accediendo a nuestro navegador con el puerto que hayas escogido (en mi caso el puerto 80) te deber√° aparecer lo siguiente: Hemos finalizado con la creaci√≥n de nuestra API y de nuestra aplicaci√≥n web. Todo bien, pero es un poco aburrido. As√≠ que le daremos un poco m√°s de funcionalidad para que sea m√°s divertido y que explique un poco mejor la l√≥gica detr√°s de separar servicios. Ejercicio de Twitter Lo siguiente consiste en que nuestra aplicaci√≥n busque un usuario de Twitter, y ese usuario lo mandar√° a la API, la cual har√° lo necesario para entregarnos los tweets e informaci√≥n general del usuario que buscamos. Lo √∫nico que tendr√°s que hacer es generar unas llaves para autenticarte con Twitter, de lo contrario no podr√°s hacer lo siguiente. Tendr√°s que entrar a la siguiente p√°gina https://apps.twitter.com/ para registrar una aplicaci√≥n y te dar√° tus llaves y tokens de acceso, son 4 en total. API Agregaremos 2 archivos a nuestro proyecto de la API. twitter_tools.py models.py twitter_tools.py traer√° la informaci√≥n del usuario y models.py contiene el modelo Person para guardar la informaci√≥n de twitter. La estructura queda de la siguiente forma: twitter_tools.py models.py En el archivo principal api.py agregamos el recurso que utilice la funci√≥n de obtener la informaci√≥n de la persona. Termina de la siguiente forma: Antes de correr la aplicaci√≥n aseg√∫rate de instalar la librer√≠a Tweepy, la cual utilizamos en nuestro proyecto. pip install tweepy Ahora ejecuta python api.py en la consola y ve a tu navegador a: http://localhost:5000/search/spotgabbiani spotgabbiani es el ejemplo de usuario de twitter, pero puedes poner cualquier otro. Deber√° aparecer lo siguiente: Perfecto, ya tenemos la API funcionando, ahora sigue la aplicaci√≥n web. Aplicaci√≥n web La gran mayor√≠a de lo que se a√±ade en esta secci√≥n es para que se vea bien la aplicaci√≥n. Y tiene la siguiente estructura. forms.py En forms.py se a√±adi√≥ una clase que hereda de FlaskForm, de esta forma se puede realizar la estructura de las formas, as√≠ como sus validaciones de una forma sencilla. main.css layout.html search.html show.html Ahora en lo que respecta a Flask vamos a a√±adir 2 m√©todos, uno que nos entrega la forma con la que buscaremos el usuario y otro para consumir nuestro servicio. El archivo webapp.py queda de la siguiente forma: Es importante mencionar que para las formas de Flask, se tuvo que a√±adir un secret key, en un proyecto real debe ponerse como una variable de ambiente para que nadie vea tu key, pero para fines pr√°cticos puedes poner lo que sea. ¬°Por fin! Acabamos con el c√≥digo, solo falta correrlas de la misma forma que antes, recuerda que es en diferente consola y para la aplicaci√≥n web probablemente tendr√°s que utilizar Sudo. python api.py sudo python webapp.py Accedemos a nuestro navegador a localhost y deber√° aparecer esto: Buscamos el usuario de Twitter que queramos y la primera vez se tardar√° bastante en cargar, dependiendo de la cantidad de tweets de la persona. Despu√©s ya no se tardar√° tanto porque se guarda en memoria de nuestra API. Como no utilizamos una base de datos, ese cache de informaci√≥n morir√° cada vez que reiniciemos la API. Si al final tuviste alg√∫n error puedes revisar el c√≥digo en los siguientes repositorios de Github: https://github.com/eso31/WebApp-flask https://github.com/eso31/API-flask Conclusi√≥n Aparte de la funcionalidad de Flask en un nivel muy b√°sico y conseguir crear una API y aplicaci√≥n web de manera r√°pida y simple, se pretende mostrar por qu√© es importante separar las aplicaciones en micro servicios; en este ejemplo, separamos la aplicaci√≥n que ve el usuario y la funcionalidad que toca el tema de Twitter. En lugar de tener todo en un proyecto gigante, separamos por servicios para facilitar la integraci√≥n continua de grandes proyectos. S√© que fue un blog muy largo, pero agradezco que lo hayas le√≠do y espero que te haya servido y hayas aprendido. Si deseas contactarme puedes hacerlo al correo: dcoss@nearsoft.com Dilan Coss, Intern @Nearsoft :-)"
      },
      {
        "id": 13,
        "autor": "Iv√°n Arribas",
        "fecha": "15/01/2020",
        "titulo": "Tutorial Power BI: Conectar con origen de datos REST API",
        "link": "https://vandalytic.com/tutorial-power-bi-conectar-con-origen-de-datos-rest-api/",
        "contenido": "Empezamos el a√±o con un nuevo tutorial de Power BI que os permitir√° acceder a m√∫ltiples soluciones online a trav√©s de la API de sus fabricantes. En meses anteriores, hemos realizado paneles que obten√≠an datos de servicios en l√≠nea como Power BI para Spotify o Power BI para Strava, pero siempre descarg√°bamos los datos en local y luego los analiz√°bamos con Power BI. Hoy ha llegado el d√≠a en que aprenderemos a conectar directamente v√≠a la API del fabricante, lo que supone muchas ventajas: No tendremos que solicitar la descarga de datos para poder actualizar nuestro panel. Podremos acceder y actualizar los datos en el momento. Podremos programar la actualizaci√≥n de datos para tener siempre datos actualizados sin intervenci√≥n manual. ¬øQu√© es una API? Actualmente, muchos servicios y soluciones que utilizamos en nuestro d√≠a a d√≠a personal o profesional est√°n creados en la nube y accedemos a ellos v√≠a web. En estos casos no tenemos un acceso directo a nuestros datos y es por ello que el fabricante suele desarrollar un acceso controlado a los datos a trav√©s de una API. Normalmente la API no s√≥lo permite leer nuestros datos, sino tambi√©n crear nuevos o editar los existentes. Con ello se consigue que otras soluciones complementarias puedan interactuar entre si. Por ejemplo, Strava tiene conexi√≥n con diferentes fabricantes de relojes deportivos para que puedan enviar y actualizar datos de los ejercicios realizados. De igual modo, Spotify interactua con Shazam para que la m√∫sica que descubres en esta app la puedas incluir en tu lista de Spotify. No voy a entrar en como funcionan por dentro las APIs porque cada una funciona de manera diferente, pero vamos a basar el tutorial en un caso muy com√∫n: una API web que necesita de un token/key de autorizaci√≥n y devuelve los datos en formato JSON. Construyendo un panel de Power BI con los resultados de La Liga 19-20 v√≠a API Obtener Key de la API En este tutorial vamos a utilizar la API proporcionada por Football Data con toda la informaci√≥n de las diferente Ligas de f√∫tbol. Para poder usarla pod√©is registraros gratuitamente y con ello recibir√©is un mail con vuestro TOKEN/KEY personal para poder conectar con la API: Mail de registro con Token Mail de registro con Token En cada caso, tendr√©is que consultar la documentaci√≥n de la API, porque cada fabricante la configura y da acceso a datos de forma diferente. En este caso ten√©is la documentaci√≥n completa en este link. Accediendo a la API desde Power BI Una vez tenemos nuestro Token, podemos abrir un informe en blanco de Power BI Desktop y elegir ‚ÄúObtener Datos‚Äù y como origen de datos ‚ÄúWeb‚Äú. En la ventana emergente, nos preguntar√° la URL a la que queremos conectarnos: Pantalla Emergente origen de datos WEB Pantalla Emergente origen de datos WEB Como os he comentado en el punto anterior, no podemos introducir la url de la API sin m√°s, ya que requiere de una autentificaci√≥n via Token/Key que es necesario pasar en la cabecera de la petici√≥n de datos. Seg√∫n la documentaci√≥n de la API de football-data.org el par√°metro que debemos pasar es: Par√°metro de autentificaci√≥n de la API Par√°metro de autentificaci√≥n de la API Antes de introducir la URL pulsamos la opci√≥n ‚ÄúUso Avanzado‚Äù que nos dar√° las opciones adicionales que necesitaremos. En este primer paso, vamos a solicitar los datos de la lista de equipos de Primera de la temporada actual (en estos datos es la temporada con id 2014): Conexi√≥n v√≠a API a trav√©s de origen de datos web Conexi√≥n v√≠a API a trav√©s de origen de datos web Como veis, s√≥lo hay que indicar la url que obtenemos de la documentaci√≥n y el nombre del par√°metro de autentificaci√≥n y su valor (en este caso el token que nos han enviado por mail). Cada API es diferente, por lo que el par√°metro de autentificaci√≥n, que en este caso se llama X-Auth-Token ,en otras APIs se llamar√° Key o APIKey o quiz√°s haya que pasar 2 par√°metros. Por eso, es muy importante leer previamente la documentaci√≥n de la API. Con esta conexi√≥n recibiremos el fichero JSON en Power BI que tendr√° este aspecto: Resultado JSON de la consulta de equipos Resultado JSON de la consulta de equipos Como veis, no es la tabla que esper√°bamos, hay que hacer unas transformaciones b√°sicas. Transformando el fichero JSON en una tabla Lo primero es usar la opci√≥n ‚ÄúConvertir en Tabla‚Äù que aparece en la parte superior izquierda: Opci√≥n de Convertir en Tabla Opci√≥n de Convertir en Tabla El resultado ser√° el siguiente: Opci√≥n Transponer JSON transformado en tabla Ahora necesitamos Transponer, ya que lo que queremos que sean campos o columnas ahora lo tenemos en filas y seguramente necesitemos tambi√©n Usar la primera fila como encabezado: Opci√≥n Usar Primera Fila como encabezado Opci√≥n Usar Primera Fila como encabezado Tras estas 2 transformaciones b√°sicas, obtendremos lo siguiente: Empezando a desglosar el fichero JSON Empezando a desglosar el fichero JSON Como veis, es un s√≥lo registro con algunos campos. En algunos pone ‚ÄúRecord‚Äù y en otros ‚ÄúList‚Äú. Si pulsamos la doble flecha de cada uno de estos campos se ira desgranando la informaci√≥n del fichero de Equipos del JSON. La diferencia entre Record y List es la siguiente: RECORD: despliega varios campos pero dentro del mismo registro LIST: despliega varios campos como filas (nuevos registros) Una vez hayamos desglosados los campos necesarios, tendremos ya una tabla reconocible: Tabla de Equipos de La Liga Tabla de Equipos de La Liga En el ejemplo que presento en este tutorial hemos realizado este mismo proceso para las siguientes entidades de la API: Equipos: http://api.football-data.org/v2/competitions/2014/teams Temporada: http://api.football-data.org/v2/competitions/2014 Partidos: http://api.football-data.org/v2/competitions/2014/matches Cifras del equipo: http://api.football-data.org/v2/competitions/2014/standings Algunos trucos: Puntos a tener en cuenta He duplicado la tabla de partidos para tener una de partidos como local y otra de partidos como visitante. Era la manera m√°s f√°cil de filtrar por el equipo y que pudiese mostrar todos los partidos de ese equipo. Aparte, fijaos que la tabla de equipo tiene una url del escudo de cada club. Recordad el tutorial para mostrar im√°genes en tabla. El link al escudo del Legan√©s y del Getafe no funcionan y he tenido que reemplazar las urls. El panel de Power BI con los resultados de La Liga Como resultado de el trabajo explicado anteriormente y con un poco de dedicaci√≥n al dise√±o del informe, he dise√±ado el siguiente panel de La Liga para que interactueis con √©l: Conclusiones La conectividad con APIs web sin necesidad de codificar en Python, C, Java u otro lenguaje de programaci√≥n nos abre las puertas a millones de datos disponibles v√≠a API web. Os animo a probarlo, y ya sab√©is que si os suscrib√≠s a la newsletter del blog tendr√©is acceso cada mes a los fichero originales pbix de todos los post y tutoriales que he realizado. ¬°SUSCR√çBETE YA! Nombre Email Doy mi consentimiento para almacenar mis datos para env√≠o de newsletters. Si te suscribes a la newsletter tendr√°s acceso a los ficheros Power BI originales de nuestros tutoriales y post. Adem√°s tendr√°s derecho a participar en sorteos peri√≥dicos que realizaremos en el blog"
      },
      {
        "id": 14,
        "autor": "H√©ctor Patricio",
        "fecha": "12/03/2019",
        "titulo": "Tres formas de crear API‚Äôs con Python",
        "link": "https://blog.thedojo.mx/2019/03/12/tres-formas-de-crear-api-s-con-python.html",
        "contenido": "Es una tarea com√∫n para un desarrollador el dise√±ar e implementar una API web. Veremos tres herramientas para desarrollar tu API, de lo m√°s sencillo a lo m√°s completo: Hug, Flask y Django Rest Framework. HugPermalink Hug es una peque√±a biblioteca para crear API‚Äôs muy f√°ciles de entender y mantener. Provee un serie de herramientas que permiten hacer tu API muy r√°pidamente, con poco c√≥digo y siguiendo las mejores pr√°cticas. Hug no es una biblioteca exclusiva para hacer API‚Äôs web, sino que se enfoca en permitirte crear API‚Äôs en el m√°s amplio sentido de la palabra: una intefaz para permitir el uso automatizado (mediante c√≥digo) de tu programa. Si haces una API en Hug, podr√°s exponerla a parte de en web como un m√≥dulo de Python o a la interfaz de l√≠nea de comandos. Con hug, puedes hacer algo tan sencillo como lo siguiente: import hug @hug.get() def hola_apis(): return {mensaje: Hola API's} ¬°Y listo! Lo anterior es una API lista para ser consumida, no necesitas crear ni configuraci√≥n ni caberceras ni nada m√°s (aunque claro que las puedes poner). Hug provee de cosas interesantes: Documentaci√≥n autom√°tica Verificaci√≥n y validaci√≥n de par√°metros -> usando el type hinting de Python 3 Versionamiento de API‚Äôs (una de las cosas m√°s dif√≠ciles de hacer bien en el ciclo de vida de una API) M√∫ltiples tipos de salida con s√≥lo cambiar la configuraci√≥n Extensibilidad y flexibilidad Hug es compatible con WSGI (Web Server Gateway Interface) por lo que puedes ponerlo en producci√≥n usando Gunicorn o uWSGI detr√°s de un servidor HTTP como proxy reverso (NGINX o Apache, entre otros). Aqu√≠ tienes un post introcutorio a Hug: Crear APIs REST con Python y Hug Cu√°ndo usarlo: No he usado Hug en producci√≥n a√∫n, pero promete ser muy bueno, sobre todo con las exigencias del mundo actual. Lo recomendar√≠a para proyectos peque√±os y medianos y para exponer bibliotecas o m√≥dulos que ya existen en alguna parte de c√≥digo como versiones Web o CLI. FlaskPermalink Flask es una herramienta flexible para programar proyectos web en Python. Provee una capa m√≠nima de ruteo y compatibilidad con WSGI, as√≠ como funcionalidades y helpers comunes para las tarea m√°s comunes en desarrollo web. Entre las caracter√≠sticas de Flask est√°n: Integraci√≥n por default con Jinja2 Soporte de cookies de sesi√≥n seguras Servidor web para desarrollo y debuggeo Personalmente, considero Flask como la opci√≥n m√°s flexible para desarrollar proyectos web en Python. Adem√°s permite empezar f√°cil. Y compar√°ndolo con otras opciones, es mucho m√°s ligero, permiti√©ndote integrar tus propias opciones para diferentes partes del proyecto. Si tu proyecto es muy poco com√∫n o muy especializado, Flask es la mejor opci√≥n. Aqu√≠ un peque√±o ejemplo de c√≥mo se empiza con Flask (sacado de su documentaci√≥n en su mayor√≠a) from flask import Flask, jsonify app = Flask(__name__) @app.route(/) def hello(): return jsonify({message: Hello World!}) As√≠ es: puedes empezar con un solo archivo, Flask hizo todo por ti. Flask tambi√©n tiene bastantes m√≥dulos que te ayudan a desarrollar funcionalidades m√°s r√°pido y con poco c√≥digo. Si quieres aprender m√°s aqu√≠ tienes algunos recursos: Creando una API y aplicaci√≥n web con Flask Dise√±ando APIs con Flask Construir una API rest con Flask M√°s adelante tendremos nuestro propio post . Cu√°ndo usarlo: Personalmente lo uso para proyectos peque√±os o medianos que s√© que no crecer√°n demasiado en caracter√≠sticas en el mediano plazo. Si tienes que hacer cosas complicadas, Flask requiere bastante experiencia t√©cnia y de arquitectura para que no se te vaya de las manos el proyecto, su flexibilidad puede trabajar en tu contra en estos casos. Django y Django Rest FrameworkPermalink Django es un framework MVT (Model-View-Template, su propia variante del MVC) para desarrollar proyectos web robustos de manera r√°pida. Django provee: Un sistema de templating propio Un ORM (Object Relational Mapper ‚Äì una capa de abstracci√≥n de la base de datos) Ruteo robusto Sistema de configuraci√≥n robusto y adaptable Interfaz de administraci√≥n autom√°tica Administraci√≥n de usuarios ‚Ä¶y muchas otras cosas m√°s. Como ver√°s es mucho m√°s robusto(viene por default con m√°s cosas) que los otros dos, pero tambi√©n es el que tiene la mayor curva de aprendizaje. Si encuentras algo para lo que no est√© preparado Django o DRF √©ste es el caso en el que se requiere m√°s experiencia t√©cnica para modificarlo. Django posee much√≠simos paquetes para extenderlo en funciones y uno de los m√°s famosos es el Django REST Framework (DRF a partir de ahora), que provee todas las funcionalidades que te imagines para desarrollar una API de manera sencilla y con pocas l√≠neas de c√≥digo. El DRF permite crear endpoints a partir de modelos, relaciones entre modelos, endpoints customizados basados en clases y un mont√≥n de cosas m√°s. Se enfoca en crear API‚Äôs navegables. Adem√°s nos da una interfaz para para pruebas desde el navegador web con todas las facilidades del mundo. Puedes pensar en Django y DRF como una navaja suiza con todo lo que necesitas para desarrollar una API un poco m√°s compleja de manera r√°pida. No pondremos el ejemplo de c√≥digo aqu√≠, porque en este caso el c√≥digo se reparte entre varios archivos, pero te compartimos los siguientes recursos por si quieres irte por este camino y sients que es lo que necesitas: ¬øQu√© es Django? - ESte es uno de los mejores tutoriales de Django en internet, muy completo, as√≠ que vale la pena que lo sigas si quieres aprenderlo. Introducci√≥n a Django REST Framework - Este post lo puedes seguir una vez que tengas una comprensi√≥n b√°sica de Django. Cu√°ndo usarlo: Django es mi elecci√≥n para proyectos que se que pueden requerir caracter√≠sitcas enterprise, pueden crecer en funcionalidades en el mediano plazo y estas funcionalidades no est√°n demasiado fuera de lo com√∫n. Si quieres desarrollar algo r√°pidamente en estas condiciones, no hay nada que pensar: usa Django, con √©l (despu√©s de la curva de aprendizaje), estar√°s haciendo cosas medianamente complejas en muy poco tiempo, adem√°s de que su inmensa cantidad de m√≥dulos para hacer much√≠simas cosas sin tanto trabajo te facilitar√° la vida. Conclusi√≥nPermalink Algo que hay que tener en mente siempre es que se debe de elegir la herramienta adecuada para el trabajo a la mano. En los tres casos de las herramientas propuestas anteriormente tienes que analizar muy bien tus necesidades antes de decidirte por una, pero incluso podr√≠as usar una para una etapa del proyecto y cambiarla en una fase posterior. Esperamos que esta peque√±a gu√≠a acerca de las opciones para elegir la mejor herramienta para crear tu API con flask te sea √∫til, y si tienes alguna opini√≥n/experiencia diferente es bienvenida en los comentarios."
      },
      {
        "id": 15,
        "autor": "Eduardo Ismael Garc√≠a P√©rez",
        "fecha": "09/10/19",
        "titulo": "¬øC√≥mo Crear Tu Propia API Con Flask?",
        "link": "https://codigofacilito.com/articulos/api-flask",
        "contenido": "En esta ocasi√≥n aprenderemos a crear nuestro propio servicio RESTFul con Flask, unos de los micro frameworks m√°s populares de Python. Para el tutorial estar√© trabajando con el gestor de base de datos PostreSQL, sin embargo t√∫ puedes utilizar el gestor que desees. Bien, sin m√°s dilaci√≥n comencemos. üòé DEPENDENCIAS Lo primero que haremos ser√° instalar las bibliotecas necesarias. Para esto recomiendo te encuentres en un entorno virtual. ü§≠ python3 -m venv env Las dependecias necesar√≠as ser√°n: Flask, psycopg2 y SQLAlchemy. pip install flask pip install psycopg2-binary pip install Flask-SQLAlchemy SQLAlchemy es un ORM el cual nos permite trabajar con una base de datos sin tener que conocer y/o dominar SQL. API El primer paso ser√° definir los endpoints de nuestra API, en mi caso cinco endpoints. ü§† main.py from flask import Flask from flask import jsonify def create_app(enviroment): app = Flask(__name__) return app app = create_app() app.route('/api/v1/users', methods=['GET']) def get_users(): response = {'message': 'success'} return jsonify(response) app.route('/api/v1/users/<id>', methods=['GET']) def get_user(id): response = {'message': 'success'} return jsonify(response) @app.route('/api/v1/users/', methods=['POST']) def create_user(): response = {'message': 'success'} return jsonify(response) @app.route('/api/v1/users/<id>', methods=['PUT']) def update_user(id): response = {'message': 'success'} return jsonify(response) @app.route('/api/v1/users/<id>', methods=['DELETE']) def delete_user(id): response = {'message': 'success'} return jsonify(response) if __name__ == '__main__': app.run(debug=True) Para probar nuestro API podemos utilizar cURL, una herramienta nativa para sistemas operativos unix o podemos utilizar POSTMAN. El siguiente paso ser√° definir nuestro archivo config.py, archivo donde se encontrar√°n las configuraciones del proyecto. class Config: pass class DevelopmentConfig(Config): DEBUG = True SQLALCHEMY_DATABASE_URI = 'postgresql://localhost/users' SQLALCHEMY_TRACK_MODIFICATIONS = False config = { 'development': DevelopmentConfig, } En este caso coloco la direcci√≥n de la base de datos directamente en el archivo, en texto plano. Esto lo hago solo por fines pr√°cticos, yo te recomiendo utilices una variable de entorno. Importamos nuestra configuraci√≥n. main.py from config import config def create_app(enviroment): app = Flask(__name__) app.config.from_object(enviroment) return app enviroment = config['development'] app = create_app(enviroment) Ahora procedemos a crear nuestro modelo. En este caso un modelo User. Para ello trabajaremos en el archivo models.py. from datetime import datetime from flask_sqlalchemy import SQLAlchemy db = SQLAlchemy() class User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(50), nullable=False) created_at = db.Column(db.DateTime(), nullable=False, default=db.func.current_timestamp()) Un modelo bastante sencillo, sin embargo para fines practicos funcionar√°. El siguiente paso ser√° crear nuestra tabla y asociar la base de datos con la aplicaci√≥n de Flask. from models import db def create_app(enviroment): app = Flask(__name__) app.config.from_object(enviroment) with app.app_context(): db.init_app(app) db.create_all() return app Antes de ejecutar el proyecto es necesario que crees la base de datos en tu servidor. ü§ñ CREATE DATABASE users; Listo, ya hicimos lo m√°s complicado, ahora toca dar funcionalidad a cada uno de los endpoints. Comencemos con crear. from models import User @app.route('/api/v1/users/', methods=['POST']) def create_user(): json = request.get_json(force=True) if json.get('username') is None: return jsonify({'message': 'Bad request'}), 400 user = User.create(json['username']) return jsonify({'user': user.json() }) En este caso creamos un m√©todo de clase (create) en nuestro modelo User para instanciar y almace nuestro usuario. El m√©todo encargado de persistir es save. @classmethod def create(cls, username): user = User(username=username) return user.save() def save(self): try: db.session.add(self) db.session.commit() return self except: return False De igual forma creamos un m√©todo de instancia json para serializar nuestro objeto. def json(self): return { 'id': self.id, 'username': self.username, 'created_at': self.created_at } Procedemos a obtener a los usuarios, algo muy sencillo con SQLAlchemy. ‚ò∫ @app.route('/api/v1/users', methods=['GET']) def get_users(): users = [ user.json() for user in User.query.all() ] return jsonify({'users': users }) @app.route('/api/v1/users/<id>', methods=['GET']) def get_user(id): user = User.query.filter_by(id=id).first() if user is None: return jsonify({'message': 'User does not exists'}), 404 return jsonify({'user': user.json() }) El siguiente paso ser√° actualizar un usuario. user = User.query.filter_by(id=id).first() if user is None: return jsonify({'message': 'User does not exists'}), 404 json = request.get_json(force=True) if json.get('username') is None: return jsonify({'message': 'Bad request'}), 400 user.username = json['username'] user.update() return jsonify({'user': user.json() }) Tendro del modelo User generamos un nuevo m√©todo. def update(self): self.save() En este caso el endpoint para editar es, quiz√°s, el m√°s complejo; como podemos observar tenemos c√≥digo duplicado, sin√≥nimos que podemos mejorar a√∫n m√°s el proyecto. ü§™ y finalmente pasamos a eliminar a un usuario. @app.route('/api/v1/users/<id>', methods=['DELETE']) def delete_user(id): user = User.query.filter_by(id=id).first() if user is None: return jsonify({'message': 'User does not exists'}), 404 user.delete() return jsonify({'user': user.json() }) Creamos un m√©todo de instancia en nuestro modelo User. def delete(self): try: db.session.delete(self) db.session.commit() return True except: return False De esta forma es como quedar√≠a, por el momento, mi API. Aunque tenemos c√≥digo duplicado podemos llegar a solucionarlo mediante decoradores. En Flask nuestros decoradores tendr√°n la siguiente estructura. def decorator_name(function): def wrap(*args, **kwargs): return function(*args, **kwargs) wrap.__name__ = function.__name__ return wrap"
      },
      {
        "id": 16,
        "autor": "Monty Shokeen",
        "pagina": "envaotuts+",
        "fecha": "09/01/2017",
        "titulo": "M√≥dulos Matem√°ticos en Python: Math y Cmath",
        "link": "https://code.tutsplus.com/es/tutorials/mathematical-modules-in-python-math-and-cmath--cms-26913",
        "contenido": "Cuando escribimos programas en nuestra vida diaria, usualmente nos encontramos con situaciones en donde necesitamos usar un poco de matem√°ticas para hacer una tarea. Como otros lenguajes de programaci√≥n, Python proporciona varios operadores para realizar c√°lculos b√°sicos como * para multiplicaci√≥n, % para m√≥dulos y // para divisi√≥n. Si est√°s escribiendo un programa para realizar tareas espec√≠ficas como estudiar movimiento peri√≥dico o simular circuitos el√©ctricos, necesitar√°s trabajar con funciones trigonom√©tricas as√≠ como n√∫meros complejos. Mientras que no puedes usar estas funciones directamente, puedes acceder a ellas incluyendo dos m√≥dulos matem√°ticos primero. Estos m√≥dulos son math y cmath. El primero te da acceso a funciones hiperb√≥licas, trigonom√©tricas y logar√≠tmicas para n√∫meros reales mientras que la √∫ltima te permite trabajar con n√∫meros complejos. En este tutorial, recorrer√© todas las funciones importantes ofrecidas por estos m√≥dulos. A menos que se mencione expl√≠citamente, todos los valores devueltos son flotantes. Funciones Aritm√©ticas Estas funciones realizan varias operaciones aritm√©ticas como calcular el valor superior, inferior o absoluto de un n√∫mero usando las funciones floor(x), ceil(x), y fabs(x) respectivamente. La funci√≥n ceil(x) devolver√° el entero m√°s peque√±o que sea mayor qu√© o igual a x. De manera similar, floor(x) devuelve el entero m√°s grande menor qu√© o igual a x. La funci√≥n fabs(x) devuelve el valor absoluto de x. Tambi√©n puedes realizar operaciones no triviales como calcular el factorial de un n√∫mero usando factorial(x). Un factorial es el producto de un entero y todos los enteros positivos menores que este. Es usado extensivamente cuando se trabaja con combinaciones y permutaciones. Tambi√©n puede ser usado para calcular el valor de las funciones seno y coseno. 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 import math def getsin(x): multiplier = 1 result = 0 for i in range(1,20,2): result += multiplier*pow(x,i)/math.factorial(i) multiplier *= -1 return result getsin(math.pi/2) # returns 1.0 getsin(math.pi/4) # returns 0.7071067811865475 Otra funci√≥n √∫til en el m√≥dulo math es gcd(x,y), la cu√°l te da el m√°ximo com√∫n divisor (MCD) de dos n√∫meros x y y. Cuando x y y no son cero, esta funci√≥n regresa el entero positivo m√°s grande que divida tanto a x como a y. Puedes usarlo indirectamente para calcular el m√≠nimo com√∫n m√∫ltiplo de dos n√∫meros usando la siguiente f√≥rmula: 1 gcd(a, b) x lcm(a, b) = a x b Aqu√≠ hay unas cuantas de las funciones aritm√©ticas que Python ofrece: 1 2 3 4 5 6 7 8 9 import math math.ceil(1.001)    # returns 2 math.floor(1.001)   # returns 1 math.factorial(10)  # returns 3628800 math.gcd(10,125)    # returns 5 math.trunc(1.001)   # returns 1 math.trunc(1.999)   # returns 1 Funciones Trigonom√©tricas Estas funciones relacionan los √°ngulos de un tri√°ngulo a sus lados. Tienen muchas aplicaciones, incluyendo el estudio de tri√°ngulos y el modelado de fen√≥menos peri√≥dicos como el sonido y ondas de luz. Ten en mente que el √°ngulo que proporcionas est√° en radianes. Puedes calcular sin(x), cos(x), y tan(x) directamente usando este m√≥dulo. Sin embargo, no hay f√≥rmula directa para calcular cosec(x), sec(x), y cot(x), pero su valor es igual al rec√≠proco del valor devuelto por sin(x), cos(x), y tan(x) respectivamente. En lugar de calcular el valor de funciones trigonom√©tricas como cierto √°ngulo, tambi√©n puedes hacer el c√°lculo inverso y calcular el √°ngulo al que tienen un valor dado usando asin(x), acos(x), and atan(x). ¬øEst√°s familiarizado con el teorema de Pit√°goras? Este establece que el cuadrado de la hipotenusa (el lado opuesto del √°ngulo derecho) es igual a la suma de los cuadrados de los otros dos lados. La hipotenusa es tambi√©n el lado m√°s grande de un tri√°ngulo rect√°ngulo. El m√≥dulo math proporciona la funci√≥n hypot(a,b) para calcular la longitud de la hipotenusa. 1 2 3 4 5 6 7 8 9 import math math.sin(math.pi/4)    # returns 0.7071067811865476 math.cos(math.pi)      # returns -1.0 math.tan(math.pi/6)    # returns 0.5773502691896257 math.hypot(12,5)       # returns 13.0 math.atan(0.5773502691896257) # returns 0.5235987755982988 math.asin(0.7071067811865476) # returns 0.7853981633974484 Funciones Hiperb√≥licas Las funciones hiperb√≥licas son an√°logas a las funciones trigonom√©tricas que est√°n basadas en una hip√©rbole en lugar de un c√≠rculo. En trigonometr√≠a, los puntos (cos b, sin b) representan los puntos de un c√≠rculo unitario. En caso de funciones hiperb√≥licas, los puntos (cosh b, sinh b) representan los puntos que forman la mitad derecha de una hip√©rbola equil√°tera. Justo como las funciones trigonom√©tricas, puedes calcular el valor de sinh(x), cosh(x), y tanh(x) directamente. El resto de los valores pueden ser calculados usando varias relaciones entra estos tres valores. Tambi√©n hay otras funciones como asinh(x), acosh(x), and atanh(x), lac cuales pueden ser usadas para culcular la inversa de los valores hiperb√≥licos correspondientes. 1 2 3 4 5 6 7 8 9 import math math.sinh(math.pi)    # returns 11.548739357257746 math.cosh(math.pi)    # returns 11.591953275521519 math.cosh(math.pi)    # returns 0.99627207622075 math.asinh(11.548739357257746)   # returns 3.141592653589793 math.acosh(11.591953275521519)   # returns 3.141592653589793 math.atanh(0.99627207622075)     # returns 3.141592653589798 Ya que math.pi es igual a alrededor de 3.141592653589793, cuando usamos asinh() en el valor devuelto por sinh(math.pi), obtuvimos nuestro œÄ de vuelta. Funciones Exponenciales y Logaritmicas Probablemente estar√°s lidiando con exponentes y logaritmos m√°s seguido que con funciones hiperb√≥licas y trigonom√©tricas. Afortunadamente, el m√≥dulo math proporciona muchas funciones para ayudarnos a calcular logaritmos. Puedes usar log(x,[base]) para calcular el log de un n√∫mero dado x a la base dada. Si dejas fuera el argumento opcional de base, el log de x es calculado a la base e. Aqu√≠, e es una constante matem√°tica cuyo valor es 2.71828182.... y puede ser accedida usando math.e. Por cierto, Python tambi√©n te permite acceder a otra constante œÄ usando math.pi. Si quieres calcular los valores logar√≠tmicos base 2 o base 10, usar log2(x) y log10(x) revolver√° resultados m√°s precisos que log(x, 2) y log(x, 10). Ten en mente que no hay funci√≥n log3(x), as√≠ que tendr√°s que seguir usando log(x, 3) para calcular valores logar√≠tmicos log(x,3). Lo mismo aplica para todas las dem√°s bases. Si el valor cuyo logaritmo est√°s calculando es bastante cercano a 1, puedes usar log1p(x). El 1p en log1p significa 1 m√°s. As√≠ pues, log1p(x) calcula log(1+x) en donde x es cercano a cero. Sin embargo, los resultados son m√°s precisos con loglp(x). Tambi√©n puedes calcular el valor de un n√∫mero x elevado a la potencia y usando pow(x, y). Antes de computar las potencias, esta funci√≥n convierte ambos argumentos a tipo float. Si quieres que el resultado final se compute en potencias enteras exactas, deber√≠as usar la funci√≥n integrada pow() o el operador **. Tambi√©n puedes computar la ra√≠z cuadrada de cualquier n√∫mero dado x usando sqrt(x), pero la misma cosa tambi√©n puede ser lograda usando pow(x, 0.5). 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 import math math.exp(5)                      # returns 148.4131591025766 math.e**5                        # returns 148.4131591025765 math.log(148.41315910257657)     # returns 5.0 math.log(148.41315910257657, 2)  # returns 7.213475204444817 math.log(148.41315910257657, 10) # returns 2.171472409516258 math.log(1.0000025)              # returns 2.4999968749105643e-06 math.log1p(0.0000025)            # returns 2.4999968750052084e-06 math.pow(12.5, 2.8)              # returns 1178.5500657314767 math.pow(144, 0.5)               # returns 12.0 math.sqrt(144)                   # returns 12.0 Advertisement N√∫meros Complejos Los n√∫meros complejos son almacenados inicialmente usando coordenadas rectangulares o Cartesianas. Un n√∫mero complejo z ser√° representado en coordenadas Cartesianas como z = x + iy, en donde x representa la parte real y y representa la parte imaginaria. Otra manera de representarlos es usando coordenadas polares. En este caso, el n√∫mero complejo ser√≠a definido por una combinaci√≥n de los m√≥dulos r y √°ngulo de fase phi. El m√≥dulo r es la distancia entre el n√∫mero complejo z y el origen. El √°ngulo phi es el √°ngulo contrario medido en radianes desde el eje x positivo al segmento de l√≠nea uniendo a z y el origen. Mientras lidiamos con n√∫meros complejos, el m√≥dulo cmath puede ser de gran ayuda. El m√≥dulo de un n√∫mero complejo puede ser calculado usando la funci√≥n integrada abs() y su fase puede ser calculada usando la funci√≥n phase(z) disponible en el m√≥dulo cmath. Puedes convertir un n√∫mero complejo en forma rectangular a forma polar usando polar(z), la cu√°l devolver√° un par (r, phi), en donde r es abs(z) y phi es phase(z). De manera similar, puedes convertir un n√∫mero complejo en forma polar a rectangular usando rect(r, phi). El n√∫mero complejo devuelto por esta funci√≥n es r * (math.cos(phi) + math.sin(phi)*1j). 01 02 03 04 05 06 07 08 09 10 import cmath cmath.polar(complex(1.0, 1.0)) # returns (1.4142135623730951, 0.7853981633974483) cmath.phase(complex(1.0, 1.0)) # returns 0.7853981633974483 abs(complex(1.0, 1.0)) # returns 1.4142135623730951 El m√≥dulo cmath tambi√©n nos permite usar funciones matem√°ticas regulares con n√∫meros complejos. Por ejemplo, puedes calcular la ra√≠z cuadrada de un n√∫mero complejo usando sqrt(z) o su coseno usando cos(z). 1 2 3 4 5 6 7 import cmath cmath.sqrt(complex(25.0, 25.0)) # returns (5.49342056733905+2.2754493028111367j) cmath.cos(complex(25.0, 25.0)) # returns (35685729345.58163+4764987221.458499j) Los n√∫meros complejos tienen muchas aplicaciones como modelado de circuitos el√©ctricos, din√°mica de fluidos, y an√°lisis de se√±ales. Si necesitas trabajar en cualquiera de estas cosas, el m√≥dulo cmath no te decepcionar√°. Ideas Finales Todas estas funciones que discutimos arriba tienen sus aplicaciones espec√≠ficas. Por ejemplo, puedes usar la funci√≥n factorial (x) para resolver problemas de permutaci√≥n. Puedes usar las funciones trigonom√©tricas para resolver un vector en coordenadas Cartesianas. Tambi√©n puedes usar funciones trigonom√©tricas para simular funciones peri√≥dicas como sonido y ondas de luz. De manera similar, la curva de una cuerda colgando entre dos postes puede ser determinada usando una funci√≥n hiperb√≥lica. Ya que todas estas funciones est√°n disponibles directamente en el m√≥dulo math, hace m√°s f√°cil crear peque√±os programas que realicen estas tareas. Espero que hayas disfrutado este tutorial. Si tienes alguna pregunta, h√°zmelo saber en los comentarios."
      },
      {
        "id": 17,
        "autor": "parzibyte",
        "pagina": "parzibyte",
        "fecha": "10/11/2020",
        "titulo": "API REST con Python, Flask y SQLite3",
        "link": "https://parzibyte.me/blog/2020/11/10/api-rest-python-flask-sqlite3/",
        "contenido": "En este tutorial de programaci√≥n con Python aprender√°s a crear una API REST usando Flask, SQLite 3 (para los datos) y JSON para la comunicaci√≥n de datos. Tabla de contenido  ocultar 1 Descripci√≥n de la API 2 Base de datos SQLite3 3 Controlador de juegos: conexi√≥n a base de datos 4 Creando API con Flask y Python 5 Opcional: agregar CORS 6 Poniendo todo junto 7 Probando API Al final tendr√°s una API que puedes consumir desde cualquier cliente, ya sea una aplicaci√≥n para Android, un navegador con JavaScript o incluso otro lenguaje de servidor. Te mostrar√© c√≥mo crear una API que se comunica usando JSON y guarda los datos en SQLite 3. La API estar√° creada con Flask, y usaremos el lenguaje de programaci√≥n Python para manejar todos los datos. Descripci√≥n de la API API con Flask y Python Vamos a usar los 4 verbos HTTP m√°s usados: GET, POST, PUT y DELETE, mismos que estar√°n relacionados con el CRUD de la base de datos. Lo que vamos a gestionar ser√° una base de datos de juegos, mismos que tienen nombre, precio y calificaci√≥n. Tambi√©n tendremos varias operaciones que vamos a exponer a trav√©s de la API creada con Flask: Obtener todos los juegos Crear un nuevo juego Actualizar un juego Eliminar un juego Obtener un juego por ID Primero vamos a crear el CRUD que se relaciona con la base de datos usando Python, y m√°s tarde vamos a exponer todas estas funciones con Flask, ya en la API, codificando como JSON. Base de datos SQLite3 La estructura de la base de datos queda como se ve a continuaci√≥n. Es una √∫nica tabla, aunque a partir de este tutorial podemos crear m√°s tablas, relaciones, etc√©tera. CREATE TABLE IF NOT EXISTS games( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, price REAL NOT NULL, rate INTEGER NOT NULL ) view rawtable.sql hosted with ‚ù§ by GitHub Despu√©s vemos el archivo de conexi√≥n a la base de datos: import sqlite3 DATABASE_NAME = games.db def get_db(): conn = sqlite3.connect(DATABASE_NAME) return conn def create_tables(): tables = [ CREATE TABLE IF NOT EXISTS games( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, price REAL NOT NULL, rate INTEGER NOT NULL ) ] db = get_db() cursor = db.cursor() for table in tables: cursor.execute(table) view rawdb.py hosted with ‚ù§ by GitHub En este archivo de conexi√≥n SQLite3 con Python observamos que la base de datos se llamar√° games.db. Adem√°s, contamos con dos funciones: una de ellas es para obtener la base de datos, y la otra (create_tables) es para crear las tablas dentro de la base de datos solo en caso de que no existan. F√≠jate bien en estas funciones, pues las vamos a importar desde otros archivos. Ahora que ya tenemos definida la base de datos veamos el CRUD de juegos con la base de datos SQLite3. Controlador de juegos: conexi√≥n a base de datos Antes de exponer la base de datos en la API, vamos a crear un controlador de juegos que se va a encargar de todas las operaciones para guardar, actualizar, eliminar y obtener los datos de los juegos. Todas estas funciones se encuentran dentro de un archivo llamado game_controller.py y se ve as√≠: from db import get_db def insert_game(name, price, rate): db = get_db() cursor = db.cursor() statement = INSERT INTO games(name, price, rate) VALUES (?, ?, ?) cursor.execute(statement, [name, price, rate]) db.commit() return True def update_game(id, name, price, rate): db = get_db() cursor = db.cursor() statement = UPDATE games SET name = ?, price = ?, rate = ? WHERE id = ? cursor.execute(statement, [name, price, rate, id]) db.commit() return True def delete_game(id): db = get_db() cursor = db.cursor() statement = DELETE FROM games WHERE id = ? cursor.execute(statement, [id]) db.commit() return True def get_by_id(id): db = get_db() cursor = db.cursor() statement = SELECT id, name, price, rate FROM games WHERE id = ? cursor.execute(statement, [id]) return cursor.fetchone() def get_games(): db = get_db() cursor = db.cursor() query = SELECT id, name, price, rate FROM games cursor.execute(query) return cursor.fetchall() view rawgame_controller.py hosted with ‚ù§ by GitHub En el archivo vemos varias funciones. La funci√≥n insert_game recibe los datos del juego y los inserta en la base de datos (INSERT); todo esto usando sentencias preparadas para evitar inyecciones SQL en esta API que estamos creando con Python y Flask. Tambi√©n vemos otros m√©todos como update_game que realiza la operaci√≥n UPDATE para actualizar un juego, delete_game que elimina un juego (DELETE) a partir de su id, get_by_id que regresa un juego a partir de su id (usando la operaci√≥n SELECT). Finalmente observamos la funci√≥n get_games que devuelve todos los juegos existentes. F√≠jate en que todas las funciones usan la base de datos y un cursor para realizar todas las operaciones. Ahora que ya tenemos el CRUD de las operaciones con la base de datos es momento de exponer todo en la API con Flask. Creando API con Flask y Python Lo primero que hacemos en la API es crear la app de Flask e importar el controlador de los juegos. Tambi√©n importamos una funci√≥n de la base de datos porque necesitamos crear las tablas al iniciar la aplicaci√≥n: from flask import Flask, jsonify, request import game_controller from db import create_tables app = Flask(__name__) view rawmain.py hosted with ‚ù§ by GitHub Ahora definimos las rutas con los verbos GET, PUT, POST y DELETE: @app.route('/games', methods=[GET]) def get_games(): games = game_controller.get_games() return jsonify(games) @app.route(/game, methods=[POST]) def insert_game(): game_details = request.get_json() name = game_details[name] price = game_details[price] rate = game_details[rate] result = game_controller.insert_game(name, price, rate) return jsonify(result) @app.route(/game, methods=[PUT]) def update_game(): game_details = request.get_json() id = game_details[id] name = game_details[name] price = game_details[price] rate = game_details[rate] result = game_controller.update_game(id, name, price, rate) return jsonify(result) @app.route(/game/<id>, methods=[DELETE]) def delete_game(id): result = game_controller.delete_game(id) return jsonify(result) @app.route(/game/<id>, methods=[GET]) def get_game_by_id(id): game = game_controller.get_by_id(id) return jsonify(game) view rawroutes.py hosted with ‚ù§ by GitHub Cada ruta expone una funci√≥n del controlador de juegos que vimos anteriormente, que a su vez interact√∫a con la base de datos de SQLite3. Es importante destacar algunas cosas. Por ejemplo, al actualizar e insertar un juego leemos el JSON de la petici√≥n con get_json y accedemos al diccionario. En el caso de eliminar o de obtener por ID leemos la variable id desde la ruta como <variable> y recibi√©ndola en el m√©todo. Tambi√©n f√≠jate en que esta API con Python se comunica a trav√©s de JSON, por lo que todas las respuestas se hacen de acuerdo a lo que regresa la funci√≥n jsonify. Finalmente creamos la app de Flask para iniciar el servidor y escuchar peticiones: if __name__ == __main__: create_tables() Here you can change debug and port Remember that, in order to make this API functional, you must set debug in False app.run(host='0.0.0.0', port=8000, debug=False) view rawinit.py hosted with ‚ù§ by GitHub Opcional: agregar CORS Si vas a consumir esta API desde un dominio distinto al de la misma, necesitas habilitar CORS. Basta con agregar el siguiente fragmento de c√≥digo en la API (en el repositorio encontrar√°s el c√≥digo ya agregado, mismo que puedes remover si quieres): Enable CORS. Disable it if you don't need CORS @app.after_request def after_request(response): response.headers[Access-Control-Allow-Origin] = * # <- You can change * for a domain for example http://localhost response.headers[Access-Control-Allow-Credentials] = true response.headers[Access-Control-Allow-Methods] = POST, GET, OPTIONS, PUT, DELETE response.headers[Access-Control-Allow-Headers] = Accept, Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization return response view rawcors.py hosted with ‚ù§ by GitHub Poniendo todo junto El c√≥digo completo de la API queda as√≠: API REST con Python 3 y SQLite 3 By Parzibyte: ** https://parzibyte.me/blog ** from flask import Flask, jsonify, request import game_controller from db import create_tables app = Flask(__name__) @app.route('/games', methods=[GET]) def get_games(): games = game_controller.get_games() return jsonify(games) @app.route(/game, methods=[POST]) def insert_game(): game_details = request.get_json() name = game_details[name] price = game_details[price] rate = game_details[rate] result = game_controller.insert_game(name, price, rate) return jsonify(result) @app.route(/game, methods=[PUT]) def update_game(): game_details = request.get_json() id = game_details[id] name = game_details[name] price = game_details[price] rate = game_details[rate] result = game_controller.update_game(id, name, price, rate) return jsonify(result) @app.route(/game/<id>, methods=[DELETE]) def delete_game(id): result = game_controller.delete_game(id) return jsonify(result) @app.route(/game/<id>, methods=[GET]) def get_game_by_id(id): game = game_controller.get_by_id(id) return jsonify(game) if __name__ == __main__: create_tables() Here you can change debug and port Remember that, in order to make this API functional, you must set debug in False app.run(host='0.0.0.0', port=8000, debug=False) view rawmain.py hosted with ‚ù§ by GitHub Si quieres ver el c√≥digo de los otros archivos y el repositorio completo, visita mi GitHub. Ah√≠ podr√°s descargar y probar todo el c√≥digo open source. Recuerda que para iniciar el servidor y la API debes ejecutar: python main.py O en su defecto: python3 main.py Probando API Despu√©s de clonar y ejecutar el repositorio puedes realizar las pruebas usando Postman o cualquier lenguaje de tu preferencia. M√°s adelante traer√© ejemplos de consumo con Frameworks JavaScript o con JavaScript puro. Tambi√©n puedes probar la API en l√≠nea, en el siguiente enlace (revisa las rutas definidas en caso de que aparezca un error 404 o 405): https://apirestflaskpythonsqlite3.parzibyte.repl.co/ Por ejemplo, para ver todos los juegos, es: https://apirestflaskpythonsqlite3.parzibyte.repl.co/games Mientras tanto te dejo una captura probando la API: Consumiendo API REST creada con Flask y Python usando SQLite y JSON Si te gusta Python, te invito a leer m√°s contenido de ese tema en mi blog. O aprende m√°s sobre Flask. Estoy disponible para trabajar en tu proyecto o realizar tu tarea pendiente, no dudes en ponerte en contacto conmigo. Si el post fue de tu agrado muestra tu apoyo comparti√©ndolo, suscribi√©ndote al blog, sigui√©ndome o realizando una donaci√≥n. Suscribir por correo Ingresa tu correo y recibir√°s mis √∫ltimas entradas sobre programaci√≥n, open source, bases de datos y todo lo relacionado con inform√°tica √önete a otros 1,548 suscriptores"
      },
      {
        "id": 18,
        "autor": "Makina Corpus",
        "pagina": "rapidoplone",
        "fecha": "00/00/2015",
        "titulo": "API de Python",
        "link": "https://rapidoplone.readthedocs.io/es/latest/python-api.html",
        "contenido": "API de Python Cualquier funci√≥n Python de Rapido recibe el context como par√°metro. El context proporciona las siguientes propiedades: context.app context.request and context.parent_request context.portal context.content context.record context.api context.rapido context.modules Registro Lista de control de acceso context.app Esta propiedad da acceso al objeto de aplicaci√≥n Rapido. Propiedades acl Devuelve el objeto de la lista de control de acceso de la aplicaci√≥n Rapido (ver abajo). blocks Devuelve los identificadores de bloque existentes. indexes Devuelve los identificadores de √≠ndice existentes. url Devuelve la URL de la aplicaci√≥n. M√©todos create_record(self, id=None) Crea y devuelve un nuevo registro. Si no se proporciona id, se genera una predeterminada. Si id ya existe, se sustituye por otro (como ...-1, ...-2). delete_record(self, id=None, record=None, ondelete=True) Elimine el registro (que se puede pasar como objeto o como id). Si la ondelete es verdad, la funci√≥n on_delete ser√° llamada (si existe) antes de borrar el registro. get_block(self, block_id) Devuelve un bloque. get_record(self, id) Devuelve el registro correspondiente al id, o None si no existe. log(self, message) Registra un mensaje en el registro del servidor. Si la aplicaci√≥n est√° en modo de depuraci√≥n, registra el mismo mensaje en la consola javascript del navegador. Los mensajes pueden ser cadenas o cualquier otro objeto serializable. records(self) Devuelve todos los registros como una lista. _records(self) Devuelve todos los registros como un generador de Python. search(self, query, sort_index=None, reverse=False) Realiza una b√∫squeda y devuelve registros como una lista. _search(self, query, sort_index=None, reverse=False) Realiza una b√∫squeda y devuelve registros como un generador de Python. context.request and context.parent_request context.request es la actual request a Rapido, como: http://localhost:8080/Plone/@@rapido/rating/blocks/rate Cuando un bloque est√° embebido en una p√°gina de Plone, context.request fue emitido por el navegador del usuario, fue emitido por Diazo. Para obtener el request emitida por el navegador del usuario, nosotros usamos context.parent_request. Ambos son objetos de solicitud HTTP, consulte la documentaci√≥n de referencia. Ejemplos: Lectura de valores presentados: val1 = context.request.get('field_1')  # returns None if key doesn't exist val1 = context.request['field_2']  # fail if key doesn't exist Lectura del BODY: request.get('BODY') context.portal Devolver el objeto de portal Plone. Es equivalente a: context.api.portal.get() La tarea m√°s com√∫n que realizaremos a trav√©s del objeto de portal es obtener su contenido: folder = context.portal['my-folder'] context.content Devuelve el contenido actual de Plone. Las tareas m√°s comunes que realizaremos en el contenido son: leer / escribir sus atributos (lectura / escritura): the_tile = context.content.title context.content.title = I prefer another title obteniendo su URL: context.content.absolute_url() Para manipular el contenido, consulte la documentaci√≥n de la API de Plone sobre el contenido. Nota Dependiendo de su tipo de contenido, el objeto de contenido puede tener m√©todos y propiedades muy diferentes. context.record Devuelve el registro Rapido actual si lo hay. Consulte Registro para obtener m√°s informaci√≥n. context.api Da acceso completo a la API de Plone. Advertencia No es necesario importar la API, como se muestra en todos los ejemplos de API de Plone: from plone import api  # WRONG porque la API ya est√° disponible en el context de Rapido: catalog = context.api.portal.get().portal_catalog Esta API permite principalmente: buscar contenidos; por ejemplo: folders = context.api.content.find(portal_type=Folder) # be careful, the find() method returns Brain objects, not real objects # so only indexed attributes are available. desc = folders[0].Description # OK folders[0].objectIds() # WRONG! folder = folders[0].getObject() folder.objectIds() # OK! para manipular contenidos (create / delete / move / publish / etc), ejemplo: new_page = context.api.content.create( type='Document', title='My Content', container=context.content) context.api.content.transition(obj=new_page, transition='publish') para acceder o gestionar la informaci√≥n de usuarios y grupos y enviar correos electr√≥nicos. Ejemplo: current_user = context.api.user.get_current() context.api.portal.send_email( recipient=current_user.getProperty(email), sender=noreply@plone.org, subject=Hello, body=World, ) Para ejemplos m√°s detallados , consulte la documentaci√≥n de la API de Plone. context.rapido context.rapido es una funci√≥n capaz de obtener otra aplicaci√≥n Rapido en nuestro script actual. Toma como par√°metro obligatorio el id de la aplicaci√≥n Rapido. Ejemplo: purchase_app = context.rapido('purchase') new_purchase_order = purchase_app.create_record() Tambi√©n puede aceptar un par√°metro content para proporcionar un espec√≠fico contexto contenido a la aplicaci√≥n (si no se proporciona, se tomar√° el contenido actual). Ejemplo: stat_app = context.rapido('stats', content=context.portal.news) context.modules Advertencia Por razones de seguridad, no se permite importar un m√≥dulo Python en un archivo Rapido Python. Rapido proporciona algunos m√≥dulos seguros a trav√©s de context.modules: context.modules.datetime: Tipos b√°sicos de fecha y hora, context.modules.random: Genera n√∫meros pseudo-aleatorios, context.modules.time: Tiempo de acceso y conversiones. Si necesitamos agregar m√≥dulos a context.modules, podemos hacerlo agregando en nuestro propio complemento de la siguiente forma: import re from rapido.core import app app.safe_modules.re = re En este ejemplo, permitimos acceder a context.modules.re desde nuestros archivos Python Rapido. Registro Propiedades url Devuelve la URL del registro. id Devuelve el identificador de registro. M√©todos display(self, edit=False) Representa el registro utilizando su bloque asociado (si existe). get(self, name, default=None) Devuelve el valor del elemento (y el valor predeterminado es el default si el elemento no existe). items(self) Devuelve todos los elementos almacenados. reindex(self) Vuelva a indexar el registro. save(self, request=None, block=None, block_id=None, creation=False) Actualizar el registro con los elementos proporcionados e indexarlo. request puede ser una request actual HTTP o un diccionario. Si se menciona un bloque, se ejecutar√°n f√≥rmulas (on_save, elementos calculados, etc.). Si no hay bloque (y request es un diccionario), solo salvamos los valores de los elementos. set_block(self, block_id) Asigne un bloque al registro. El bloque se utilizar√° entonces para representar el registro o para guardarlo. Interfaz de diccionario de Python Los elementos del registro se pueden acceder y manipular como elementos del diccionario: myrecord['fruit'] = banana for key in myrecord: context.app.log(myrecord[key]) if 'vegetable' in myrecord: del myrecord['fruit'] Nota Cuando se establece un valor de elemento, el registro no se reindexa. Lista de control de acceso Nota La lista de control de acceso a la aplicaci√≥n puede ser obtenida mediante context.app.acl. M√©todos current_user(self) Devuelve el ID de usuario actual. Equivalente a: context.api.user.get_current().getUserName() current_user_groups(self) Devuelve los grupos al usuario actual al que pertenece. Equivalente a: api.user.get_current().getGroups() has_access_right(self, access_right) Devuelve True si el usuario actual tiene el derecho de acceso especificado (los derechos de acceso Rapido son reader, author, editor, manager) has_role(self, role_id) Devuelve True si el usuario actual tiene la funci√≥n especificada. roles(self) Devuelve los roles existentes."
      },
      {
        "id": 19,
        "autor": "python",
        "pagina": "python",
        "fecha": "00/00/2013",
        "titulo": "Requests: HTTP para Humanos",
        "link": "https://docs.python-requests.org/es/latest/",
        "contenido": "Requests es una librer√≠a para HTTP, ref:licenciada bajo Apache2 <apache2>, escrita en Python, para seres humanos. El m√≥dulo urllib2 que se encuentra en el est√°ndar de Python, ofrece la mayor√≠a de las funcionalidades necesarias para HTTP, pero su api est√° completamente rota. Fue construida para otra √©poca, - y una web diferente‚Äì. Requiere una gran cantidad de trabajo (incluso reimplementar m√©todos) para ejecutar las tareas m√°s sencillas. Las cosas no deber√≠an ser as√≠. No en Python. >>> r = requests.get('https://api.github.com/user', auth=('user', 'pass')) >>> r.status_code 200 >>> r.headers['content-type'] 'application/json; charset=utf8' >>> r.encoding 'utf-8' >>> r.text u'{type:User...' >>> r.json() {u'private_gists': 419, u'total_private_repos': 77, ...} Ver el mismo c√≥digo, sin Requests. Requests quita las complicaciones de trabajar HTTP/1.1 en Python - haciendo que la integraci√≥n con servicios web sea transparente. No hay necesidad de agregar queries a tus URLs manualmente, o convertir tu informaci√≥n a formularios para hacer una petici√≥n POST. La reutilizaci√≥n de keep-alive y conexi√≥n HTTP se hace autom√°ticamente, todo gracias a urllib3, el cual est√° integrado en Requests. Testimonios El gobierno de su Majestad, Amazon, Google, Twilio, Mozilla, Heroku, PayPal, NPR, Obama for America, Transifex, Native Instruments, The Washington Post, Twitter, SoundClound, Kippt, Readability y algunas organizaciones Federales de los Estados Unidos de Am√©rica utilizan Requests internamente. Ha sido descargado m√°s de 8,000,000 de veces desde PyPI. Armin Ronacher Requests es el ejemplo perfecto de qu√© tan hermosa pueder ser una API con el nivel correcto de abstracci√≥n. Matt DeBoard Voy a tatuarme el m√≥dulo de Python Requests de @kennethreitz, en mi cuerpo, de alguna forma. Todo completo. Daniel Greenfeld Elimin√© una librer√≠a de 1200 l√≠neas de c√≥digo enredado, con unas 10 l√≠neas de c√≥digo gracias a la librer√≠a Requests de @kennethreitz. Hoy ha sido un d√≠a GENIAL. Kenny Meyers Python HTTP: Cuando tengas dudas, o cuando no, usa Requests. Bonita, simple pyt√≥nica. Soporte Destacado Request est√° listo para al web de hoy URLs y Dominios internacionales Keep-Alive y Agrupamiento de conexiones (Connection Pooling) Sesiones con Cookies persistentes Verificaci√≥n SSL al estilo navegador Autenticaci√≥n B√°sica y Digest Elegantes Cookies en pares Llave/Valor Descompresi√≥n autom√°tica Cuerpos de respuestas Unicode Subida de archivos Multiparte Tiempos de espera de conexi√≥n Soporte para .netrc Python 2.6 ‚Äì 3.3 Seguridad para programaci√≥n en hilos (Thread-safety) Gu√≠a de Usuario Esta parte de la documentaci√≥n, la cual est√° compuesta de prosa en su mayor√≠a, empieza dando informaci√≥n general acerca de Requests, luego se centra en instrucciones paso por paso de c√≥mo utilizar la mayor√≠a de funcionalidades que brinda Requests. Introducci√≥n Filosof√≠a Licencia Apache2 Licencia de Requests Instalaci√≥n Distribute & Pip Cheeseshop Mirror Obtener el c√≥digo fuente Quickstart Realizar un petici√≥n Pasar par√°metros en URLs Contenido de respuesta Contenidos de respuesta binarios Contenido de respuesta JSON Contenido de respuesta en crudo Cabeceras personalizadas Peticiones POST m√°s complicadas Pasar un Archivo Multiparte en POST C√≥digos de estado de respuesta Cabeceras de respuesta Cookies Historial y Redireccionamiento Timeouts Errores y excepciones: Uso avanzado Objetos de sesi√≥n Objetos de petici√≥n y de respuesta Peticiones Preparadas Validaci√≥n de Certificados SSL Workflow del cuerpo del contenido Keep-Alive Subir por Streaming Peticiones Fragmentadas Chunk-Encoded Hooks de eventos Autenticaci√≥n personalizada Peticiones en streaming Proxies Conformidad Verbos HTTP Link Headers Transport Adapters Bloqueante o no-Bloqueante Timeouts Autenticaci√≥n Autenticaci√≥n B√°sica Autenticaci√≥n Digest Autenticaci√≥n OAuth 1 Otras formas de autenticaci√≥n Nuevas formas de autenticaci√≥n Gu√≠a para la comunidad Esta parte de la documentaci√≥n, la cual est√° compuesta de prosa en su mayor√≠a, detalla el ecosistema alrededor de Requests y su comunidad. Preguntas Frecuentes Integraciones Art√≠culos y Charlas Soporte Actualizaciones Software Updates Documentaci√≥n del API Si buscas informaci√≥n acerca de una funci√≥n, clase o m√©todo en espec√≠fico est√° parte de la documentaci√≥n es para ti. Interfaz para Desarrolladores Interfaz Principal Request Sessions Migrando a 1.x Migrando a 2.x Gu√≠a del contribuidor Si quieres contribuir con el proyecto, esta parte de la documentaci√≥n es para ti. Filosof√≠a del desarrollo C√≥mo ayudar Authors Logo Requests is an elegant and simple HTTP library for Python, built for human beings. You are currently looking at the documentation of the development release. Donate If you love Requests, consider supporting the author on Gittip: If your organization uses Requests, consider financial support: Requests Pro Feedback Feedback is greatly appreciated. If you have any questions, comments, random praise, or anonymous threats, shoot me an email. Useful Links Requests @ PyPI Requests @ GitHub Requests @ Flattr Issue Tracker B√∫squeda r√°pida Introduzca los t√©rminos de b√∫squeda o un nombre de m√≥dulo, clase o funci√≥n."
      },
      {
        "id": 20,
        "autor": "iKenshu",
        "pagina": "platzi",
        "fecha": "00/00/2018",
        "titulo": "C√≥mo crear tu contenedor de Docker para tu aplicaci√≥n en Django",
        "link": "https://platzi.com/blog/django-docker/",
        "contenido": "Docker resulta √∫til a la hora de crear un entorno de desarrollo ya que empaqueta la aplicaci√≥n en contenedores con lo necesario para que pueda funcionar sin importar el sistema operativo que corre. Incluso si no tienes dependencias o servicios, como Postgres instalados en tu m√°quina. Este tutorial quiero ense√±arte c√≥mo puedes tener tu primer contenedor con una aplicaci√≥n de Django. Ojo, estoy suponiendo que tienes Pipenv, Docker y Docker Compose. Dockerfile 7Ha8pRa.png Lo primero que debemos hacer es crear un proyecto con Django con su entorno virtual. mkdir PlatziDocker pipenv install --three django pipenv run django-admin startproject config . Listo. Si Pipenv no te resulta familiar, escrib√≠ un tutorial acerca de esta herramienta hace un par de semanas, te puede ahorra tiempo a la hora de usar entornos virtuales. Sigamos, ahora es necesario crear un Dockerfile. As√≠, sin extensi√≥n ni nada parecido. Nuestro Dockerfile se debe ver as√≠. FROM python:3.6 ENV PYTHONUNBUFFERED 1 COPY. /code/ WORKDIR/code/ RUNpip install pipenv RUNpipenv install --system EXPOSE8000 La primera l√≠nea FROM python:3.6 le dice a Docker que vamos a usar esa imagen como base para construir la nuestra. Es un contenedor de Ubuntu que tiene instalado la versi√≥n 3.6 de Python. La segunda l√≠nea ENV PYTHONUNBUFFERED 1 es una variable de entorno dici√©ndole a Docker que nos muestre el Standart Output(salida) y Standart Error(errores) en la terminal como estamos acostumbrados. De esta misma manera podemos declarar un ENV SECRET_KEY='__KEY__' para tener nuestra llave secreta alejada de nuestro archivo settings. La tercera l√≠nea COPY . /code/ es un comando para copiar todos los archivos y carpetas que se encuentran al mismo nivel (.) del Dockerfile a una carpeta llamada code. Luego en WORKDIR /code/ le decimos que nuestra √°rea de trabajo va a ser esa carpeta, todos los comandos que corramos, se ejecutar√°n dentro de la misma. Las siguientes dos l√≠neas RUN pip install pipenv y RUN pipenv install --system le dir√°n a docker que ejecute esos comandos, primero instalar√° Pipenv con pip para luego ejecutar la siguiente e instalar las dependencias de nuestro archivo Pipfile.lock y como le estamos pasando como argumento --system no se va a crear un entorno virtual, no lo necesitamos. Y la √∫ltima l√≠nea EXPOSE 8000, para correr bien runserver nuestro contenedor necesita acceder al puerto 8000. Listo, con eso ya tenemos nuestro Dockerfile. Ahora solo necesitamos hacer docker build . y vamos a ver una larga lista de cosas en la terminal, diferentes pasos. Todo deber√≠a ir bien. Docker Compose Ahora, Docker Compose nos ayuda a correr m√°s de un contenedor en nuestra aplicaci√≥n de Docker, por ejemplo si queremos tener una base de datos como Postgres o un servicio de cach√© como Redis o un servidor como Nginx. Para esto necesitamos un archivo en el mismo nivel que nuestro archivo Dockerfile y lo llamamos docker-compose.yml, este si tiene una extensi√≥n. Es un archivo YAML. Tendr√≠a esto: versi√≥nversion: '3' services: db: image: postgres:10.1 volumes: - postgres_data:/var/lib/postgresql/data web: build: . command: python /code/manage.py migrate --noinput command: python /code/manage.py runserver 0.0.0.0:8000 volumes: - .:/code ports: - 8000:8000 depends_on: - db environment: - DJANGO_SETTINGS_MODULE=config.settings - SECRET_KEY=${SECRET_KEY} volumes: postgres_data: Ahora vamos a explicarlo l√≠nea por l√≠nea. La primera version: '3' define la versi√≥n de Compose que queremos usar. Ahora en services vamos a definir, de manera identada, los servicios que queremos corran en diferentes contenedores. Con el primer servicio le decimos a docker que queremos la imagen de PostgreSQL. Ni siquiera necesitamos tenerlo instalado en nuestra sistema, Docker la descargar√° desde el Docker Hub con la versi√≥n que le especificamos. Y con volumes le decimos en que parte de nuestro contenedor queremos que se guarden los datos, en este caso /var/lib/postgresql/data. Si recuerdan, les dije que nuestra imagen de Python tiene como base una imagen de Ubuntu, eso hace que tenga varios subdirectorios. Un volumen permite que nuestros datos persistan sin importar el ciclo de vida del contenedor Por supuesto, para esto tenemos que decirle a Django que vamos a usar Postgres como base de datos, as√≠ que tenemos que deshacernos de ese sqlite3. Colocaremos esto: DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql_psycopg2', 'NAME': 'postgres', 'USER': 'postgres', 'PASSWORD': 'postgres', 'HOST': 'db', 'PORT': '5432', } } El siguiente servicio es el web y le decimos que construya build . nuestra imagen desde el directorio actual. Los siguientes dos commandos command, uno ejecutar√° las migraciones sin mostrar la salida en nuestra consola --no-input y el segundo levantar√° el servidor cuando corramos el contenedor. volumes al igual que con la base de datos, le dira a nuestro contenedor donde estar√° nuestro c√≥digo ./code. Justo despu√©s con ports mapeamos nuestro puerto 8000 al puerto 8000 del contenedor de Docker, haciendo que nuestro servidor sea accesible v√≠a localhost:8000 o 0.0.0.0:8000. Ahora depends_on le dice que nuestro servicio web necesita esperar por la base de datos, Compose primero levantar√° ese servicio antes de pasar a web. Con environment, puedes adivinar que son variables de entorno. Si es el caso de que estamos trabajando con diferentes archivos settings. Puedes colocar ah√≠, la variable DJANGO_SETTINGS_MODULE para especificar con cu√°l archivo quieres trabajar, puede ser local, production o test. La siguiente SECRET_KEY es una manera de llamar a una variable de entorno colocada en un archivo .env Ya que Pipenv carga autom√°ticamente las variables de un archivo .env podemos usar ese mismo archivo para mandarle la variable de entorno a nuestro contenedor con la l√≠nea SECRET_KEY=${SECRET_KEY} Y nuestras √∫ltimas dos l√≠neas, Compose tiene una regla donde tenemos que listar nuestros vol√∫menes en una llave volumes al mismo nivel de identaci√≥n que services o version Con el archivo guardado. Podemos ejecutar ahora docker-compose up tambi√©n nos mostrar√° cierta cantidad de informaci√≥n en la terminal pero al final deber√≠as tener un servidor corriendo en localhost:8000 o 0.0.0.0:8000 con la acostumbrada salida de Django. KLB7fnp.png Conclusi√≥n De esta manera, puedes olvidarte de los entornos virtuales y de tener algunos programas instalados en tu m√°quina local, puedes tener tu aplicaci√≥n empaquetada de esta manera y usarla en cualquier SO mientras tengas Docker instalado. Para saber m√°s acerca de Docker te invito a ver los dos grandes cursos que tiene Platzi, aprender√°s esto y m√°s."
      },
      {
        "id": 21,
        "autor": "tutorialpython",
        "pagina": "tutorialpython",
        "fecha": "00/00/0000",
        "titulo": "Bienvenido a Tutorial Python",
        "link": "https://www.tutorialpython.com/",
        "contenido": "Un tutorial de Python diferente Este curso de Python es diferente a los dem√°s. La mayor√≠a de los cursos, intentan explicar todas las caracter√≠sticas del lenguaje de principio a fin. Esto, adem√°s de ser arduo, hace que muchas personas se frustren ante semejante avalancha de informaci√≥n, y tiren la toalla antes de tiempo. En vez de pasar por todas y cada una de las posibilidades que ofrece Python, que sin lugar a dudas puede ser abrumador, en este curso aprender√°s lo b√°sico para La intenci√≥n de este curso de Python es que aprendas a programar lo m√°s r√°pido posible, por lo que en vez de desmenuzar todas las caracter√≠sticas, se centra en lo m√≠nimo indispensable para desenvolverse con soltura. Est√° dise√±ado para personas sin experiencia en programaci√≥n, aunque si ya sabes algo, aprender√°s a√∫n m√°s r√°pido El principio de Pareto Pareto enunci√≥ un principio en el que establec√≠a que en el mundo unos pocos (aproximadamente un 20 %) tienen una gran influencia sobre el mismo, frente a un 80 % que tienen una influencia mucho menor. Este principio es aplicable a multitud de situaciones, como por ejemplo sucede en el caso de los idiomas. Con las 300 palabras m√°s usadas del ingl√©s se pueden formar el 65% de todo el material escrito en ingl√©s. Pero, si se puede aplicar a los idiomas, ¬øpor qu√© no aplicarlo a los lenguajes de programaci√≥n? Al fin y al cabo, son tambi√©n ¬´idiomas¬ª. Aprendiendo el 20 % de los comandos m√°s usados en Python, podr√°s escribir completamente el 80% de los programas existente en Python. De este modo, conseguiremos aprender a programar en Python en el menor tiempo posible. Haz lo m√≠nimo indispensable, no lo m√°ximo posible Henk Kraaijenhof Este curso de Python est√° dise√±ado pensando en ti, por lo que te animo a participar activamente en tu curso, comentando y preguntando todas las dudas que te surjan."
      },
      {
        "id": 22,
        "autor": "IONOS",
        "pagina": "IONOS",
        "fecha": "23/06/2020",
        "titulo": "Aprender Python: principios b√°sicos y consejos",
        "link": "https://www.ionos.es/digitalguide/paginas-web/desarrollo-web/tutorial-de-python/",
        "contenido": "A inicios de los a√±os 90, el holand√©s Guido van Rossum desarroll√≥ el lenguaje de programaci√≥n Python que r√°pidamente se convirti√≥ en una herramienta popular para escribir scripts de grabaci√≥n de audio y para el desarrollo web. A pesar de que en la actualidad hay m√°s alternativas que nunca, el popular lenguaje apenas ha perdido adeptos en sus tres d√©cadas de existencia. Da igual si hablamos de aplicaciones web, sistemas embebidos (p. ej. ordenadores peque√±os en electrodom√©sticos) o software empresarial, los programadores de Python act√∫an en los sectores m√°s diversos y est√°n muy solicitados. Una de las razones para el √©xito tan prolongado de Python es su sencillez a la hora de iniciarse desde cero, ya que es mucho m√°s f√°cil aprender y aplicar Python que muchas de sus alternativas. Este tutorial de Python explica por qu√© es tan sencillo y cu√°l es la mejor forma de iniciarse en este lenguaje de programaci√≥n. √çndice Tutorial b√°sico de Python: ¬øpor qu√© se caracteriza el lenguaje de programaci√≥n? ¬øA qui√©n puede interesarle o serle √∫til Python? Aprender Python: lo que hace falta para empezar Python para principiantes: los mejores tutoriales de Python para programadores n√≥veles Aprender Python en la web: las mejores fuentes para usuarios experimentados La entrada perfecta a Python: los tutoriales como pilares Tutorial b√°sico de Python: ¬øpor qu√© se caracteriza el lenguaje de programaci√≥n? Python es uno de los lenguajes de programaci√≥n m√°s vers√°tiles, entre otras cosas, porque es compatible con varios paradigmas de programaci√≥n. As√≠, Python permite tanto una programaci√≥norientada a los objetos como una programaci√≥n funcional u orientada a los aspectos. Guido van Rossum estableci√≥ desde el principio el requisito de que el lenguaje permitiese desarrollar programas cuyos c√≥digos fuente se caracterizasen por una buena legibilidad. Y la base para conseguirlo es una sintaxis organizada, clara y f√°cil de aprender que apueste, entre otras cosas, por palabras clave en ingl√©s en lugar de s√≠mbolos cr√≠pticos y que no requiera demasiadas construcciones sint√°cticas. Nota Desde el a√±o 2001 la Python Software Foundation (PSF) ubicada en Delaware (EE. UU.) es la responsable de cuidar y seguir desarrollando el lenguaje Python. La organizaci√≥n sin √°nimo de lucro es la propietaria de la licencia libre de Python-Software-Foundation, entre otras (compatible con GNU GPL), con la que se ha licenciado el lenguaje de programaci√≥n. Pero el dise√±o claro y l√≥gico de Python no es la √∫nica raz√≥n por la que ofrece tantas ventajas a los principiantes que deseen programar en Python desde cero. El lenguaje tambi√©n cuenta con las siguientes ventajas: Python no necesita caracteres delimitadores (como las llaves que se usan en el lenguaje C), ya que la estructura de los bloques se define autom√°ticamente mediante la indentaci√≥n, que se usa para darle estructura. Si una l√≠nea solo cuenta con una instrucci√≥n, no se requiere un punto y coma al final de la l√≠nea. Python no necesita declaraciones de variables. Por norma general, los programas programados en Python son m√°s ligeros que las aplicaciones de los lenguajes tradicionales (como Java) de un rendimiento similar. Python tambi√©n ofrece una biblioteca est√°ndar muy amplia. Gracias a un int√©rprete port√°til, el lenguaje est√° disponible en diversas plataformas. El desarrollo continuo (en colaboraci√≥n con la gran comunidad del sector) est√° asegurado. ¬øA qui√©n puede interesarle o serle √∫til Python? Python tiene la etiqueta de f√°cil para principiantes, pero eso no significa que el lenguaje carezca de inter√©s para los programadores experimentados. El lenguaje din√°mico y universal goza de una gran popularidad y compite en diferentes sectores con otros lenguajes de programaci√≥n asentados. Su estructura simple no implica que los programas de Python ofrezcan menos opciones o un menor nivel de rendimiento o calidad. Por lo tanto, la decisi√≥n de aprender Python puede merecer la pena tanto a nivel privado como profesional. Python en el desarrollo web y empresarial: √∫til, pero no se requiere de inmediato Ya seas principiante o experto, debes plantearte previamente si el lenguaje es adecuado para los proyectos que tienes planeados. Si por ejemplo te interesa, sobre todo, el desarrollo web y trabajas en un sector correspondiente, va a ser dif√≠cil que consigas evitar est√°ndares como PHP y Perl. Pero incluso en estos casos no debes subestimar el potencial de Python como complemento de la gama, sobre todo en combinaci√≥n con el framework CMS Django se pueden crear aplicaciones web de gran calidad mediante Python. Lo mismo ocurre en el sector empresarial, est√° dominado por lenguajes como Java y C# pero no cierra las puertas de forma categ√≥rica a los lenguajes alternativos como Python. Sistemas embebidos, Machine Learning, Data Science: √°mbitos de aplicaci√≥n para Python Python tiene muy buena fama en el √°mbito de desarrollo de sistemas embebidos (en ingl√©s, embedded systems). Estos miniordenadores, que se ocupan de tareas sencillas como funciones de supervisi√≥n, control o regulaci√≥n, as√≠ como la distribuci√≥n de datos y se√±ales, son imprescindibles en pr√°cticamente todos los electrodom√©sticos: desde el router, pasando por la tele, hasta llegar a la nevera o la lavadora. Si tu actividad programadora va en esta direcci√≥n, es muy recomendable que aprendas Python, ya que tambi√©n se usa mucho como base de software para proyectos DIY con Raspberry PI. En la programaci√≥n de software con aprendizaje autom√°tico (Machine Learning) el Python tambi√©n juega un papel determinante: los casos de aplicaci√≥n sencillos, que no requieren Deep Learning (es decir, el procesamiento de informaci√≥n natural), se pueden resolver de manera muy sencilla con las tres bibliotecas Python scikit-learn, NumPy y pandas. En este √°mbito son muchos los que llevan tiempo apostando por este lenguaje. Adem√°s, el lenguaje de programaci√≥n Python es interesante para todos aquellos que se mueven en el amplio campo de la ciencia de datos (Data Science) y que desean programar software para c√°lculos y pron√≥sticos matem√°ticos o estad√≠sticos m√°s all√° del Machine Learning. Aprender Python: lo que hace falta para empezar Para aprender Python necesitas dos cosas: un editor de c√≥digos y la versi√≥n Python adecuada para tu sistema operativo. En el caso del editor, basta con un editor de textos normal y corriente como el Notepad integrado en Windows (en espa√±ol tambi√©n solo ‚ÄúBloc de notas‚Äù). No obstante, para que el trabajo con Python sea lo m√°s c√≥modo posible, deber√≠as usar un editor como Notepad++ con caracter√≠sticas adicionales para destacar la sintaxis o de autocompletado. Puedes consultar una lista de soluciones recomendables para Windows, macOS, Linux o Android en el siguiente art√≠culo sobre los mejores editores de c√≥digos. Puedes conseguir la edici√≥n adecuada en el centro de descargas de la p√°gina web oficial de Python. All√≠ encontrar√°s archivos de instalaci√≥n ejecutables, archivos fuente en paquetes o Docker-Images para los distintos sistemas operativos, Windows, macOS y Linux, as√≠ como iOS, Solaris e IBM i (antiguo OS/400). Si est√°s empezando a aprender Python, te recomendamos descargar la versi√≥n m√°s actualizada. Tambi√©n puedes usar distintas versiones m√°s antiguas, hasta llegar a los archivos binarios de Python 1.1. Python para principiantes: los mejores tutoriales de Python para programadores n√≥veles Si la palabra programaci√≥n no te dec√≠a absolutamente nada hasta hace poco, es muy probable que la amplia documentaci√≥n en l√≠nea de Python, que describe los conceptos b√°sicos del lenguaje, tampoco te sirva de mucho. Por lo general, este tipo de manuales, que suelen estar disponibles √∫nicamente en ingl√©s, van dirigidos a usuarios avanzados que ya tienen experiencia en el uso de otros lenguajes de programaci√≥n. Pero tambi√©n existen otras soluciones que facilitan el aprendizaje de Python de forma notable a los principiantes. En los siguientes p√°rrafos te presentamos tres de las plataformas para principiantes de Python m√°s interesantes y √∫tiles. La web del programador ‚ÄúHow to think like a Computer Scientist‚Äù (en espa√±ol ‚ÄúAprenda a pensar como un programador‚Äù) es el t√≠tulo del tutorial de Python de Allen B. Downey, Jeffrey Elkner y Chris Meyers, traducido al espa√±ol por Miguel √Ångel Vilella, √Ångel Arnal, Iv√°n Juanes, Litza Amurrio, Efrain Andia y C√©sar Ballardini y est√° disponible en Academia. Las instrucciones de ayuda para introducirse en el mundo de la programaci√≥n mediante el ejemplo concreto de Python no solo van dirigidas a los m√°s j√≥venes, sino, en general, a todos aquellos que quieran dar sus primeros pasos en este mundo. Tutorial de Python de pildorasinformaticas (YouTube) La plataforma de v√≠deo YouTube es una fuente excelente para consultar informaci√≥n de las t√©cnicas de programaci√≥n m√°s diversas y tambi√©n incluye una oferta bastante amplia de material did√°ctico de Python. Como principiante, te puede interesar, por ejemplo, la lista de reproducci√≥n ‚ÄúCurso Python desde cero‚Äù del usuario pildorasinformaticas. La serie de tutoriales se dirige especialmente a aquellos interesados que tengan poca experiencia y parte desde cero, como su nombre indica. Cuenta con un total de 78 lecciones. Para proteger tu privacidad, el v√≠deo se cargar√° tras hacer clic. Tutorial de Python de Programaci√≥n ATS (YouTube) Otro canal de YouTube muy recomendable para todos aquellos que deseen aprender Python es el de Programaci√≥n ATS. Al margen de los numerosos tutoriales de desarrollo web, pseudoc√≥digos o diagramas de flujo, tambi√©n encontrar√°s una secci√≥n espec√≠fica para la programaci√≥n Python. Para los m√°s inexpertos la lista de reproducci√≥n ‚ÄúProgramaci√≥n en Python‚Äù es muy √∫til: con un total de 38 v√≠deos did√°cticos se explican los conceptos b√°sicos del Python o se ofrecen v√≠deos para aprender alguno de los otros lenguajes de programaci√≥n comunes. Para proteger tu privacidad, el v√≠deo se cargar√° tras hacer clic. Aprender Python en la web: las mejores fuentes para usuarios experimentados Gracias a su enorme oferta, el canal de YouTube de pildorasinformaticas, mencionado anteriormente, tambi√©n es √∫til para usuarios que ya cuentan con una base asentada de conocimientos de programaci√≥n y que busquen contenidos un poco m√°s profundos. De hecho, al margen de los tutoriales de Python para principiantes, tambi√©n puedes acceder a listas de reproducci√≥n que te explican la programaci√≥n de Python en detalle y tambi√©n la programaci√≥n con otros lenguajes. Puedes encontrar, entre otros, v√≠deos did√°cticos de programaci√≥n API, el framework Django y otros lenguajes de programaci√≥n y sus frameworks, todos ellos disponibles en el espacio del canal ‚ÄúListas de reproducci√≥n creadas‚Äù. En la siguiente lista puedes consultar m√°s fuentes interesantes para programadores experimentados que quieran profundizar un poco m√°s en el lenguaje de programaci√≥n Python: Tutorial de Python para usuarios experimentados de dandrusco (YouTube): otro canal de YouTube que trata el lenguaje Python, pero a nivel m√°s experimentado. En la lista de reproducci√≥n ‚ÄúCurso Python avanzado‚Äù tambi√©n se ofrece contenido did√°ctico de Python para programadores con experiencia. Se tratan, sobre todo, las expresiones regulares y la documentaci√≥n. Aprendeprogramando.es: en aprendeprogramando.es hay material did√°ctico para principiantes y usuarios experimentados. Puedes acceder a las distintas lecciones, presentadas de forma muy atractiva con capturas de pantalla y ejemplos de c√≥digos, c√≥modamente a trav√©s del men√∫ lateral izquierdo de la p√°gina. Wiki de Python en espa√±ol: si buscas un sitio que re√∫na toda la informaci√≥n sobre Python, te puede interesar el Wiki de Python en espa√±ol una p√°gina que resume gu√≠as, libros y documentaci√≥n diversas. Si te quedan dudas sobre Python, es posible que encuentres las soluciones aqu√≠. Nota Obviamente tambi√©n puedes estudiar los principios b√°sicos de Python en clases presenciales de facultades y universidades o en distintas formaciones online. No obstante, en este caso se trata de programas de pago y van dirigidos especialmente a aquellos que desean aprender el lenguaje Python en el marco de una formaci√≥n laboral. La entrada perfecta a Python: los tutoriales como pilares Al igual que en otros muchos campos, para aprender Python, el secreto tambi√©n est√° en la pr√°ctica. Como en todos los dem√°s lenguajes de programaci√≥n, la aplicaci√≥n pr√°ctica es la base del aprendizaje, indistintamente de si eres totalmente nuevo en el mundo de la programaci√≥n o si el Python ya es tu segundo lenguaje o incluso, simplemente uno m√°s. Por lo tanto, t√≥mate los tutoriales web de Python mencionados como ayuda, pero no te olvides de ponerte manos a la obra. Lo mejor es que pruebes inmediatamente todo lo que vayas aprendiendo en un proyecto de ejemplo. Ponte a prueba cada poco para asegurarte de que has entendido las bases del Python y familiar√≠zate con los contenidos de manera que pudieses explic√°rselos a terceros si fuera necesario."
      },
      {
        "id": 23,
        "autor": "mattwojo, volprod",
        "pagina": "Microsoft Build",
        "fecha": "05/05/2021",
        "titulo": "Introducci√≥n al uso de Python en Windows para principiantes",
        "link": "https://docs.microsoft.com/es-es/windows/python/beginners",
        "contenido": "En este art√≠culo Configurar el entorno de desarrollo Instalar Python Instalar Visual Studio Code Instalar GIT (opcional) Tutorial de Hola mundo para algunos aspectos b√°sicos de Python Tutorial Hola mundo para usar Python con VS Code Crear un juego sencillo con Pygame Recursos para el aprendizaje continuo A continuaci√≥n, te ofrecemos una gu√≠a paso a paso para aquellos usuarios principiantes interesados en aprender Python con Windows 10. Configurar el entorno de desarrollo Si eres un usuario principiante y no est√°s familiarizado con Python, te recomendamos instalar Python desde Microsoft Store. La instalaci√≥n a trav√©s de Microsoft Store utiliza el int√©rprete de Python3 b√°sico, pero controla el establecimiento de la configuraci√≥n del valor PATH para el usuario actual (lo que evita la necesidad de contar con acceso de administrador) y, adem√°s, proporciona actualizaciones autom√°ticas. Resulta especialmente √∫til si te encuentras en un entorno educativo o en un departamento de una organizaci√≥n que restringe los permisos o el acceso administrativo en la m√°quina. Si usas Python en Windows para el desarrollo web, te recomendamos que definas una configuraci√≥n diferente para el entorno de desarrollo. En lugar de realizar la instalaci√≥n directamente en Windows, te recomendamos que instales y uses Python a trav√©s del Subsistema de Windows para Linux. Para obtener ayuda, consulta lo siguiente: Introducci√≥n al uso de Python para el desarrollo web en Windows. Si est√°s interesado en automatizar las tareas comunes en el sistema operativo, consulta nuestra gu√≠a: Introducci√≥n al uso de Python en Windows para el scripting y la automatizaci√≥n. En algunos escenarios avanzados (por ejemplo, si necesitas acceder a los archivos instalados de Python o modificarlos, hacer copias en archivos binarios o usar archivos DLL de Python directamente), es posible que quieras considerar la posibilidad de descargar una versi√≥n espec√≠fica de Python directamente desde python.org o una alternativa, como Anaconda, Jython, PyPy, WinPython, IronPython, etc. Solo te lo recomendamos si eres un programador de Python m√°s avanzado y tienes un motivo espec√≠fico para elegir una implementaci√≥n alternativa. Instalar Python Para instalar Python con Microsoft Store: Ve al men√∫ Inicio (icono de Windows de la esquina inferior izquierda), escribe Microsoft Store y selecciona el v√≠nculo para abrir Store. Una vez que lo hayas abierto, selecciona Buscar en el men√∫ superior derecho y escribe Python. Seleccione la versi√≥n de Python que quiera usar en los resultados de la opci√≥n Aplicaciones. Se recomienda usar la m√°s reciente, a menos que tenga una raz√≥n para no hacerlo (por ejemplo, alinearse con la versi√≥n que se us√≥ en un proyecto existente en el que planea trabajar). Una vez que haya determinado qu√© versi√≥n quiere instalar, seleccione Obtener. Una vez que Python haya completado el proceso de descarga e instalaci√≥n, abre Windows PowerShell mediante el men√∫ Inicio (icono de Windows de la esquina inferior izquierda). Cuando PowerShell est√© abierto, escribe Python --version para confirmar que Python3 est√° instalado en la m√°quina. La instalaci√≥n de Microsoft Store de Python incluye PIP, el administrador de paquetes est√°ndar. PIP te permite instalar y administrar paquetes adicionales que no forman parte de la biblioteca est√°ndar de Python. Para confirmar que tambi√©n dispones de PIP para instalar y administrar paquetes, escribe pip --version. Instalar Visual Studio Code Al usar VS Code como editor de texto/entorno de desarrollo integrado (IDE), puedes aprovechar IntelliSense (una ayuda de finalizaci√≥n de c√≥digo), el detector de errores (permite evitar que se produzcan errores en el c√≥digo), el soporte t√©cnico de depuraci√≥n (ayuda a buscar errores en el c√≥digo despu√©s de ejecutarlo), los fragmentos de c√≥digo (plantillas para peque√±os bloques de c√≥digo reutilizables) y las pruebas unitarias (para probar la interfaz del c√≥digo con distintos tipos de entrada). VS Code tambi√©n contiene un terminal integrado que te permite abrir una l√≠nea de comandos de Python con el s√≠mbolo del sistema de Windows, PowerShell o cualquier otra herramienta que prefieras, y establece un flujo de trabajo sin interrupciones entre el editor de c√≥digo y la l√≠nea de comandos. Para instalar VS Code, descarga VS Code para Windows: https://code.visualstudio.com. Una vez instalado VS Code, tambi√©n debes instalar la extensi√≥n de Python. Para instalar la extensi√≥n de Python, puedes seleccionar el v√≠nculo para VS Code de Marketplace o abrir VS Code y buscar Python en el men√∫ de extensiones (Control + May√∫s + X). Python es un lenguaje interpretado y, para ejecutar el c√≥digo de Python, debes indicar a VS Code el int√©rprete que debe usar. Se recomienda usar la versi√≥n m√°s reciente de Python, a menos que tenga una raz√≥n espec√≠fica para elegir alguna diferente. Despu√©s de instalar la extensi√≥n de Python, selecciona un int√©rprete de Python 3. Para ello, abre la paleta de comandos (Control + May√∫s + P) y empieza a escribir el comando Python: Select Interpreter para buscarlo y, luego, selecci√≥nalo. Tambi√©n puedes usar la opci√≥n Select Python Environment (Seleccionar entorno de Python) en la barra de estado inferior si est√° disponible (es posible que ya se muestre un int√©rprete seleccionado). El comando presenta una lista de los int√©rpretes disponibles que VS Code puede buscar autom√°ticamente, incluidos los entornos virtuales. Si no ves el int√©rprete que quieres, consulta Configuraci√≥n de los entornos de Python. Selecci√≥n del int√©rprete de Python en VS Code Para abrir el terminal en VS Code, selecciona Ver > Terminal, o bien usa el acceso directo Control + ` (mediante el car√°cter de tilde aguda). El terminal predeterminado es PowerShell. En el terminal de VS Code, simplemente escribe el comando python para abrir Python. Para probar el int√©rprete de Python, escribe print(Hello World). Python devolver√° la instrucci√≥n Hola mundo. L√≠nea de comandos de Python en VS Code Instalar GIT (opcional) Si planeas colaborar con otras personas en el c√≥digo de Python u hospedar el proyecto en un sitio de c√≥digo abierto (como GitHub), VS Code admite el control de versiones con GIT. La pesta√±a Control de c√≥digo fuente de VS Code realiza un seguimiento de todos los cambios y tiene comandos GIT comunes (agregar, confirmar, enviar cambios e incorporar cambios) integrados directamente en la interfaz de usuario. Primero, debes instalar GIT para alimentar el panel de control de c√≥digo fuente. Descarga e instala GIT para Windows desde el sitio web git-scm. Se incluye un asistente para instalaci√≥n que te formular√° una serie de preguntas sobre la configuraci√≥n de la instalaci√≥n de GIT. Te recomendamos que uses todas las opciones de configuraci√≥n predeterminadas, a menos que tengas un motivo concreto para cambiar algo. Si nunca has trabajado con GIT, las gu√≠as de GitHub pueden resultarte de ayuda para empezar. Tutorial de Hola mundo para algunos aspectos b√°sicos de Python Python, seg√∫n su creador Guido van Rossum, es un lenguaje de programaci√≥n de alto nivel y su filosof√≠a de dise√±o b√°sico trata sobre la legibilidad del c√≥digo y una sintaxis que permite a los programadores expresar conceptos en unas pocas l√≠neas de c√≥digo. Python es un lenguaje interpretado. A diferencia de los lenguajes compilados, en los que el c√≥digo que escribes debe traducirse en c√≥digo m√°quina para que lo ejecute el procesador del equipo, el c√≥digo de Python se pasa a un int√©rprete y se ejecuta directamente. Solo tienes que escribir el c√≥digo y ejecutarlo. Prob√©moslo. Con la l√≠nea de comandos de PowerShell abierta, escribe python para ejecutar el int√©rprete de Python 3. (Algunas instrucciones prefieren usar el comando py o python3 y tambi√©n deber√≠an funcionar). Sabr√°s que se ha ejecutado correctamente porque se mostrar√° un aviso con tres s√≠mbolos de mayor que (>>>). Hay varios m√©todos integrados que permiten realizar modificaciones en las cadenas de Python. Crea una variable con variable = 'Hello World!'. Presiona Entrar para que se muestre una nueva l√≠nea. Imprime la variable con print(variable). Se mostrar√° el texto Hello World!. Averigua la longitud (el n√∫mero de caracteres que se usan) de la variable de cadena con len(variable). Se mostrar√° que se usan 12 caracteres. (Ten en cuenta que el espacio en blanco se cuenta como un car√°cter en la longitud total). Convierte la variable de cadena en letras may√∫sculas: variable.upper(). Convierte la variable de cadena en letras min√∫sculas: variable.lower(). Cuenta el n√∫mero de veces que se usa la letra l en la variable de cadena: variable.count(l). Busca un car√°cter espec√≠fico en la variable de cadena. En este caso, buscaremos el signo de exclamaci√≥n con variable.find(!). Se mostrar√° que el signo de exclamaci√≥n se encuentra en el car√°cter und√©cimo de la cadena. Reemplaza el signo de exclamaci√≥n por un signo de interrogaci√≥n: variable.replace(!, ?). Para salir de Python, puedes escribir exit() o quit(), o seleccionar Control-Z. Captura de pantalla de PowerShell de este tutorial Esperamos que te hayas divertido usando algunos de los m√©todos de modificaci√≥n de cadenas integrados de Python. Ahora intenta crear un archivo de programa de Python y ejecutarlo con VS Code. Tutorial Hola mundo para usar Python con VS Code El equipo de VS Code ha elaborado el excelente tutorial Introducci√≥n a Python en el que se explica c√≥mo crear un programa Hola mundo con Python, ejecutar el archivo de programa, configurar y ejecutar el depurador e instalar paquetes como matplotlib y NumPy para crear un trazado gr√°fico dentro de un entorno virtual. Abre PowerShell y crea una carpeta vac√≠a denominada hello, navega a esta carpeta y √°brela en VS Code: Consola Copiar mkdir hello cd hello code . Una vez que se abra VS Code y se muestre la nueva carpeta Hello en la ventana Explorador del lado izquierdo, abre una ventana de l√≠nea de comandos en el panel inferior de VS Code. Para ello, presiona Control + ` (mediante el car√°cter de tilde aguda) o selecciona Ver > Terminal. Al iniciar VS Code en una carpeta, esa carpeta se convierte en tu √°rea de trabajo. VS Code almacena la configuraci√≥n espec√≠fica de esa √°rea de trabajo en. vscode/settings.json, que es independiente de la configuraci√≥n de usuario que se almacena globalmente. Contin√∫a con el tutorial en la documentaci√≥n de VS Code: Creaci√≥n de un archivo de c√≥digo fuente de Hola mundo de Python. Crear un juego sencillo con Pygame Pygame ejecutando un juego de ejemplo Pygame es un paquete de Python conocido para escribir juegos, que anima a los alumnos a aprender a programar a la vez que crean algo divertido. Pygame muestra los gr√°ficos en una nueva ventana, por lo que no funcionar√° en el enfoque solo de l√≠nea de comandos de WSL. Sin embargo, si instalaste Python mediante Microsoft Store tal y como se detalla en este tutorial, funcionar√° correctamente. Una vez hayas instalado Python, instala Pygame desde la l√≠nea de comandos (o el terminal de VS Code). Para ello, escribe python -m pip install -U pygame --user. Prueba la instalaci√≥n mediante la ejecuci√≥n de un juego de ejemplo: python -m pygame.examples.aliens. Si todo va bien, el juego abrir√° una ventana. Cierra la ventana cuando termines de jugar. A continuaci√≥n, te indicamos c√≥mo puedes empezar a escribir tu propio juego. Abre PowerShell (o el s√≠mbolo del sistema de Windows) y crea una carpeta vac√≠a denominada bounce. Navega hasta esta carpeta y crea un archivo denominado bounce.py. Abre la carpeta en VS Code. PowerShell Copiar mkdir bounce cd bounce new-item bounce.py code . Con VS Code, escribe el c√≥digo siguiente de Python (o c√≥pialo y p√©galo): Python Copiar import sys, pygame pygame.init() size = width, height = 640, 480 dx = 1 dy = 1 x= 163 y = 120 black = (0,0,0) white = (255,255,255) screen = pygame.display.set_mode(size) while 1: for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() x += dx y += dy if x < 0 or x > width: dx = -dx if y < 0 or y > height: dy = -dy screen.fill(black) pygame.draw.circle(screen, white, (x,y), 8) pygame.display.flip() Gu√°rdalo como bounce.py. En el terminal de PowerShell, escribe python bounce.py para ejecutarlo. Pygame ejecutando la pr√≥xima gran idea Intenta ajustar algunos de los n√∫meros para ver el efecto que tienen en la bola que bota. Obt√©n m√°s informaci√≥n sobre la escritura de juegos con Pygame en pygame.org. Recursos para el aprendizaje continuo Te recomendamos los siguientes recursos que te permitir√°n seguir obteniendo informaci√≥n sobre el desarrollo de Python en Windows. Cursos en l√≠nea para aprender Python Introducci√≥n a Python en Microsoft Learn: prueba la plataforma de Microsoft Learn interactiva y gana puntos de experiencia por completar este m√≥dulo, en el que se describen los aspectos b√°sicos sobre c√≥mo escribir c√≥digo de Python b√°sico, declarar variables y trabajar con la entrada y salida de la consola. Con el entorno de espacio aislado interactivo, resulta un buen punto de partida para aquellas personas que a√∫n no cuentan con su propio entorno de desarrollo de Python configurado. Python en Pluralsight: 8 cursos, 29 horas: la ruta de aprendizaje de Python en Pluralsight ofrece cursos en l√≠nea que abarcan una gran variedad de temas relacionados con Python, incluida una herramienta para medir tus aptitudes y averiguar tus debilidades. Tutoriales de LearnPython.org: empieza a aprender el lenguaje Python sin necesidad de instalar o configurar nada con estos tutoriales interactivos y gratuitos de Python de los usuarios de DataCamp. Tutoriales de Python.org: introduce al lector los conceptos b√°sicos y las caracter√≠sticas del lenguaje y el sistema de Python de una manera informativa. Aprendizaje de Python en Lynda.com: introducci√≥n b√°sica a Python. Trabajar con Python en VS Code Edici√≥n de Python en VS Code: obtenga m√°s informaci√≥n sobre c√≥mo aprovechar las ventajas de la compatibilidad de Autocompletar e IntelliSense de VS Code con Python, incluida la forma de personalizar sus comportamientos, o simplemente desact√≠velas. Detecci√≥n de errores de Python: la detecci√≥n de errores es el proceso de ejecuci√≥n de un programa que analizar√° el c√≥digo para detectar posibles errores. Obt√©n informaci√≥n sobre las distintas formas de compatibilidad de la detecci√≥n de errores que VS Code proporciona para Python y c√≥mo configurarlas. Depuraci√≥n de Python: la depuraci√≥n es el proceso de identificar y quitar errores de un programa. En este art√≠culo se describe c√≥mo inicializar y configurar la depuraci√≥n de Python con VS Code, establecer y validar puntos de interrupci√≥n, adjuntar un script local, realizar la depuraci√≥n para diferentes tipos de aplicaciones o en un equipo remoto, y algunos procedimientos de soluci√≥n de problemas b√°sicos. Pruebas unitarias de Python: incluye un poco de informaci√≥n sobre qu√© significa el t√©rmino pruebas unitarias, un tutorial de ejemplo, la habilitaci√≥n de un marco de pruebas, la creaci√≥n y ejecuci√≥n de pruebas, la depuraci√≥n de pruebas y la configuraci√≥n de pruebas."
      },
      {
        "id": 24,
        "autor": "Tr4nsduc7or",
        "pagina": "robologs",
        "fecha": "22/09/2020",
        "titulo": "Tutorial: punteros a funciones en C",
        "link": "https://robologs.net/2019/05/31/tutorial-punteros-a-funciones-en-c/",
        "contenido": "Saludos, humano. Como sabr√°s, cu√°ndo programamos en C disponemos de punteros a varios tipos de datos (char*, int*, float*, double*) que nos permiten hacer muchas cosas: reservar memoria din√°mica, crear referencias y alias, etc. Lo que quiz√° no sab√≠as es que tambi√©n podemos crear punteros que apunten a funciones como si fueran cualquier otro tipo de datos. En los ejemplos de este tutorial ver√°s c√≥mo declarar punteros a funciones y como utilizarlos de varias formas distintas. 1. Puntero a funci√≥n He aqu√≠ un ejemplo b√°sico. Tenemos una funci√≥n que escribe un texto por pantalla, y la llamamos a trav√©s de un puntero: 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 #include <stdio.h> //Funcion de ejemplo void funcion() { printf(Se ha entrado en la funcion\n); } int main() { //Creamos el puntero a la funcion void (*puntero_funcion)() = &funcion; //Llamamos la funcion a traves del puntero puntero_funcion(); return 0; } Como puedes ver, no tiene demasiada diferencia con el resto de punteros. Vamos a complicarlo un poco m√°s‚Ä¶ 2. Funci√≥n con par√°metros Si la funci√≥n a la que quieres apuntar recibe alg√∫n par√°metro, hay que indicar sus tipos al declarar el puntero. F√≠jate en este ejemplo: la funci√≥n recibe dos enteros y muestra sus valores. N√≥tese que cu√°ndo se declara el puntero se escriben los tipos de los argumentos entre par√©ntesis. 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> //Funcion que recibe dos enteros void funcion(int valor1, int valor2) { printf(Valor 1 = %d\n, valor1); printf(Valor 2 = %d\n, valor2); } int main() { //Se crea el puntero a la funcion. Hay que indicar el tipo de los parametros que recibe. void (*puntero_funcion)(int, int) = &funcion; //Se llama la funcion a traves del puntero puntero_funcion(2, 5); return 0; } 3. Funci√≥n como par√°metro a otra funci√≥n Las funciones tambi√©n pueden pasarse como par√°metros a otras funciones. En este c√≥digo se define una funci√≥n principal que recibe como par√°metros dos n√∫meros a, b y un puntero a una funci√≥n entera. La funci√≥n principal pasa a y b como par√°metros a la funci√≥n del puntero y escribe el valor que devuelve por pantalla. 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> int sumar(int a, int b) { return a+b; } int restar(int a, int b) { return a-b; } void funcion_principal(int a, int b, int (*funcion)(int, int)) { int resultado = funcion(a,b); printf(El resultado es %d\n, resultado); } int main() { //Se definen dos valores enteros cualesquiera int num1 = 5; int num2 = 4; //Se invoca la funcion principal, pasandole la funcion de SUMA printf(\nSuma:\n); funcion_principal(num1, num2, sumar); //Se invoca la funcion principal, pasandole la funcion de RESTA printf(Resta:\n); funcion_principal(num1, num2, restar); return 0; } Con este ejemplo puede verse que los punteros a funciones sirven para eliminar la redundancia en el c√≥digo: al pasar la funci√≥n como par√°metro nos ahorramos tener que escribir variantes de la funci√≥n principal para realizar cada una de las operaciones. 4. Funci√≥n qsort() Un ejemplo pr√°ctico del caso anterior es la funci√≥n qsort(). Esta funci√≥n propia de C permite ordenar cualquier vector utilizando el algoritmo Quick Sort. La signatura de la funci√≥n qsort() en C es: 1 void qsort (void* array, size_t nelementos, size_t bytes, int (*comparador)(const void*,const void*)); d√≥nde void* array es un puntero al vector que se quiere ordenar, nelementos es el n√∫mero de elementos dentro del vector y bytes es el tama√±o que ocupan. El par√°metro m√°s importante es el √∫ltimo: el puntero a la funci√≥n comparador. Para ordenar un vector hace falta un criterio para comparar dos elementos y decidir cu√°l de ellos va primero. Por ejemplo, en el caso de que los elementos del vector sean enteros, basta con comparar sus valores. Pero ordenar alfab√©ticamente un vector de Strings (u otro tipo de estructura m√°s compleja) puede requerir de funciones m√°s elaboradas. La funci√≥n qsort() de C est√° pensada para poder ordenar un vector de cualquier tipo, y para ello el programador debe pasarle como par√°metro la funci√≥n para comparar elementos. Puedes programar esta funci√≥n comparadora a tu gusto, pero debe recibir como argumentos dos punteros void (correspondientes a dos elementos del vector) y devolver 1 o -1 seg√∫n cu√°l de los dos elementos vaya primero. 1 2 3 4 int comparador(const void * a, const void * b) { //Tu codigo aqui dentro. Tiene que comparar a,b y devolver -1 √≥ 1. } Esta funci√≥n tendr√°s que pasarla como par√°metro a qsort(). Admito que esto puede parecer complicado a primera vista, pero en realidad es muy sencillo. Veamos un ejemplo: sup√≥n que tenemos un struct correspondiente a la informaci√≥n de un envase de un cierto producto. Este struct tiene definidos tres campos: un identificador, la capacidad (en mililitros) del envase y su precio. Si quisi√©ramos ordenar un vector de envases con la funci√≥n qsort(), habr√≠a que definir una funci√≥n para comparar dos envases. En este ejemplo esto se hace de dos formas distintas: por identificador y seg√∫n el precio por unidad de volumen. 001 002 003 004 005 006 007 008 009 010 011 012 013 014 015 016 017 018 019 020 021 022 023 024 025 026 027 028 029 030 031 032 033 034 035 036 037 038 039 040 041 042 043 044 045 046 047 048 049 050 051 052 053 054 055 056 057 058 059 060 061 062 063 064 065 066 067 068 069 070 071 072 073 074 075 076 077 078 079 080 081 082 083 084 085 086 087 088 089 090 091 092 093 094 095 096 097 098 099 100 101 #include <stdio.h> struct Envase { int id; //Identificador int volumen; //Volumen en mililitros float precio; //Precio en euros }; /* Metodo de ordenacion I: ordenar por identificador*/ int ordenarID (const void * a, const void * b) { /*Se hace un casting para convertir los punteros void a punteros de Envases y se guarda su identificador*/ int id_a = ((struct Envase*)a)->id; int id_b = ((struct Envase*)b)->id; //Se comparan los dos identificadores if(id_a > id_b) return 1; else return -1; } /* Metodo de ordenacion II: ordenar por precio/unidad de volumen */ int ordenar_precio_volumen (const void * a, const void * b) { /*Se hace un casting para convertir los punteros void a punteros de Envases y se guarda su volumen y precio*/ float precio_a = ((struct Envase*)a)->precio; int volumen_a = ((struct Envase*)a)->volumen; float precio_b = ((struct Envase*)b)->precio; int volumen_b = ((struct Envase*)b)->volumen; //Se calcula precio/volumen float val_a = precio_a/volumen_a; float val_b = precio_b/volumen_b; //Se comparan los dos valores if(val_a > val_b) return 1; else return -1; } int main() { int dimension = 4; //Dimension del vector struct Envase array[4]; //Vector de envases array[0].id = 5; array[0].volumen = 600; array[0].precio = 12; array[1].id = 6; array[1].volumen = 550; array[1].precio = 7.99; array[2].id = 1; array[2].volumen = 400; array[2].precio = 25; array[3].id = 3; array[3].volumen = 600; array[3].precio = 9.5; //Ordenar el vector por ID qsort((void*)array, dimension, sizeof(struct Envase), ordenarID); //Mostrar el vector por ID. El output es {1 3 5 6} printf(\nOrdenado por ID: {); for(int i = 0; i < dimension; i++) { printf(%d , array[i].id); } printf(}\n); //Ordenar el vector por precio/volumen qsort((void*)array, dimension, sizeof(struct Envase), ordenar_precio_volumen); //Mostrar el vector por precio/volumen. El output ahora es {6 3 5 1} printf(\nOrdenado por precio/vol: {); for(int i = 0; i < dimension; i++) { printf(%d , array[i].id); } printf(}\n\n); return 0; } Como es l√≥gico, puedes hacer funciones comparadoras tan complicadas como quieras. Este es uno de los puntos fuertes del lenguaje C, su enorme flexibilidad. 5. Funciones como Arrays C tambi√©n permite declarar arrays de punteros a funciones. Este c√≥digo define tres funciones para hacer comprobaciones sobre un n√∫mero (si es par, si es positivo y si es primo) y las realiza sobre un entero introducido por el usuario. La gracia es que en vez de llamar las tres funciones individualmente, se guardan en un vector y √©ste se recorre con un bucle for. 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include <stdio.h> /*Comprobar si el numero es PAR*/ void funcion1(int a) { if(a % 2 == 0) printf(El numero es par\n); else printf(El numero es impar\n); } /*Comprobar si el numero es POSITIVO/NEGATIVO*/ void funcion2(int a) { if(a > 0) printf(El numero es positivo\n); else if(a < 0) printf(El numero es negativo\n); else printf(El numero es cero\n); } /*Comprobar si el numero es PRIMO*/ void funcion3(int a) { if(a <= 1) { printf(El numero NO es primo\n); return; } for(int i = 2; i <= (a)/2; i++) { if ( a%i == 0 ) { printf(El numero NO es primo\n); return; } } printf(El numero es primo\n); } int main() { //Vector de funciones void (*array[]) (int) = {funcion1, funcion2, funcion3}; //Se pide al usuario que entre un numero int val; printf(\nIntroduce un numero entero: ); scanf(%d, &val); //Se recorre el vector para llamar las funciones for(int i = 0; i < 3; i++) { array[i] (val); } return 0; } Programaci√≥n, Tutoriales C++, programaci√≥n, transductor"
      },
      {
        "id": 25,
        "autor": "Programo Ergo Sum",
        "pagina": "Programo Ergo Sum",
        "fecha": "00/00/2021",
        "titulo": "Curso de iniciaci√≥n a Python en Raspberry Pi",
        "link": "https://www.programoergosum.com/cursos-online/raspberry-pi/244-iniciacion-a-python-en-raspberry-pi/introduccion",
        "contenido": "Aprender a programar - Asociaci√≥n Programo Ergo Sum | Todos los cursos Scratch Arduino Raspberry PI Impresi√≥n 3D - Maker AppInventor Realidad aumentada Rob√≥tica educativa Curso de iniciaci√≥n a Python en Raspberry Pi Lecciones del curso 1: Introducci√≥n 2: ¬øQu√© es Python? 3: Hola Mundo 4: Operadores 5: Tipos de datos 6: Variables 7: Entrada de datos 8: Salida de datos 9: Condiciones 10: Bucles 11: Funciones 12: Ejercicios 13: Materiales Lecci√≥n 1: Introducci√≥n ¬øQu√© voy a aprender en este curso? En este curso aprender√°s a programar en Python utilizando la Raspberry Pi para iniciarte en el mundo de la programaci√≥n. Este es un tutorial de nivel iniciaci√≥n para aquellos usuarios que todav√≠a no han programado ning√∫n lenguaje de programaci√≥n en modo texto. En el tutorial se va a explicar la versi√≥n de Python 3 (IDLE) que viene instalada por defecto en el sistema operativo de Raspbian para Raspberry Pi. No obstante, tambi√©n podr√°s acceder al tutorial en caso de instalar Python en tu sistema operativo Windows, Linux o MAC. Curso de programaci√≥n en Python con Raspberry Pi Curso de programaci√≥n en Python con Raspberry Pi Tambi√©n puedes acceder a la plataforma de AprendeProgramando para aprender a programar en Python a trav√©s de lecciones de teor√≠a y pr√°ctica. ¬øQu√© materiales voy a necesitar? Antes de continuar con las lecciones del curso aseg√∫rate que dispones de todos los componentes y configuraciones que se van a necesitar: Raspberry Pi con el sistema operativo Raspbian. Sobre nosotros Asociaci√≥n Programo Ergo Sum Colaboradores / Donaciones Contacta con nosotros Proyectos educativos Programo Ergo Sum Aprende Programando Redes sociales Twitter  Youtube  Instagram  Facebook  LinkedIn  Github Esta obra est√° bajo una licencia de Creative Commons Reconocimiento-CompartirIgual 4.0 Internacional. 2021 - Asociaci√≥n Programo Ergo Sum"
      },
      {
        "id": 26,
        "autor": "Hektor Profe",
        "pagina": "hektorprofe",
        "fecha": "17/03/2021",
        "titulo": "Apuntes del curso de Python",
        "link": "https://docs.hektorprofe.net/python/",
        "contenido": "Saltar a contenido Hektor Profe Buscar en mis apuntes  Ofertas cursos Udemy Apuntes de Python √çndice del archivo Introducci√≥n informal Operadores y expresiones Controlando el flujo Colecciones de datos Entradas y salidas Programaci√≥n de funciones Errores y excepciones Orientaci√≥n a objetos (POO) Herencia en la POO M√©todos de las colecciones M√≥dulos y paquetes Manejo de ficheros Interfaces gr√°ficas Tkinter Bases de datos SQLite Funcionalidades avanzadas Documentaci√≥n y pruebas Distribuci√≥n Apuntes del curso de Python Estos apuntes son un material de apoyo para los alumnos de mi curso de Python en Udemy publicados bajo una Licencia CC BY 4.0. Si decides utilizarlos o compartirlos aseg√∫rate de cumplir las normas de atribuci√≥n. Los ex√°menes, ejercicios de codificaci√≥n y soluciones son de acceso exclusivo para alumnos. Pod√©is navegar por ellos utilizando el men√∫ lateral. √öltima edici√≥n: 17 de Marzo de 2021 AnteriorConfigurar Ubuntu Server SiguientePresentaci√≥n 2015 - 2021 ¬© H√©ctor Costa Guzm√°n (Licencia CC BY 4.0) Esta web utiliza cookies para mejorar la experiencia y proporcionar funcionalidades adicionales. DetallesAceptar cookies"
      },
      {
        "id": 27,
        "autor": "GABRIELA GONZ√ÅLEZ",
        "pagina": "genbeta",
        "fecha": "29/03/2021",
        "titulo": "20 cursos y tutoriales de Python para aprender a programar en el lenguaje m√°s amado por los desarrolladores",
        "link": "https://www.genbeta.com/desarrollo/20-cursos-tutoriales-python-para-aprender-a-programar-lenguaje-amado-desarrolladores-1",
        "contenido": "Python no es solo uno de los lenguajes de programaci√≥n m√°s amados por los programadores, sino que tambi√©n suele ser uno de los m√°s usados, y m√°s estudiados. Recientemente, Python ha sobrepasado a Java como lenguaje de programaci√≥n m√°s popular en el √≠ndice TIOBE, algo que no hab√≠a ocurrido en 20 a√±os. Gracias a su versatilidad es usado en muchos casos, y se ha convertido en uno de los caballos de batalla en el mundo de la inteligencia artificial y el machine learning, campo con cada vez m√°s demanda en el mercado de trabajo. Que lo diga Tesla, empresa en la que buscan programadores que dominen Python para trabajar en sus coches. Si quieres aprender Python desde cero, o eres programador y buscas ampliar tus conocimientos, o si ya manejas el lenguaje y quieres aprender m√°s cosas, aqu√≠ tienes una lista con cursos y tutoriales para todos los niveles. Este informe de Hired nos muestra cu√°les son los puestos de trabajo para desarrolladores con m√°s demanda y que mejor pagan EN GENBETA Este informe de Hired nos muestra cu√°les son los puestos de trabajo para desarrolladores con m√°s demanda y que mejor pagan Cursos online gratuitos en espa√±ol Hitesh Choudhary D9zow2rem8u Unsplash Introducci√≥n a la programaci√≥n con Python: un curso de la Universidad Austral que no requiere conocimientos previos. Ofrece acceso a los conceptos b√°sicos de programaci√≥n utilizando Python en su versi√≥n 3.0. Una vez que completes este curso, podr√°s construir peque√±os programas que te ayuden en tu trabajo y estar√°s preparado para tomar cursos de programaci√≥n m√°s avanzados. Programaci√≥n para todos (empezando con Python): uno de los cursos m√°s populares sobre Python en el mundo, es un curso de la Universidad de Michigan que fue traducido recientemente a espa√±ol. Es una introducci√≥n sin prerrequisitos donde aprender√°s sobre as variables, la ejecuci√≥n condicional, la ejecuci√≥n repetida y c√≥mo usamos las funciones. Programaci√≥n Orientada a Objetos con Python: un curso de la Universidad Austral en el que aprender√°s sobre el dise√±o de programas con objetos y para diagramar UML. Introducci√≥n a la programaci√≥n en Python I: un curso de la Pontificia Universidad Cat√≥lica de Chile que te introducir√° en el mundo de la programaci√≥n con el lenguaje Python. Aprender√°s desde el tratamiento b√°sico de variables hasta la programaci√≥n de algoritmos para construir tus propios juegos. Adem√°s, te familiarizar√°s con los conceptos fundamentales para el desarrollo de algoritmos y su programaci√≥n. Machine Learning (aprendizaje autom√°tico) con Python: una introducci√≥n pr√°ctica: un curso de IBM en el que aprender√°s los conceptos b√°sicos acerca del aprendizaje autom√°tico con Python. Aprender√°s sobre el aprendizaje supervisado y no supervisado, veras como se relaciona el modelado estad√≠stico con el aprendizaje autom√°tico y har√°s una comparaci√≥n de cada uno. 'Aprende X en Y minutos': esta web ense√±a lo b√°sico de muchos lenguajes de programaci√≥n en el menor tiempo posible EN GENBETA 'Aprende X en Y minutos': esta web ense√±a lo b√°sico de muchos lenguajes de programaci√≥n en el menor tiempo posible Cursos online gratuitos en ingl√©s Python Cursos Python for Beginners un curso de Microsoft publicado como 44 v√≠deos en YouTube. Este cubre todo lo b√°sico que necesitas saber sobre Python para darte las bases necesarias para que luego vayas a aprender m√°s por tu cuenta. Crash Course on Python: un curso de Google para aprender los b√°sico para escribir programas simples en Python usando las estructuras m√°s comunes. Using Python to Interact with the Operating System: un curso de Google en el que aprender√°s a manipular archivos y procesos en el sistema operativo de tu ordenador. Learn Python 2 un curso b√°sico en Codecademy para aprender los fundamentos de Python 2. Introduction to Python: Absolute Beginner: un curso de Microsoft para aprender los conceptos b√°sicos de Python, en el que practicar√°s mucho creando proyectos usando Jupyter Notebooks en Azure. An Introduction to Interactive Programming in Python: un curso de RICE en el que cualquier estudiante sin conocimientos de computaci√≥n podr√° aprender lo b√°sico para construir una aplicaci√≥n interactiva usando Python. Python Programming Essentials: un curso de RICE en el que aprender√°s los elementos b√°sicos de la programaci√≥n y c√≥mo crear programas usando Python. Introduction to Computer Science and Programming Using Python: un curso del MIT en el que aprender√°s a solucionar problemas anal√≠ticos del mundo real utilizando Python 3.5. Python for Data Science: un curso de UC San Diego en el que aprender√°s a usar poderosas herramientas Python open source como Pandas, Git, y Malplotlib para manipular, analizar y visualizar bases de datos complejas. Analyzing Data with Python: un curso de IBM en el que aprender√°s c√≥mo analizar datos en Python usando matrices multidimensionales en numpy, a manipular DataFrames en pandas, a usar la librer√≠a SciPy, y a ejecutar machine learning con scikit-learn! 15.000 desarrolladores responden en Twitter cu√°l es su lenguaje de programaci√≥n favorito, cu√°l odian y cu√°l recomiendan EN GENBETA 15.000 desarrolladores responden en Twitter cu√°l es su lenguaje de programaci√≥n favorito, cu√°l odian y cu√°l recomiendan Tutoriales Aprender Python NSA Python Training Document: el manual de entrenamiento para programadores de la NSA, publicado recientemente. Es b√°sicamente una introducci√≥n al lenguaje, en el que los estudiantes usan la versi√≥n 4.4.0 de la distribuci√≥n Ananconda3 de Python, y en la que se abordan las razones de su popularidad. Aprende Python construyendo 5 juegos: un mini curso de 7 horas de v√≠deo en el que aprender√°s a construir tus propias versiones de cl√°sicos como Pong, Snake, Connect Four, y Tetris utilizando Python. Learn Python for Free un tutorial de 48 partes en el que aprender√°s Python a trav√©s de una mezcla entre peque√±os tutoriales y retos de c√≥digo interactivo. Learn Natural Language Processing with Python and TensorFlow 2.0: una introducci√≥n pr√°ctica al procesamiento natural del lenguaje (NLP) en el que aprender√°s todo lo que puedes hacer con Python y TensorFlow 2.0. How to Build a Toy Markdown Editor with Python and Tkinter: aprende a crear un peque√±o editor de texto MarkDown usando Python y Tkinter."
      },
      {
        "id": 28,
        "autor": "Eugenia Bahit",
        "pagina": "uniwebsidad",
        "fecha": "00/00/2021",
        "titulo": "Python para principiantes",
        "link": "https://uniwebsidad.com/libros/python",
        "contenido": "INICIO LIBROS TUTORIALES EVENTOS FORO BUSCAR Python para principiantes Escrito por Eugenia Bahit Cap√≠tulo 1. Preparaci√≥n del entorno de desarrollo 1.1. Introducci√≥n al Sistema Operativo GNU/Linux 1.2. Instalando Python 1.3. Instalaci√≥n de un Shell interactivo mejorado 1.4. Ninja-IDE 1.5. Instalaci√≥n de Bazaar Cap√≠tulo 2. Estructura y elementos del lenguaje 2.1. Elementos del Lenguaje 2.2. Estructuras de Control de Flujo Cap√≠tulo 3. M√≥dulos, paquetes y namespaces 3.1. Creando m√≥dulos empaquetados Cap√≠tulo 4. Funciones definidas por el usuario 4.1. Definiendo funciones 4.2. Llamadas de retorno 4.3. Llamadas recursivas 4.4. Sobre la finalidad de las funciones Cap√≠tulo 5. Introducci√≥n a la orientaci√≥n a objetos 5.1. Pensar en objetos 5.2. Programaci√≥n Orientada a Objetos Cap√≠tulo 6. M√©todos principales del objeto String 6.1. M√©todos de formato 6.2. M√©todos de B√∫squeda 6.3. M√©todos de Validaci√≥n 6.4. M√©todos de Sustituci√≥n 6.5. M√©todos de uni√≥n y divisi√≥n 6.6. Ejercicios Cap√≠tulo 7. M√©todos principales del objeto list 7.1. M√©todos de agregado 7.2. M√©todos de eliminaci√≥n 7.3. M√©todos de orden 7.4. M√©todos de b√∫squeda 7.5. Anexo sobre listas y tuplas Cap√≠tulo 8. M√©todos principales del objeto dict 8.2. M√©todos de agregado y creaci√≥n 8.3. M√©todos de retorno Cap√≠tulo 9. El objeto File: trabajando con archivos 9.1. Sobre el objeto File 9.2. M√©todos del Objeto File 9.3. Propiedades del objeto file 9.4. Cerrando archivos de forma autom√°tica Cap√≠tulo 10. Un paseo por los m√≥dulos de la librer√≠a est√°ndar 10.1. M√≥dulos de sistema 10.2. M√≥dulos para el programador 10.3. M√≥dulos que resuelven necesidades funcionales 10.4. M√≥dulos e Internet Cap√≠tulo 11. Introducci√≥n a MySQL y el lenguaje SQL 11.1. Acerca de MySQL 11.2. Sobre el lenguaje SQL 11.3. Optimizaci√≥n de bases de Datos 11.4. Bases de datos relacionales Cap√≠tulo 12. Bases de datos en Python con MySQL 12.2. Conectarse a la base de datos y ejecutar consultas Cap√≠tulo 13. Corriendo aplicaciones Python en la web 13.1. Introducci√≥n 13.2. Python bajo Apache 13.3. Utilizando environ para manejar peticiones del usuario Cap√≠tulo 14. Enviando e-mails con formato HTML desde Python 14.2. Env√≠o de e-mail desde Python ¬© 2006-2021 uniwebsidad Contacto Aviso legal Recursos sobre: css dise√±o drupal JavaScript PHP programaci√≥n Python ruby Symfony 5.280 d√≠as online Este sitio utiliza cookies propias y de terceros. Sigue navegando para aceptar nuestra Pol√≠tica de Cookies o ajusta tu configuraci√≥n. ACEPTAR"
      },
      {
        "id": 29,
        "autor": "Python",
        "pagina": "Python",
        "fecha": "27/05/2021",
        "titulo": "Tutorial de Python",
        "link": "https://docs.python.org/es/3/tutorial/index.html",
        "contenido": "√≠ndicem√≥dulos |siguiente |anterior | Python ¬ª Spanish 3.9.5 Documentation ¬ª B√∫squeda r√°pida | Tutorial de Python Python es un lenguaje de programaci√≥n potente y f√°cil de aprender. Tiene estructuras de datos de alto nivel eficientes y un simple pero efectivo sistema de programaci√≥n orientado a objetos. La elegante sintaxis de Python y su tipado din√°mico, junto a su naturaleza interpretada lo convierten en un lenguaje ideal para scripting y desarrollo r√°pido de aplicaciones en muchas √°reas, para la mayor√≠a de plataformas. El int√©rprete de Python y la extensiva librer√≠a est√°ndar se encuentran disponibles libremente en c√≥digo fuente y forma binaria para la mayor√≠a de plataformas desde la Web de Python, https://www.python.org/, y se pueden distribuir libremente. El mismo sitio contiene distribuciones y direcciones a muchos m√≥dulos de Python de terceras partes, programas, herramientas y adicionalmente documentaci√≥n. El int√©rprete de Python es f√°cilmente extensible con funciones y tipos de datos implementados en C o C++ (o otros lenguajes que permitan ser llamados desde C). Python tambi√©n es apropiado como un lenguaje para extender aplicaciones modificables. Este tutorial introduce al lector informalmente a los conceptos b√°sicos y las funcionalidades del lenguaje de programaci√≥n Python y a su sistema. Ayuda a tener un interprete de Python accesible para una experiencia pr√°ctica, todos los ejemplos son auto-contenidos, permitiendo utilizar el tutorial sin conexi√≥n. Para una descripci√≥n de los objetos est√°ndar y de los m√≥dulos, ver La Biblioteca Est√°ndar de Python. Referencia del Lenguaje Python d√≥nde se ofrece una definici√≥n m√°s formal del lenguaje. Para escribir extensiones en C o C++, leer Ampliaci√≥n e incrustaci√≥n del int√©rprete de Python y Manual de referencia de la API en C de Python. Existen diversos libros que cubren Python en detalle. Este tutorial no pretende ser comprensible y cubrir todas las funcionalidades, o incluso ni las m√°s utilizadas. Pretende introducir muchas de las funcionalidades m√°s notables y dar una idea del estilo y el tipo de lenguaje. Despu√©s de leerlo podr√°s leer y escribir m√≥dulos y programas en Python y estar√°s listo para aprender sobre varias librer√≠as y m√≥dulos descritos en La Biblioteca Est√°ndar de Python. Es interesante leer el Glosario. 1. Abriendo el apetito 2. Usando el int√©rprete de Python 2.1. Invocando al int√©rprete 2.1.1. Paso de argumentos 2.1.2. Modo interactivo 2.2. El int√©rprete y su entorno 2.2.1. Codificaci√≥n del c√≥digo fuente 3. Una introducci√≥n informal a Python 3.1. Usando Python como una calculadora 3.1.1. N√∫meros 3.1.2. Cadenas de caracteres 3.1.3. Listas 3.2. Primeros pasos hacia la programaci√≥n 4. M√°s herramientas para control de flujo 4.1. La sentencia if 4.2. La sentencia for 4.3. La funci√≥n range() 4.4. Las sentencias break, continue, y else en bucles 4.5. La sentencia pass 4.6. Definiendo funciones 4.7. M√°s sobre definici√≥n de funciones 4.7.1. Argumentos con valores por omisi√≥n 4.7.2. Palabras claves como argumentos 4.7.3. Par√°metros especiales 4.7.3.1. Argumentos posicionales o de palabras claves 4.7.3.2. Par√°metros √∫nicamente posicionales 4.7.3.3. Argumentos √∫nicamente de palabras clave 4.7.3.4. Ejemplos de Funciones 4.7.3.5. Resumen 4.7.4. Listas de argumentos arbitrarios 4.7.5. Desempaquetando una lista de argumentos 4.7.6. Expresiones lambda 4.7.7. Cadenas de texto de documentaci√≥n 4.7.8. Anotaci√≥n de funciones 4.8. Intermezzo: Estilo de codificaci√≥n 5. Estructuras de datos 5.1. M√°s sobre listas 5.1.1. Usando listas como pilas 5.1.2. Usando listas como colas 5.1.3. Comprensi√≥n de listas 5.1.4. Listas por comprensi√≥n anidadas 5.2. La instrucci√≥n del 5.3. Tuplas y secuencias 5.4. Conjuntos 5.5. Diccionarios 5.6. T√©cnicas de iteraci√≥n 5.7. M√°s acerca de condiciones 5.8. Comparando secuencias y otros tipos 6. M√≥dulos 6.1. M√°s sobre los m√≥dulos 6.1.1. Ejecutando m√≥dulos como scripts 6.1.2. El camino de b√∫squeda de los m√≥dulos 6.1.3. Archivos ¬´compilados¬ª de Python 6.2. M√≥dulos est√°ndar 6.3. La funci√≥n dir() 6.4. Paquetes 6.4.1. Importando * desde un paquete 6.4.2. Referencias internas en paquetes 6.4.3. Paquetes en m√∫ltiples directorios 7. Entrada y salida 7.1. Formateo elegante de la salida 7.1.1. Formatear cadenas literales 7.1.2. El m√©todo format() de cadenas 7.1.3. Formateo manual de cadenas 7.1.4. Viejo formateo de cadenas 7.2. Leyendo y escribiendo archivos 7.2.1. M√©todos de los objetos Archivo 7.2.2. Guardar datos estructurados con json 8. Errores y excepciones 8.1. Errores de sintaxis 8.2. Excepciones 8.3. Gestionando excepciones 8.4. Lanzando excepciones 8.5. Exception Chaining 8.6. Excepciones definidas por el usuario 8.7. Definiendo acciones de limpieza 8.8. Acciones predefinidas de limpieza 9. Clases 9.1. Unas palabras sobre nombres y objetos 9.2. √Åmbitos y espacios de nombres en Python 9.2.1. Ejemplo de √°mbitos y espacios de nombre 9.3. Un primer vistazo a las clases 9.3.1. Sintaxis de definici√≥n de clases 9.3.2. Objetos clase 9.3.3. Objetos instancia 9.3.4. Objetos m√©todo 9.3.5. Variables de clase y de instancia 9.4. Algunas observaciones 9.5. Herencia 9.5.1. Herencia m√∫ltiple 9.6. Variables privadas 9.7. Cambalache 9.8. Iteradores 9.9. Generadores 9.10. Expresiones generadoras 10. Peque√±o paseo por la Biblioteca Est√°ndar 10.1. Interfaz al sistema operativo 10.2. Comodines de archivos 10.3. Argumentos de linea de √≥rdenes 10.4. Redirigir la salida de error y finalizaci√≥n del programa 10.5. Coincidencia en patrones de cadenas 10.6. Matem√°tica 10.7. Acceso a Internet 10.8. Fechas y tiempos 10.9. Compresi√≥n de datos 10.10. Medici√≥n de rendimiento 10.11. Control de calidad 10.12. Las pilas incluidas 11. Peque√±o paseo por la Biblioteca Est√°ndar‚Äî Parte II 11.1. Formato de salida 11.2. Plantillas 11.3. Trabajar con registros estructurados conteniendo datos binarios 11.4. Multi-hilos 11.5. Registrando 11.6. Referencias d√©biles 11.7. Herramientas para trabajar con listas 11.8. Aritm√©tica de punto flotante decimal 12. Entornos Virtuales y Paquetes 12.1. Introducci√≥n 12.2. Creando Entornos Virtuales 12.3. Manejando paquetes con pip 13. ¬øY ahora qu√©? 14. Edici√≥n de entrada interactiva y sustituci√≥n de historial 14.1. Autocompletado con tab e historial de edici√≥n 14.2. Alternativas al int√©rprete interactivo 15. Aritm√©tica de Punto Flotante: Problemas y Limitaciones 15.1. Error de Representaci√≥n 16. Ap√©ndice 16.1. Modo interactivo 16.1.1. Manejo de errores 16.1.2. Programas ejecutables de Python 16.1.3. El archivo de inicio interactivo 16.1.4. Los m√≥dulos de customizaci√≥n Tema anterior Changelog Pr√≥ximo tema 1. Abriendo el apetito Esta p√°gina Reporta un Bug Mostrar el c√≥digo ¬´ √≠ndicem√≥dulos |siguiente |anterior | Python ¬ª 3.9.5 Documentation ¬ª B√∫squeda r√°pida | ¬© Copyright 2001-2021, Python Software Foundation. La Python Software Foundation es una organizaci√≥n sin fines de lucro. Por favor, haga una donaci√≥n. Actualizado por √∫ltima vez en may. 27, 2021. Found a bug? Created using Sphinx 2.4.4."
      },
      {
        "id": 30,
        "autor": "Sergio Luj√°n",
        "pagina": "Rinc√≥n de la tecnolog√≠a",
        "fecha": "00/00/0000",
        "titulo": "¬°QUIERO APRENDER PYTHON DESDE CERO!",
        "link": "https://rincondelatecnologia.com/quiero-aprender-python-desde-cero/",
        "contenido": "Y es que Python est√° de moda. Se requiere en puestos de trabajo como programador o para programar nuestra querida Raspberry Pi. Su sencillez y su legibilidad hacen de este lenguaje de programaci√≥n de alto nivel uno de los m√°s buscados. Pero aprender Python desde cero es un tost√≥n, como lo es aprender cualquier lenguaje. Libros, tutoriales y un sinf√≠n de recetas que acaban aburriendo al alumno por no enfrentarse a casos pr√°cticos. Pero hay otras formas. La primera puede ser un curso, en este caso un MOOC, d√≥nde observas un v√≠deo explicativo de la unidad y luego se ofrecen ejercicios y test para observar el progreso realizado. Un ejemplo de curso es este y no es una mala opci√≥n para quien le gustan los formalismos y las clases de siempre pero desde el sof√° de su casa. Otra forma de aprendizaje puede ser la opci√≥n ofrecida por codeacademy, d√≥nde cada unidad trata sobre alguna parte del lenguaje y se aprende programando. Al usuario se le ofrece una explicaci√≥n para alcanzar un objetivo (como podr√≠a ser definir una variable) y se le pide que lo haga. No se pasa de nivel hasta que no se supera el reto, pero siempre se puede conseguir una serie de ayudas. Es una manera de aprender programando y teniendo a alguien que supervisa cada una de nuestras l√≠neas. Por √∫ltimo, la forma de aprendizaje m√°s desenfadada es la ofertada por codecombat. Codecombat ofrece la opci√≥n de aprender Python desde cero de una forma distendida: jugando. El juego se basa en la historia de un caballero que debe recoger gemas y luchar contra trolls. De aqu√≠, aparecen una serie de √≥rdenes que el caballero debe realizar para poder salir del laberinto. De esta manera se presentan la definici√≥n de variables para poder realizar acciones como encontrar objetos. tambi√©n se presentan los bucles para poder salir de laberintos que siguen un patr√≥n. Se presentan decisiones que se deben de tomar con la sentencia condicional if/else o incluso propiedades de ciertas variables. Adem√°s, llega un punto del juego donde √©ste se vuelve aleatorio, de manera que el c√≥digo debe de ser lo suficientemente robusto como para salir airoso de las distintas pruebas a las que se somete al pobre protagonista. Por si esto fuera poco, el programa est√° compartido como software libre, para que pueda ser mejorado por cualquiera y publicado en github para su revisi√≥n. Y t√∫, ¬øte animas a aprender Python desde cero?"
      },
      {
        "id": 31,
        "autor": "Tr4nsduc7or",
        "pagina": "robologs",
        "fecha": "22/09/2020",
        "titulo": "Tutorial: punteros a funciones en C",
        "link": "https://robologs.net/2019/05/31/tutorial-punteros-a-funciones-en-c/",
        "contenido": "Saludos, humano. Como sabr√°s, cu√°ndo programamos en C disponemos de punteros a varios tipos de datos (char*, int*, float*, double*) que nos permiten hacer muchas cosas: reservar memoria din√°mica, crear referencias y alias, etc. Lo que quiz√° no sab√≠as es que tambi√©n podemos crear punteros que apunten a funciones como si fueran cualquier otro tipo de datos. En los ejemplos de este tutorial ver√°s c√≥mo declarar punteros a funciones y como utilizarlos de varias formas distintas. 1. Puntero a funci√≥n He aqu√≠ un ejemplo b√°sico. Tenemos una funci√≥n que escribe un texto por pantalla, y la llamamos a trav√©s de un puntero: 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 #include <stdio.h> //Funcion de ejemplo void funcion() { printf(Se ha entrado en la funcion\n); } int main() { //Creamos el puntero a la funcion void (*puntero_funcion)() = &funcion; //Llamamos la funcion a traves del puntero puntero_funcion(); return 0; } Como puedes ver, no tiene demasiada diferencia con el resto de punteros. Vamos a complicarlo un poco m√°s‚Ä¶ 2. Funci√≥n con par√°metros Si la funci√≥n a la que quieres apuntar recibe alg√∫n par√°metro, hay que indicar sus tipos al declarar el puntero. F√≠jate en este ejemplo: la funci√≥n recibe dos enteros y muestra sus valores. N√≥tese que cu√°ndo se declara el puntero se escriben los tipos de los argumentos entre par√©ntesis. 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> //Funcion que recibe dos enteros void funcion(int valor1, int valor2) { printf(Valor 1 = %d\n, valor1); printf(Valor 2 = %d\n, valor2); } int main() { //Se crea el puntero a la funcion. Hay que indicar el tipo de los parametros que recibe. void (*puntero_funcion)(int, int) = &funcion; //Se llama la funcion a traves del puntero puntero_funcion(2, 5); return 0; } 3. Funci√≥n como par√°metro a otra funci√≥n Las funciones tambi√©n pueden pasarse como par√°metros a otras funciones. En este c√≥digo se define una funci√≥n principal que recibe como par√°metros dos n√∫meros a, b y un puntero a una funci√≥n entera. La funci√≥n principal pasa a y b como par√°metros a la funci√≥n del puntero y escribe el valor que devuelve por pantalla. 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> int sumar(int a, int b) { return a+b; } int restar(int a, int b) { return a-b; } void funcion_principal(int a, int b, int (*funcion)(int, int)) { int resultado = funcion(a,b); printf(El resultado es %d\n, resultado); } int main() { //Se definen dos valores enteros cualesquiera int num1 = 5; int num2 = 4; //Se invoca la funcion principal, pasandole la funcion de SUMA printf(\nSuma:\n); funcion_principal(num1, num2, sumar); //Se invoca la funcion principal, pasandole la funcion de RESTA printf(Resta:\n); funcion_principal(num1, num2, restar); return 0; } Con este ejemplo puede verse que los punteros a funciones sirven para eliminar la redundancia en el c√≥digo: al pasar la funci√≥n como par√°metro nos ahorramos tener que escribir variantes de la funci√≥n principal para realizar cada una de las operaciones. 4. Funci√≥n qsort() Un ejemplo pr√°ctico del caso anterior es la funci√≥n qsort(). Esta funci√≥n propia de C permite ordenar cualquier vector utilizando el algoritmo Quick Sort. La signatura de la funci√≥n qsort() en C es: 1 void qsort (void* array, size_t nelementos, size_t bytes, int (*comparador)(const void*,const void*)); d√≥nde void* array es un puntero al vector que se quiere ordenar, nelementos es el n√∫mero de elementos dentro del vector y bytes es el tama√±o que ocupan. El par√°metro m√°s importante es el √∫ltimo: el puntero a la funci√≥n comparador. Para ordenar un vector hace falta un criterio para comparar dos elementos y decidir cu√°l de ellos va primero. Por ejemplo, en el caso de que los elementos del vector sean enteros, basta con comparar sus valores. Pero ordenar alfab√©ticamente un vector de Strings (u otro tipo de estructura m√°s compleja) puede requerir de funciones m√°s elaboradas. La funci√≥n qsort() de C est√° pensada para poder ordenar un vector de cualquier tipo, y para ello el programador debe pasarle como par√°metro la funci√≥n para comparar elementos. Puedes programar esta funci√≥n comparadora a tu gusto, pero debe recibir como argumentos dos punteros void (correspondientes a dos elementos del vector) y devolver 1 o -1 seg√∫n cu√°l de los dos elementos vaya primero. 1 2 3 4 int comparador(const void * a, const void * b) { //Tu codigo aqui dentro. Tiene que comparar a,b y devolver -1 √≥ 1. } Esta funci√≥n tendr√°s que pasarla como par√°metro a qsort(). Admito que esto puede parecer complicado a primera vista, pero en realidad es muy sencillo. Veamos un ejemplo: sup√≥n que tenemos un struct correspondiente a la informaci√≥n de un envase de un cierto producto. Este struct tiene definidos tres campos: un identificador, la capacidad (en mililitros) del envase y su precio. Si quisi√©ramos ordenar un vector de envases con la funci√≥n qsort(), habr√≠a que definir una funci√≥n para comparar dos envases. En este ejemplo esto se hace de dos formas distintas: por identificador y seg√∫n el precio por unidad de volumen. 001 002 003 004 005 006 007 008 009 010 011 012 013 014 015 016 017 018 019 020 021 022 023 024 025 026 027 028 029 030 031 032 033 034 035 036 037 038 039 040 041 042 043 044 045 046 047 048 049 050 051 052 053 054 055 056 057 058 059 060 061 062 063 064 065 066 067 068 069 070 071 072 073 074 075 076 077 078 079 080 081 082 083 084 085 086 087 088 089 090 091 092 093 094 095 096 097 098 099 100 101 #include <stdio.h> struct Envase { int id; //Identificador int volumen; //Volumen en mililitros float precio; //Precio en euros }; /* Metodo de ordenacion I: ordenar por identificador*/ int ordenarID (const void * a, const void * b) { /*Se hace un casting para convertir los punteros void a punteros de Envases y se guarda su identificador*/ int id_a = ((struct Envase*)a)->id; int id_b = ((struct Envase*)b)->id; //Se comparan los dos identificadores if(id_a > id_b) return 1; else return -1; } /* Metodo de ordenacion II: ordenar por precio/unidad de volumen */ int ordenar_precio_volumen (const void * a, const void * b) { /*Se hace un casting para convertir los punteros void a punteros de Envases y se guarda su volumen y precio*/ float precio_a = ((struct Envase*)a)->precio; int volumen_a = ((struct Envase*)a)->volumen; float precio_b = ((struct Envase*)b)->precio; int volumen_b = ((struct Envase*)b)->volumen; //Se calcula precio/volumen float val_a = precio_a/volumen_a; float val_b = precio_b/volumen_b; //Se comparan los dos valores if(val_a > val_b) return 1; else return -1; } int main() { int dimension = 4; //Dimension del vector struct Envase array[4]; //Vector de envases array[0].id = 5; array[0].volumen = 600; array[0].precio = 12; array[1].id = 6; array[1].volumen = 550; array[1].precio = 7.99; array[2].id = 1; array[2].volumen = 400; array[2].precio = 25; array[3].id = 3; array[3].volumen = 600; array[3].precio = 9.5; //Ordenar el vector por ID qsort((void*)array, dimension, sizeof(struct Envase), ordenarID); //Mostrar el vector por ID. El output es {1 3 5 6} printf(\nOrdenado por ID: {); for(int i = 0; i < dimension; i++) { printf(%d , array[i].id); } printf(}\n); //Ordenar el vector por precio/volumen qsort((void*)array, dimension, sizeof(struct Envase), ordenar_precio_volumen); //Mostrar el vector por precio/volumen. El output ahora es {6 3 5 1} printf(\nOrdenado por precio/vol: {); for(int i = 0; i < dimension; i++) { printf(%d , array[i].id); } printf(}\n\n); return 0; } Como es l√≥gico, puedes hacer funciones comparadoras tan complicadas como quieras. Este es uno de los puntos fuertes del lenguaje C, su enorme flexibilidad. 5. Funciones como Arrays C tambi√©n permite declarar arrays de punteros a funciones. Este c√≥digo define tres funciones para hacer comprobaciones sobre un n√∫mero (si es par, si es positivo y si es primo) y las realiza sobre un entero introducido por el usuario. La gracia es que en vez de llamar las tres funciones individualmente, se guardan en un vector y √©ste se recorre con un bucle for. 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include <stdio.h> /*Comprobar si el numero es PAR*/ void funcion1(int a) { if(a % 2 == 0) printf(El numero es par\n); else printf(El numero es impar\n); } /*Comprobar si el numero es POSITIVO/NEGATIVO*/ void funcion2(int a) { if(a > 0) printf(El numero es positivo\n); else if(a < 0) printf(El numero es negativo\n); else printf(El numero es cero\n); } /*Comprobar si el numero es PRIMO*/ void funcion3(int a) { if(a <= 1) { printf(El numero NO es primo\n); return; } for(int i = 2; i <= (a)/2; i++) { if ( a%i == 0 ) { printf(El numero NO es primo\n); return; } } printf(El numero es primo\n); } int main() { //Vector de funciones void (*array[]) (int) = {funcion1, funcion2, funcion3}; //Se pide al usuario que entre un numero int val; printf(\nIntroduce un numero entero: ); scanf(%d, &val); //Se recorre el vector para llamar las funciones for(int i = 0; i < 3; i++) { array[i] (val); } return 0; } Programaci√≥n, Tutoriales C++, programaci√≥n, transductor"
      },
      {
        "id": 32,
        "autor": "chuidiang",
        "pagina": "chuidiang",
        "fecha": "04/02/2007",
        "titulo": "Conceptos y Consejos pr√°cticos para el uso correcto de punteros",
        "link": "http://www.chuidiang.org/clinux/funciones/punteros.php",
        "contenido": "Conceptos y Consejos pr√°cticos para el uso correcto de punteros Una cosa es lo que nos cuentan los libros de C sobre punteros y otra los problemas pr√°cticos que se nos plantean cuando nos ponemos a programarlos. Los punteros son adem√°s una cosa muy delicada, cualquier peque√±o despiste con ellos puede hacer que nuestro programa se caiga inesperadamente o de resultados muy extra√±os. Aunque en los ejemplos de c√≥digo que pongo a continuaci√≥n, al ir las l√≠neas seguidas, se ve claramente el error (al menos, esa es la intenci√≥n), lo habitual es que estas l√≠neas erroneas est√©n separadas en el c√≥digo, incluso en funciones distintas, con lo que no es tan evidente el verlas. Todo lo que se dice aqu√≠, aunque est√© explicado para C con las funciones malloc() y free(), se puede aplicar a C++, usando new y delete. Donde hablamos de estructuras, podemos hablar de clases. Concepto de puntero y primeros errores Podemos imaginar un puntero como una flecha. Esa flecha apunta a una direcci√≥n de memoria. Por ejemplo, si declaramos en C el puntero char *puntero; tenemos declarada una flecha que apunta a una direcci√≥n de memoria. ¬øA cual?. Aqu√≠ se nos presenta el primer problema pr√°ctico con los punteros. Tal cual est√° declarado, esa flecha apunta a cualquier direcci√≥n de memoria, al azar. Lo habitual es que sea la direcci√≥n de memoria 0 (cero), pero puede ser cualquiera. Si inmediatamente despu√©s de declararlo intentamos guardar algo en la direcci√≥n de memoria a la que apunta, como por ejemplo *puntero = 'A'; pueden pasarnos dos cosas: Que la direcci√≥n aleatoria a la que apunta puntero pertenezca a nuestro programa. En ese caso se meter√° la 'A' en la direcci√≥n y aparentemente no ha pasado nada. Lo que realmente pasa es que estamos metiendo un byte 65 (c√≥digo ascii de la 'A') en alg√∫n sitio de nuestro programa (c√≥digo, zona de variables, etc). El error puede presentarse en cualquier otro lada de nuestro programa, en un sitio aparentemente correcto. Que la direcci√≥n aleatoria a la que apunta puntero no pertenezca a nuestro programa. Esto es lo mejor que nos puede pasar. En el momento de la asignaci√≥n nuestro programa se caer√° y dar√° un error de violaci√≥n de memoria o similar. Al ser en el momento de la asignaci√≥n, podremos corregirlo m√°s f√°cilmente, ya que sabemos en qu√© l√≠nea se ha producdo el fallo. Por ello, como primer consejo pr√°ctico: Inicializar todos los punteros al declararlos, por ejemplo, a NULL char *puntero = NULL; Si nos olvidamos de hacerle apuntar a una direcci√≥n de memoria adecuada, nos dar√° error en el momento de utilizarlo, y  no despu√©s, en otro lado del programa. En general, casi todos los consejos que doy van orientados a poder depurar el programa con m√°s facilidad. Se trata de conseguir que el programa se caiga en la instrucci√≥n incorrecta y no que d√© resultados erroneos o se caiga en otro sitio que no tiene nada que ver. Apuntar un puntero a una direcci√≥n de memoria De lo comentado anteriormente, vemos que siempre debemos hacer que un puntero apunte a una direcci√≥n de memoria v√°lida antes de utilizarlo. Para ello tenemos dos posibilidades: Apuntarlo a una direcci√≥n de memoria ya reservada para nuestro programa. Para ello basta asignarlo a la direcci√≥n de cualquier variable que tengamos declarada o igualarlo a otro puntero que ya est√© apuntando a una direcci√≥n adecuada. Por ejemplo char unCaracter; char *puntero = NULL; ... puntero = &unCaracter; Ahora puntero apunta a la direcci√≥n de memoria en la que est√° unCaracter. Podemos utilizar con seguridad la memoria a la que apunta puntero, sabiendo que lo que pongamos ah√≠ tambi√©n se est√° poniendo en unCaracter. *puntero = 'A';  /* Ahora unCaracter tambi√©n tiene una 'A' */ Reservar una zona de memoria espec√≠fica para nuestro puntero y hacer que apunte a ella. Para ello tenemos la funci√≥n malloc(). La funci√≥n malloc() nos reserva una zona de memoria del tama√±o que le indiquemos y nos devuelve su direcci√≥n. Podemos hacer que nuestro puntero apunte a esa direcci√≥n puntero = malloc(...);  /* No pongo los par√°metros ... */ ... *puntero = 'A'; Una vez reservada la zona de memoria, podemos utilizarla con seguridad. Si no queremos que nuestro programa consuma m√°s memoria de la cuenta, debemos acordarnos de liberarla cuando no la necesitemos m√°s. Para ello est√° la funci√≥n free() a la que se le pasa la direcci√≥n de memoria que queremos liberar. free (puntero); Todo esto es muy bonito y es b√°sicamente lo que nos puede contar cualquier libro de C. Sin embargo, hay varios problemas que se nos pueden presentar. Si hacemos que nuestro puntero apunte a una variable local, cuando la variable desaparezca, nuestro puntero queda apuntando a una direcci√≥n de memoria que ya no es v√°lida. Por ejemplo char * funcion () { char resultado; char *puntero; resultado = algun_valor; puntero = &resultado; return puntero; } Esto es una fuente segura de problemas. La variable resultado tiene sentido dentro de la funci√≥n, pero al terminar la funci√≥n, desaparece la variable, puntero apunta a la direcci√≥n de memoria que ocupaba esa variable. Cuando intentemos usar el puntero devuelto por la funci√≥n, esa memoria ya est√° libre y es posible que alguien la sobre-escriba, haciendo que su valor sea aleatorio. Cualquier variante de esa funci√≥n tambi√©n da problemas. Por ejemplo, es igual de incorrecto este c√≥digo char * funcion () { char resultado; /* Aqui rellenamos resultado con el valor deseado */ return &resultado; } Al salir de la funci√≥n, la direcci√≥n que estamos devolviendo ya no tiene sentido. Adem√°s, esto nunca nos dar√° un error de violaci√≥n de memoria, ya que esa zona de memoria pertenec√≠a a nuestro programa. Nuestro programa no se caer√°, simplemente dar√° resultados incorrectos. No devolver nunca punteros a variables locales a una funci√≥n. Al liberar una zona de memoria con free() nuestro puntero queda apuntando a una direcci√≥n que ya no es correcta, free() no lo hace apuntar a NULL autom√°ticamente. Utilizarla posteriormente dar√° problemas. Por ejemplo: char *puntero = NULL; puntero = malloc(); free (puntero); *puntero = 'A'; Esto no dar√° ning√∫n problema de violaci√≥n de memoria, puesto que la memoria a la que apunta puntero era nuestra. Sin embargo, alguien puede posteriormente sobre-escribir en esa direcci√≥n de memoria. Este problema se agrava si no lo hacemos todos seguido. Imaginemos que hemos liberado puntero y que en otra funci√≥n o m√°s adelante en el c√≥digo intentamos usarlo. Apuntar a NULL los punteros despu√©s de liberarlos free (puntero); puntero = NULL; Si lo apuntamos a NULL despu√©s de hacer el free(), cuando lo intentemos utilizar de forma incorrecta, el programa se caer√° inmediatamente, con lo que ser√° m√°s sencillo de depurar. Liberar dos veces la misma zona de memoria puede dar montones de problemas. Cuando liberamos por segunda vez, el programa no da ning√∫n error, pero deja corrupto al gestor de memoria. Lo m√°s probable, al menos en solaris (unix de sun), es que posteriormente el programa nos d√© fallo en otro malloc(). Por ejemplo: char *puntero1 = NULL; char *puntero2 = NULL; puntero1 = malloc(); puntero2 = puntero1; free (puntero1); puntero1 = NULL; free (puntero2); puntero2 = NULL; Al liberar puntero1,  liberamos nuestro espacio de memoria. Sobra la liberaci√≥n de puntero2, ya que el espacio de memoria al que apunta ya est√° liberado. Esto no dar√° ning√∫n error en la ejecuci√≥n del programa, pero m√°s adelante tendremos problemas en alg√∫n malloc() o free(). Es bastante habitual hacer que una funci√≥n reserve un espacio de memoria y lo devuelva. Luego nuestro c√≥digo usar√° ese resultado en varios sitios e, inadvertidamente, podemos liberarlo en dos sitios distintos o dejarlo sin liberar. Es necesario, cuando hacemos un malloc(), tener claro qui√©n va a liberar esa memoria y d√≥nde, para evitar este tipo de problemas. Por cada malloc(), hacer un √∫nico free(). Cuando reservemos memoria con malloc(), decidir claramente qui√©n la va a liberar y cu√°ndo. Punteros dentro de estructuras Los punteros dentro de estructuras, si se utilizan descuidadamente, son fuente de problemas. Pongamos por ejemplo una estructura como la siguiente struct Datos { char *nombre; int otroCampo; } Todo lo dicho hasta ahora para punteros, vale para el que est√° dentro de la estructura. Si declaramos una variable de tipo Datos, el puntero nombre est√° sin inicializar. struct Datos unNombre; unNombre.nombre = NULL; y antes de usarlo reservar espacio para √©l unNombre.nombre = malloc(); o bien asignarlo a alguna variable adecuada. unNombre.nombre = &algunaVariableAdecuada; El problema principal con las estructuras surge cuando las copiamos o asignamos. Supongamos el siguiente c√≥digo struct Datos unNombre; unNombre.nombre = NULL; struct Datos otroNombre; otroNombre.nombre = NULL; ... unNombre.nombre = malloc(); ... otroNombre = unNombre; La √∫ltima asignaci√≥n copia todos los campos de la estructura unNombre en otroNombre, incluido el puntero interno. Ambos punteros van a apuntar a la misma direcci√≥n de memoria. Cambiar el contenido de uno de ellos implica cambiar el contenido del otro. El problema se presenta si liberamos uno de ellos free (unNombre.nombre); unNombre.nombre = NULL; Con esta acci√≥n tambi√©n hemos liberado la memoria a la que apunta otroNombre.nombre, por lo que su contenido puede no ser v√°lido. Utilizar o liberar  posteriormente otroNombre.nombre nos dar√° los problemas que ya hemos mencionado. En C++, si utilizamos clases con alg√∫n atributo puntero, tenemos algunos trucos que podemos utilizar. Uno de ellos consiste en definir el operator = () y constructores copia para que hagan una copia de los datos a los que apunta el puntero, y  no s√≥lo del puntero. Por ejemplo class Datos { protected: char *nombre; }; funciona exactamente igual que una estructura, con los mismos problemas al hacer asignaciones. Sin embargo class Datos { public: /* Constructor defecto */ Datos() { nombre = NULL; } /* Constructor copia */ Datos (Datos &original) { *this = original;  // Llama al operador de asignaci√≥n, m√°s abajo. } /* Destructor, Libera nombre si no es NULL */ ~Datos() { if (nombre != NULL) { delete [ ] nombre; nombre = NULL; } } /* Asignaci√≥n entre instancias de la clase */ Datos &operator = (Datos &original) { /* Se deber√≠a verificar si original.nombre tiene o no contenido antes de hacer la copia. por simplicidad no no hago */ nombre = new char[strlen (original.nombre)+1]; strcpy (nombre, original.nombre); return *this; } protected: char *nombre; }; Esto as√≠ es mucho m√°s seguro. Cada instancia de la clase hace su propio new[] y delete[] y tiene su propia zona de memoria reservada, con lo que es m√°s dif√≠cil equivocarse. La pega de esto es la ineficiencia. El mismo dato estar√° repetido en varias clases, con el consiguiente consumo de memoria. De todas formas, salvo para datos excesivamente grandes o aplicaciones muy cr√≠ticas en memoria, es mejor evitarse problemas definiendo constructores copia y operator = () En C no tenemos esta facilidad, pero podemos hacer funciones del tipo copiaEstructura (estructuraOrigen, estructuraDestino) o liberaEstructura (estructura) que se encargen de hacer estas copias de los punteros y de liberarlos correctamente. La otra opci√≥n es ser muy cuidadosos al programar. Para punteros dentro de estructuras o clases, hacer funciones o m√©todos adecuados para su tratamiento. Paso de punteros par√°metro En C, aunque no lo parezca, todos los par√°metros se pasan siempre por copia. Para hacer que tanto fuera de una funci√≥n como dentro se pueda acceder a la misma variable, hay que pasar un puntero a esa variable. Sin embargo, el puntero en s√≠ mismo se est√° pasando por copia. Veamos esto en un ejemplo: void funcion1 (char *p1) { *p1 = 'B'; } void funcion2 () { char *p2 = NULL; char unaVariable = 'A'; p2 = &unaVariable; ... funcion1 (p2); } En este ejemplo p2 apunta a la variable unaVariable. Llamamos a funcion1() pas√°ndole el puntero p2 y dentro actuamos sobre su contenido. Tanto p1 como p2 apuntan a la misma direcci√≥n de memoria (unaVariable), por lo que *p1='B' afecta a unaVariable y *p2. por Sin embargo, p1 y p2 son punteros distintos. Si dentro de funcion1() hacemos que p1 apunte a otro sitio, por ejemplo, con  cualquiera de las siguientes cosas: p1 = NULL; p1 = malloc(); p1 = &otraVariable; s√≥lo estamos tocando p1. El puntero p2 permanece inalterado, sigue apuntando a unaVariable. Esto tan simple suele dar lugar a errores. Es habitual tratar de devolver alg√∫n puntero pas√°ndolo como par√°metro. Por ejemplo, se podr√≠a pretender que funcion1() creara la memoria con malloc() y luego intentar usarla con p2 void funcion1 (char *p1) { p1 = malloc(...); strcpy (p1, Hola mundo\n); } void funcion2 () { char *p2 = NULL; funcion1 (p2); printf (%s, p2); } Cuando salimos de funcion1(), p2 sigue apuntando al mismo sitio, a NULL. El programa fallar√° en el printf(). Si queremos pasar por par√°metro un puntero y que la funci√≥n nos lo altere (el puntero, no su contenido), debemos pasar un puntero al puntero. La sintaxis es un poco m√°s liada, pero ser√≠a algo as√≠ como esto: void funcion1 (char **p1) { *p1 = malloc( ...); strcpy (*p1, Hola mundo\n); } void funcion2 () { char *p2 = NULL; funcion1 (&p2);        /* Advertir el & delante de p2 */ printf (%s, p2); } Esto s√≠ funciona correctamente. Depuraci√≥n En la parte de trucos C++ tienes una sugerencia de c√≥mo encontrar punteros descarriados. Estos son b√°sicamente los errores con los que me he tropezado o he visto a mis compa√±eros tropezarse cuando empezabamos con los punteros. Si conoces alg√∫n otro error t√≠pico, env√≠ame un correo y lo pondr√© por aqu√≠. Estad√≠sticas y comentarios Numero de visitas desde el 4 Feb 2007: Esta pagina este mes: 178 Total de esta pagina: 95086 Total del sitio: 24287170"
      },
      {
        "id": 33,
        "autor": "ADRIGM",
        "pagina": "genbeta",
        "fecha": "15/04/2013",
        "titulo": "Punteros y referencias",
        "link": "https://www.genbeta.com/desarrollo/punteros-y-referencias",
        "contenido": "Muchos novatos o gente que viene de lenguajes de alto nivel no quieren ni o√≠r hablar de C/C++. se oyen cosas como que es muy complicado porque hay que manejar la memoria a bajo nivel, no tiene recolector de basura, etc. Vamos a intentar explicar claramente el manejo de memoria en C/C++ y los temidos punteros y referencias. La memoria principal Como sabemos cuando declaramos una variable lo que estamos haciendo es reservar una zona de memoria, imaginemos que la memoria es una tabla con muchas celdas: Memoria Imaginemos que cada celda de memoria puede ser ocupada por un dato. En realidad seg√∫n el tipo dato se precisan m√°s o menos casillas, pero para entender el concepto imaginemos que en cada casilla se puede almacenar un dato. Nuestra memoria ficticia est√° compuesta de mil casillas numeradas desde el 0 al 999. √âsta es la direcci√≥n de memoria de cada casilla, su identificador √∫nico, como pudieran ser en la vida real una direcci√≥n de una calle, un n√∫mero y un piso. Si nosotros hacemos algo como esto en nuestro c√≥digo: int x = 4; Lo que estamos haciendo es reservar una zona de memoria para una variable x y d√°ndole el valor 4. Imaginemos que en nuestra memoria ficticia se almacena en la posici√≥n 998, se ver√≠a as√≠. Variable Bien, en C++ hay un operador para obtener la direcci√≥n de memoria de una variable y es & si hici√©ramos algo como imprimir el valor de la direcci√≥n de memoria: int x = 4; cout << Valor de x:  << x << endl; cout << Direccion de x:  << &x << endl; Nos saldr√≠a por pantalla: Valor de x: 4 Direccion de x: 998 Realmente no te saldr√° un n√∫mero entero sino que ser√° un n√∫mero hexadecimal bastante m√°s largo, pero hay que tener bastante claro que ni el n√∫mero hexadecimal que te de el compilador ni el 998 son n√∫meros enteros es una direcci√≥n de memoria un tipo de dato como cualquier otro. Punteros Como es un tipo de dato las direcciones de memoria se pueden almacenar en variables. Variables del tipo que almacenan direcciones de memoria que son los llamados punteros. Por tanto un puntero es tan solo un tipo de datos como int almacena enteros, char caracteres o float almacena n√∫meros de como flotante pues los punteros almacenan direcciones de memoria. La clave est√° en que no hay una palabra clave, valga la redundancia, para definir a los tipos punteros sino que seg√∫n sea el tipo de direcci√≥n que va a almacenar ese sera el tipo a√±adiendo el operador *. Por ejemplo si yo quiero crear un puntero que almacene una direcci√≥n de memoria de un entero debo hacer lo siguiente: int *px; con esto estoy declarando una variable que puede almacenar la direcci√≥n de una variable de tipo int. Podriamos entonces asignarle una direcci√≥n de memoria mediante el operador que vimos antes. int x = 4; int *px = &x; Imaginemos que la variable px se crea en la posici√≥n 2 de nuestra memoria ficticia. Nos quedar√≠a el siguiente esquema: Puntero Como vemos ocupa una posici√≥n como una variable normal, pero en lugar de contener un entero como 4 contiene una direcci√≥n de memoria (998). Como posici√≥n de memoria que ocupa tambi√©n tiene su direcci√≥n de memoria que se puede obtener con el operador & es lo que se llama un puntero de puntero. Estos se declaran igual que los dem√°s anteponiendo el operador *: int x = 4; int *px = &x; int **ppx = &px // es un puntero de puntero por lo que solo puede guardar direcciones de punteros de tipo int Siguiendo con el ejemplo de nuestra memoria ficticia supongamos que la nueva variable ppx se crea en la posici√≥n 997. Este ser√≠a el equema resultante. Puntero de puntero El operador de indirecci√≥n Bien, ya sabemos almacenar en memoria direcciones de memoria de otras variables ya sean variables enteras o de cualquier tipo como punteros de las mismas (punteros de punteros). Ahora necesitamos algo para poder usar esas direcciones de memoria, poder usarlas para acceder al contenido original, esto se hace a trav√©s del operador de indirecci√≥n * y no, no me he equivocado es el mismo que se usa para declarar los punteros es lo que tiene C y por tanto C++ que reutiliza mucho los operadores y basa su significado en el contexto. Veamos un ejemplo de uso. int x = 4; int *px = &x; cout << Valor de x:  << x << endl; cout << Valor de x:  *px << endl; Esto mostrar√° el siguiente resultado: Valor de x: 4 Valor de x: 4 Como vemos anteponer * a una variable puntero nos devuelve el contenido de la direcci√≥n que contiene. Lo mismo sucede con los punteros de punteros: int x = 4; int *px = &x; int **ppx = &px; cout << Valor de x:  << x << endl; cout << Valor de x:  << *px << endl; cout << Valor de x:  << **ppx << endl; La √∫ltima sentencia el asterisco m√°s pegado a la variable devuelve la que contiene la direcci√≥n de ppx que es px y el siguiente asterisco devuelve lo que contiene la direcci√≥n de px que es x y por tanto 4. Valor de x: 4 Valor de x: 4 Valor de x: 4 Paso por valor o por referencia Una de las cosas m√°s √∫tiles de los punteros es el paso por referencia en lugar del paso por valor. Vamos a explicar como funciona esto en C/C++. √Åmbito de variables Lo primero es entender bien lo que es el √°mbito de las variables, una variable solo existe en la funci√≥n en la que se crea y nada m√°s, a trav√©s de los par√°metros podemos pasar el valor de una determinada variable a otra funci√≥n, pero lo que pasamos es el valor y no la variable en s√≠. Veamos un ejemplo. #include void sumar(int); int main() { int n = 4; sumar(n); std::cout << n << std::endl; system(pause); return 0; } void sumar(int x) { x++; std::cout << x << std::endl; } Tenemos la funci√≥n main que contiene la variable n, esta variable solo existe en este contexto al llamar a la funci√≥n sumar que tiene como par√°metro la variable x lo que hacemos es darle a ese valor del par√°metro x el valor de n, pero es la √∫nica relaci√≥n que hay entre n y x por tanto la salida de nuestro programa es la siguiente: 5 4 La variable x que val√≠a 4 por el valor que le dio n es aumentada en una unidad y se muestra en pantalla, se sale de la funci√≥n sumar y se vuelve a la funci√≥n main que muestra el valor de n que sigue siendo 4. Paso por referencia Hay veces que nos interesa que una funci√≥n modifique una variable que no pertenece a ella, es decir, fuera de su √°mbito. En C/C++ es imposible pasar una variable por referencia como en otros lenguajes y hay que hacerlo a trav√©s de punteros (o referencias como veremos m√°s adelantes). La idea es que como solo se puede pasar el valor de una variable a una funci√≥n lo que hacemos es pasar la direcci√≥n de una variable a trav√©s de un par√°metro de puntero y luego con el operador de indirecci√≥n podemos acceder al contenido de la variable original. #include void sumar(int *); int main() { int n = 4; sumar(&n); std::cout << n << std::endl; system(pause); return 0; } void sumar(int *x) { *x = *x + 1; std::cout << *x << std::endl; } Como vemos el par√°metro de sumar ahora es un puntero que recibe una direcci√≥n de memoria en este caso le pasamos la direcci√≥n de la variable x y dentro de la funci√≥n con operador de indirecci√≥n podemos acceder al contenido de la variable n. Referencias Adem√°s de los punteros heredados de C el lenguaje C++ a√±adi√≥ una nueva caracter√≠stica que son las referencias, una referencia es por as√≠ decirlo un alias o etiqueta de una variable. Las referencias se deben inicializar al declararse ya que no son en s√≠ una variable sino una etiqueta de otra y se declaran poniendo el operador & despu√©s del tipo de dato. int n = 4; int &ref_n = n; std::cout << ref_n << std::endl; A efectos pr√°cticos n y refn se refieren a la misma variable de hecho si con el operador & obtenemos la direcci√≥n de memoria de n y refn obtendr√≠amos la misma en ambos casos. En nuestra memoria ficticia se ver√≠a as√≠: Referencia Paso por referencia... con referencias Las referencias son una buena forma de pasar un valor a otra funci√≥n sin ser por valor, veamos el ejemplo anterior de paso por punteros, pero est√° vez usando referencias. #include void sumar(int &); int main() { int n = 4; sumar(n); std::cout << n << std::endl; system(pause); return 0; } void sumar(int &x) { x = x + 1; std::cout << x << std::endl; } Espero que este art√≠culo ayude a todos los que tengas dudas a√∫n sobre como usar los punteros y las referencias de C/C++."
      },
      {
        "id": 34,
        "autor": "Jose Vicente Carratala",
        "pagina": "jocarsa",
        "fecha": "22/06/2020",
        "titulo": "Programando en C: Punteros",
        "link": "https://jocarsa.com/programando-en-c-punteros",
        "contenido": "Los punteros constituyen una de las herramientas diferenciales del lenguaje de programaci√≥n C con respecto a otros lenguajes considerados de m√°s alto nivel, desde el punto de vista de la cercan√≠a al lenguaje del ser humano o de la m√°quina dado que el lenguaje de programaci√≥n C Tiene una consideraci√≥n, con respecto a esos otros lenguajes, de estar relativamente cerca del lenguaje de la m√°quina, l√≥gicamente tiene la capacidad de trabajar con punteros o apuntadores, que no es m√°s que la capacidad de poder referirse directamente a un registro en memoria ocupado por una variable, en lugar de llamar directamente a esa variable o a ese referencia Obtener la referencia de la posicion en memoria de una variable En este ejemplo, empezamos declarando una variable de tipo entero a la cual asignamos un valor concreto, que para este ejemplo es el n√∫mero 5 a continuaci√≥n, tal y como hemos hecho otras tantas veces, simplemente devolvemos el valor de esa variable por pantalla, haciendo referencia al propio nombre de la variable directamente en una instrucci√≥n de impresi√≥n la novedad, en este ejercicio, es que, a continuaci√≥n, devolvemos no ya el valor de la variable, que para esta aplicaci√≥n no nos interesa tanto, sino la celda de memoria que ocupa en su asignaci√≥n. es decir, la direcci√≥n de la memoria a la que le ha tocado almacenar el valor de esa variable dentro de una misma ejecuci√≥n de un programa, el valor de la posici√≥n en la memoria ser√° siempre el mismo. sin embargo, si cerramos y abrimos el programa de nuevo, podremos comprobar como naturalmente la posici√≥n de la memoria de la variable habr√° cambiado, ya que cada vez que se ejecuta el programa, el sistema lo considera como un programa completamente nuevo, y no tiene porqu√© mantener las posiciones de la memoria con respecto a la ejecuci√≥n anterior adem√°s, podremos comprobar f√°cilmente como la nomenclatura de las direcciones de la memoria podr√° variar grandemente de un sistema a otro main.c #include <stdio.h> int main() {    int numero = 5;    printf(¬´El numero es: %d \n¬ª,numero);    printf(¬´La celda de memoria del numero es: %p \n¬ª,&numero);    } Creaci√≥n de un puntero A continuaci√≥n, una vez que ha quedado claro el concepto anterior, en cuanto a que podemos usar el s√≠mbolo ampersand para saber la direcci√≥n en memoria de una variable concreta, vamos a declarar un puntero o apuntador c√≥mo podemos imaginarnos, el siguiente c√≥digo es una evoluci√≥n del c√≥digo anterior, donde hemos declarado un nuevo puntero, que adem√°s, por claridad, recibe exactamente ese mismo nombre. Cuando creamos un puntero, habremos observado que la forma de la declaraci√≥n es exactamente igual que la forma en la que hemos declarado cualquier tipo anterior de variable, pero introducimos un asterisco justo antes del nombre de la variable. esto indica que esa variable no es una variable real, sino que va a apuntar a la direcci√≥n de memoria de otra variable adem√°s, tambi√©n es importante indicar que el tipo de dato del puntero deber√° ser el mismo tipo que el dato al que apunta por √∫ltimo, dentro de este ejemplo, vamos a extraer un par de datos del puntero, para saber c√≥mo debemos trabajar y como debemos invocarlos. si llamamos al propio puntero, es decir, lo llevamos como si estuvi√©ramos llamando a la propia variable, no tendremos el valor, sino que obtendremos la direcci√≥n en la memoria, porque precisamente eso es lo que hace un puntero, b√°sicamente apuntar a la direcci√≥n de memoria de otra variable algo as√≠ como un acceso directo sin embargo, si invocamos al puntero pero lo llamamos con el asterisco antes del nombre de la variable, ah√≠ es cuando estamos llamando al valor de la variable, o lo que es lo mismo, al valor de la variable a la que apunta el puntero main.c #include <stdio.h> int main() {    int numero = 5;    printf(¬´El numero es: %d \n¬ª,numero);    printf(¬´La celda de memoria del numero es: %p \n¬ª,&numero);        int *puntero; // Declaro un puntero    puntero = &numero; // El puntero apunta a la direccion de la memoria de la variable        printf(¬´El puntero esta en la posicion: %p \n¬ª,puntero);    printf(¬´El puntero tiene el valor: %i \n¬ª,*puntero);    } Referencia cambiante al puntero Todo esto que hemos visto hasta ahora b√°sicamente refuerza el mensaje de que un puntero no es en si una variable, sino que es un acceso directo a la posici√≥n es memoria de otra variable existente para demostrar la veracidad de esta afirmaci√≥n, esta extensi√≥n del ejercicio, aparentemente trivial, nos demuestra hasta qu√© punto el puntero va a depender siempre del valor original de la variable referenciada de esta forma, en primer lugar, trabajamos con el c√≥digo con el que hemos estado operando hasta el momento en esta unidad did√°ctica, pero, como novedad, a continuaci√≥n, una vez que hemos obtenido el valor del puntero, realizamos un cambio sobre el valor de la variable s√≠ la variable fuera una entidad, y el puntero fuera otra entidad, cambiar√≠a el valor de la variable, pero no el valor del puntero sin embargo, en el ejemplo a continuaci√≥n podemos comprobar que, cambiando el valor de la variable, no solo cambia el valor de la variable, sino que tambi√©n cambia el valor devuelto por el puntero, ya que, una vez m√°s, el puntero finalmente no tiene entidad por si mismo sino que apunta al valor de la variable inicial main.c #include <stdio.h> int main() {    int numero = 5;    printf(¬´El numero es: %d \n¬ª,numero);    printf(¬´La celda de memoria del numero es: %p \n¬ª,&numero);        int *puntero; // Declaro un puntero    puntero = &numero; // El puntero apunta a la direccion de la memoria de la variable        printf(¬´El puntero esta en la posicion: %p \n¬ª,puntero);    printf(¬´El puntero tiene el valor: %i \n¬ª,*puntero);        numero = 16;    printf(¬´El numero es: %d \n¬ª,numero);    printf(¬´El puntero tiene el valor: %i \n¬ª,*puntero);}"
      },
      {
        "id": 35,
        "autor": "Giovanni Benussi",
        "pagina": "maestrosdelweb",
        "fecha": "28/08/2012",
        "titulo": "Programaci√≥n en C/C++: Trabajando con punteros",
        "link": "http://www.maestrosdelweb.com/programacion-en-c-trabajando-con-punteros/",
        "contenido": "En el contexto de la programaci√≥n en C/C++ trabajar con punteros es algo que asusta a la mayor√≠a porque es un tema complicado de entender, pero una vez que se conoce la l√≥gica te das cuenta que no es tan terrible como se pensaba. En √©ste art√≠culo desarrollar√© la l√≥gica de los punteros y sus utilidades para que lo comprendamos mejor. Giovanni Benussi Giovanni Benussiagosto 28 2012 Compartir [tipexperto titulo = ‚ÄúNota‚Äù ] Si nunca has programado en C o C++, te recomiendo primero aprender a programar en el lenguaje, ya que es necesario conocerlo un poco para entender el tema de los punteros.[/tipexperto] Como se que a la mayor√≠a de nosotros, los programadores (o los que intentamos serlo), nos gusta aprender algo viendo c√≥digo directamente, mil veces me han explicado algo, pero no lo entiendo hasta ver el c√≥digo. Asi que tratar√© de explicar de esa manera para que quede clar√≠simo el tema. Vamos al grano. Entendiendo los punteros Un puntero es b√°sicamente una direcci√≥n de memoria. Muchas veces hemos hecho esto: ? 1 2 3 int numero; numero = 10; printf(‚ÄúNumero: %i‚Äù,numero); Obteniendo la salida: ‚ÄúNumero: 10‚Äù. Pero, ¬øQu√© hace el computador en su interior? El computador trabaja con direcciones de memoria, imaginemos los siguientes valores: Tenemos nuestra variable numero, cuyo valor es 10, y su direcci√≥n de memoria es 100. Cuando escribimos la l√≠nea ‚Äúnumero = 10; ‚Äú, le estamos diciendo al computador que en la direcci√≥n 100 escriba el valor 10. Ahora es cuando veremos un puntero, he aqu√≠ un c√≥digo equivalente al anterior: ? 1 2 3 4 int numero; int * puntero = ‚Ññ *puntero = 10; printf(‚ÄúNumero: %i‚Äù,numero); Nuevamente la salida es: ‚ÄúNumero: 10‚Äù. ¬øQu√© hicimos aqu√≠? Vayamos l√≠nea por l√≠nea para que quede claro: int numero: Declaramos nuevamente la variable numero. int * puntero = &numero: Declaramos un puntero llamado puntero al cual le asignamos la direcci√≥n de memoria de numero (el operador & nos sirve para obtener la direcci√≥n de memoria de una variable, en este caso, 100). *puntero = 10: Con esto estamos dici√©ndole al computador: ‚ÄúA lo que esta se√±alando el puntero (la direcci√≥n 100), asignale el valor 10‚Äù. printf(‚ÄúNumero: %i‚Äù,numero): Mostramos el valor de numero. Para que quede m√°s claro, veamos los valores que corresponden a nuestras variables hasta la segunda l√≠nea: [tipexperto titulo = ‚ÄúNota‚Äù] Para ver el contenido de un puntero, podemos escribir ‚Äúprintf(‚Äú%p‚Äù,puntero);‚Äù Los valores de las direcciones de memoria han sido cambiados para mayor comprensi√≥n, por ejemplo, la direcci√≥n de ‚Äúnumero‚Äù en mi computador dio ‚Äú0022FF18‚Äù. [/tipexperto] Como vemos, la variable puntero es una variable m√°s, tiene su direcci√≥n de memoria (110) y un valor. Lo que hace especial a los punteros, es que alojan una direcci√≥n de memoria, en este caso 100, que corresponde a la direcci√≥n de memoria de la variable numero (que contiene basura debido a que no la hemos inicializado). Entonces cuando escribimos ‚Äú*puntero = 10‚Äù, decimos: En la direcci√≥n 100, escribe el valor 10. Quedando de esta manera: Operadores &, ‚Äú*‚Äù y la funci√≥n Scanf Para que quede m√°s claro, les dejo los casos de uso de los operadores ‚Äú&‚Äù y ‚Äú*‚Äù: Operador & Se utiliza para obtener la direcci√≥n de memoria de una variable. Se puede implementar con cualquier tipo de variable. Operador ‚Äú*‚Äù Se utiliza s√≥lo con punteros. Su funci√≥n es la de acceder al contenido de la direcci√≥n almacenada. Quiero recalcar que siempre que trabajen con punteros, deben apuntarlo a alguna variable. De lo contrario apuntar√° a una direcci√≥n cualquiera y puede (y es lo mas probable) que te cause errores, adem√°s de que tu programa no funcionar√° como deber√≠a. Funci√≥n Scanf() Ahora que saben el uso del operador ‚Äú&‚Äù, quiz√°s entiendan el uso de la t√≠pica funci√≥n scanf, veamos un ejemplo de como se utiliza para leer una variable de tipo entero y guardar el valor en la variable: ? 1 scanf(%i,&variable); Pueden notar el uso del operador ‚Äú&‚Äù antes de ‚Äúvariable‚Äù. As√≠ es, scanf recibe un puntero del tipo que se le indica en el primer argumento (‚Äú%i indica un entero, por lo tanto, el segundo argumento debe ser de tipo puntero a entero). En √©ste primer art√≠culo aprendimos sobre los punteros y sus operadores. En una pr√≥xima entrega veremos casos de uso: Punteros para pasar argumentos por referencia a funciones, Arreglos y Matrices con punteros."
      },
      {
        "id": 36,
        "autor": "Ecured",
        "pagina": "Ecured",
        "fecha": "00/00/0000",
        "titulo": "Operadores de puntero",
        "link": "https://www.ecured.cu/Operadores_de_puntero",
        "contenido": "Operadores de puntero. Un puntero es una variable cuyo Rvalue es justamente la direcci√≥n en memoria de un objeto x. Es decir: Rvalue(p) == Lvalue(x). Adem√°s de los operadores aritm√©ticos, de los que existen versiones para los tipos num√©ricos y para los punteros, C++ dispone de dos operadores espec√≠ficos para estos √∫ltimos (punteros de cualquier tipo): la indirecci√≥n * y la referencia &. Adem√°s existen dos operadores espec√≠ficos para punteros-a-clases. Sumario 1 Operador de indirecci√≥n * 1.1 Sintaxis 1.2 Comentario 1.3 La indirecci√≥n m√∫ltiple 1.4 La indirecci√≥n con punteros a funci√≥n 2 La indirecci√≥n de punteros a clases y a miembros 2.1 Operador de indirecci√≥n de punteros-a-miembro .* 3 Operador de referencia & 3.1 Sintaxis 4 V√©ase tambi√©n 5 Fuente Operador de indirecci√≥n * Este operador unitario deferencia el operando (que debe ser un puntero). Es decir, devuelve el valor del objeto se√±alado por el operando. El s√≠mbolo * tiene tres usos en C++: operador de multiplicaci√≥n, indicador de tipo de variable (tipo puntero) y operador de indirecci√≥n. Sintaxis * cast-expresion Operando cast-expresion debe ser una expresi√≥n que se resuelva a un puntero-a-objeto, o a-funci√≥n. Cuando se usa como operador de indirecci√≥n se espera que el operando sea una variable de tipo puntero de cualquier tipo (a objeto, o a funci√≥n). Si el operando es un puntero-a-funci√≥n, el resultado es un designador de funci√≥n que puede ser utilizado para invocaci√≥n de la misma. Si ptr es un puntero-a-X, entonces se cumple que *ptr es el objeto apuntado por ptr y su tipo es el de X. Es decir: typeid(*ptr) == typeid(X) Comentario La expresi√≥n n = *ptr; asigna a la variable n el valor del objeto apuntado por ptr y a la inversa: la expresi√≥n *ptr = n; asigna al objeto apuntado por ptr el valor de la variable n. Si pt1 y pt2 son dos punteros a las variables v1 y v2, la expresi√≥n *pt2 = *pt1; asignar√≠a a la variable apuntada por pt2 el valor de la variable apuntada por pt1, es decir, equivale a v2 = v1;. Los punteros-a-void no pueden ser deferenciados sin un modelado expl√≠cito. El resultado de la operaci√≥n de indirecci√≥n sobre un puntero es indefinido si se da alguno de los casos siguientes (aqu√≠ indefinido significa que se obtiene basura o incluso un error irrecuperable): El operando cast-expresion es un puntero nulo. En este caso, lo m√°s probable es que se obtenga un error irrecuperable, como ocurre por ejemplo, con los compiladores Borland C++ 5.5 y MS Visual C++ 6.0 en la situaci√≥n siguiente: int x; int* ptr = 0; x = *ptr;       // Error!! El operando cast-expresion es un puntero a una variable autom√°tica y su bloque ha terminado la ejecuci√≥n. Ejemplo: int* iptr; ... { int x = 0; iptr = &x ... } ... int z = *iptr;   // Error!! El operando cast-expresion es un puntero a un elemento despu√©s del √∫ltimo de una matriz. Ejemplo: char* nombre = Bond; cout << Letra:  << *nombre << endl;       // Ok. cout << Letra:  << *(nombre+5) << endl;   // Error!! La indirecci√≥n m√∫ltiple Se ha se√±alado que los punteros pueden a su vez se√±alar a punteros. En estos casos, el valor del objeto se√±alado en el extremo de la cadena de punteros debe obtenerse mediante varias indirecciones. Considere el siguiente ejemplo: int x = 10;            // entero int* iptr = &x;        // puntero a entero int** pptr = &iptr     // puntero a puntero a entero cout << Valor x =  << *iptr << endl; cout << Valor x =  << **pptr << endl; Salida: Valor x = 10 Valor x = 10 La indirecci√≥n con punteros a funci√≥n Hay que resaltar que la indirecci√≥n de punteros a funciones no se utiliza para obtener la direcci√≥n de comienzo del c√≥digo sino para invocar la funci√≥n se√±alada por el puntero y que esta invocaci√≥n tiene una sintaxis un tanto especial. En efecto, sea el c√≥digo: void somefunc (...); // una funci√≥n con sus par√°metros ... void (*fptr)(...) = &somefunc; // fptr es puntero a somefunc En este caso, seg√∫n la definici√≥n de puntero, ocurre que: *fptr == somefunc (ambas expresiones son equivalentes), por lo que en la invocaci√≥n de la funci√≥n podemos sustituir el nombre por *fptr, lo que nos conducir√≠a a la notaci√≥n: *fptr( ...); como f√≥rmula de invocaci√≥n. Sin embargo, esta expresi√≥n debe ser utilizada con par√©ntesis: (*fptr)( ...);. Se tiene as√≠ que las dos sentencias que siguen son igualmente v√°lidas para invocar a la funci√≥n, pero observe que la segunda tiene una sintaxis especial: somefunc(...);    // L.1  Ok invocaci√≥n tradicional (*fptr)(...);     // L.2  Ok invocaci√≥n a trav√©s de puntero *fptr(...);       // L.3  Error de sintaxis!! La indirecci√≥n de punteros a clases y a miembros En la programaci√≥n C/C++ los punteros y sus operaciones constituyen parte fundamental del lenguaje, por lo que es muy frecuente el uso del operador de indirecci√≥n * para acceder a entidades se√±aladas por punteros, y desde luego, este operador (herencia del C cl√°sico), cubre suficientemente las necesidades de acceso a trav√©s de punteros de cualquier tipo. Sin embargo C++ va un paso m√°s all√° cuando se trata de punteros a clases o a sus miembros (tambi√©n a estructuras y uniones) y ofrece dos operadores adicionales para estos casos. Operador de indirecci√≥n de punteros-a-miembro .* El operador .* de indirecci√≥n de puntero-a-miembro, es un operador binario cuyo resultado es un objeto-valor (indirecci√≥n de un puntero-a-propiedad) o un objeto-algoritmo (indirecci√≥n de un puntero-a-m√©todo). Su sintaxis es la siguiente: <objeto> .* <puntero-a-miembro> <objeto> es la estructura de datos (objeto) en la que se aplicar√° el desplazamiento (offset) se√±alado por el puntero. <puntero-a-miembro> es el puntero que se deferencia Para que la indirecci√≥n funcione correctamente, objeto debe ser la instancia de una clase C, mientras que puntero-a-miembro debe ser del tipo X C::*, siendo X el tipo de um miembro de C. Adem√°s, el objeto deber√° ser accesible desde el puntero. Si el resultado de la indirecci√≥n es una funci√≥n (m√©todo), solo podr√° ser utilizado como operando con el operador de invocaci√≥n de funci√≥n ( ). Se√±alar que el puntero-a-miembro representado por el operador derecho no tiene porqu√© ser un miembro del objeto se√±alado por el operador izquierdo (de hecho puede no ser un miembro de clase). En otras palabras, no tiene porqu√© existir ninguna conexi√≥n entre las entidades representadas por ambos operadores. Operador de referencia & Este operador unitario es complementario del de indirecci√≥n. Cuando se aplica a un objeto devuelve la direcci√≥n de almacenamiento del objeto (valor que puede ser asignado a un puntero). En C++ el s√≠mbolo & se utiliza tambi√©n como declarador de referencia; casi siempre para pasar argumentos a funciones. Sintaxis & cast-expresion El operando cast-expresion debe ser alguno de los siguientes: Un identificador cualificado. Ejemplo: class A {....}; int A::iptr = &A::miembro_x; El designador de una funci√≥n. Ejemplo: void func() { /* ... */ };  // funcion void (*fptr)() = &func;     // Ok. puntero-a-funcion Un Lvalue designando un objeto X que no sea un campo de bits ni tenga un especificador de almacenamiento tipo registro. Recuerde que no es posible obtener la direcci√≥n de una variable de registro. Es decir, no se le puede aplicar le operador de referencia a una de estas variables. Tampoco se puede aplicar al valor devuelto por una funci√≥n, en consecuencia, la expresi√≥n x = &func(x); es incorrecta, ya que el valor devuelto por func() es del tipo registro (est√° en la pila que no es direccionable por este m√©todo). Regla: el operador de referencia no puede ser aplicado al valor devuelto por una funci√≥n. V√©ase tambi√©n Operadores Operadores aritm√©ticos Operadores l√≥gicos Operadores de manejo de bits Operador condicional Operador coma Operadores relacionales Operadores de asignaci√≥n Operadores de modelado de tipos Operadores a√±adidos a expresi√≥n Operador de acceso a √°mbito Operador new Errores con el operador new Operador delete Operador sizeof Operador typeid Operador de preproceso Fuente Operadores de puntero Operadores que act√∫an sobre punteros Operadores de punteros & y * Categor√≠as: Inform√°ticaLenguajes de programaci√≥nProgramaci√≥n Powered by MediaWiki Normativa de privacidadEcuRedExoneraciones"
      },
      {
        "id": 37,
        "autor": "Roberto G√≥mez",
        "pagina": "cryptomex",
        "fecha": "00/00/0000",
        "titulo": "Apuntadores y Arreglos",
        "link": "http://cryptomex.org/Tutorial-LengC/apun_arreg.html",
        "contenido": "Existe una estrecha relaci√≥n entre apuntadores y arreglos, tanto que pueden ser usados en forma casi indistinta. Una variable de tipo arreglo puede considerarse como un apuntadoral tipo del arreglo. Los apuntadores pueden ser utilizados en cualquier operaci√≥n que involucre sub√≠ndices de arreglos. Ejemplo: prog35.c Ejemplo relacion apuntadores y arreglos #include <stdlib.h> #include <stdio.h> int main() { int tabla[10],i,x,*pt,*ptr; pt = &tabla[0]; x = *pt; for (i=0; i <10; i++) *(pt+i) = rand() % 100; ptr = tabla; for (i=0; i <10; i++) printf(''%d \n'',*(ptr+i),tabla[i]); } Cuando se suma 1 a un apuntador el incremento se adecua al tama√±o en memoria del objeto apuntado. Un apuntador es una variable, por lo que operaciones como pa = a y pa++ son permitidas. Un nombre de un arreglo es una constante, no una variable, de ah√≠ que a = pa o a++ o p = a. Arreglos de apuntadores Los arreglos pueden contener apuntadores El uso m√°s com√∫n es el de formar arreglos de cadenas de caracteres Cada entrada en el arreglo es un apuntador al primer caracter de la cadena Sea la declaraci√≥n: char * mensaje[4] = {''Hola'',''Adios'',''Bye'',''Salut''} Cada cadena est√° almacenada en memoria como una cadena de caracteres terminada en NULL n0. En el arreglo no estan colocadas las cadenas, tan solo est√°n almacenados los apuntadores. Aunque el arreglo es de tama√±o fijo, permite el acceso a cadenas de caracteres de cualquier longitud. prog36.c Inicializaci√≥n de arreglos de apuntadores #include <stdlib.h> #include <stdio.h> int main() { int x; char * mes[] = { ''mes ilegal'', ''enero'', ''febrero'', ''marzo'', ''abril'', ''mayo'', ''junio'', ''julio'', ''agosto'', ''septiembre'', ''octubre'', ''noviembre'', ''diciembre'', }; x = rand() % 12; printf(''El mes %d corresponde a %s \n'',x,mes[x]); } Detalles inicializaci√≥n arreglos caracteres A diferencia de un apuntador, un arreglo inicializado por un string puede ser modificado. Los caracteres individuales pueden ser cambiados despu√©s. prog37.c Ejemplo inicializaci√≥n arreglos caracteres #include <stdio.h> int main() { char *esp[10] = { ''uno'', ''dos'', ''tres'' }; char frances[5][10] = { ''un'', ''deux'', ''trois'' }; printf(Elemen: 123456789\n); for (i=0; i<3; i++) printf(Esp[%d]: %s\n,i,esp[i]); for (i=0; i<3; i++) printf(Fra[%d]: %s\n,i,esp[i]); printf(\nEsp: Elemento 3 de la entrada 2  %c \n,esp[2][3]); printf(Fra: Elemento 4 de la entrada 3  %c \n,frances[3][4]); printf(Esp: Elemento 7 de la entrada 2  %c \n,esp[2][7]); frances[3][4]='A'; printf(Fra: Elemento 4 de la entrada 3  %c \n,frances[3][4]); esp[2][3]='A'; /* Segmentation fault (core dumped) */ printf(Elemento 3 entrada 2 esp: %c \n,esp[2][3]); } Apuntadores y arreglos multidimensionales Puede provocar confusi√≥n el uso de arreglos de dos dimensiones y un arreglo de apuntadores. Considerar: int a[10][10]; int *b[10]; El uso de a y b puede ser parecido, desde el momento en que a[5][5] y b[5][5] son referencias validas a un int El arreglo a es un arreglo verdadero, existen 100 celdas de memoria asignadas y se efectua el c√°lculo de sub√≠ndices rectangulares convencional para localizar un elemento dado Sin embargo a b la declaraci√≥n solo le asigna 10 apuntadores, cada uno de los cuales deber√° de apuntar a un arreglo de enteros La desventajas de b son: 1. ocupa m√°s espacio, suponiendo que cada uno apunta a un arreglo de 10 elementos, el tama√±o ser√° de 10 apuntadores m√°s 100 elementos 2. se debe de crear el espacio de los arreglos antes de asignarlos La declaraci√≥n b tiene dos ventajas: 1. el acceso se hace m√°s r√°pido, una inderecci√≥n es m√°s rapida que el hacer una multiplicaci√≥n seguida de una suma 2. el tama√±o de los arreglos apuntados por cada una de las diez  localidades pueden ser diferentes Diferentes formas de declarar a[i][j] Cuando se ve la referencia a un arreglo de dos dimensiones, a[i][j] , no se puede deducir inmendiatamente como fue declarado a : Como un arreglo de 10 arreglos de tama√±o 20 int a[10][20]; Como un arreglo de tama√±o 20 de vectores de longitud variable int *a[10]; Como un apuntador de apuntadores a enteros int **a; Como un apuntador a un arreglo de enteros de tama~no 20 int (* a)[20]; Para poder direccionar un elemento de un apuntador de apuntadores se sigue la regla: tab[i][j] * ( *(tab + i) + j)"
      },
      {
        "id": 38,
        "autor": "Diego Vizcarra",
        "pagina": "codingornot",
        "fecha": "20/11/2016",
        "titulo": "05. Apuntadores: trabajando con estructuras",
        "link": "https://codingornot.com/05-apuntadores-trabajando-con-estructuras",
        "contenido": "Las estructuras son una forma en que podemos agrupar varias variables para, posteriormente, lograr referirnos a ellas como una entidad completa. Claro que es posible crear cualquier programa sin llegar a utilizar ninguna estructura pero, en ocasiones, es mucho m√°s conveniente su uso para poder dar un significado m√°s l√≥gico a lo que estamos realizando. El hecho de que podamos agrupar varias variables en una estructura nos pone a pensar que el tama√±o en bytes de esta podr√≠a ser realmente grande. Si quisi√©ramos, por ejemplo, pasar una estructura por valor a una funci√≥n, ver√≠amos que tendr√≠a que copiarse una gran cantidad de informaci√≥n. En esta nota veremos c√≥mo los apuntadores nos ofrecen una soluci√≥n a este problema. Sintaxis de apuntador a estructura No tiene nada de especial crear un apuntador hacia una variable de tipo estructura, es exactamente lo mismo que crear un apuntador hacia cualquier otra variable, a√∫n as√≠, deja te muestro un ejemplo: /* Tenemos nuestra estructura */ struct Punto { int x; int y; } /* Tenemos una variable del tipo anterior y la inicializamos */ struct Punto p1; p1.x = 0; p1.y = 0; /* Creamos nuestro apuntador y lo inicializamos */ struct Punto *ptr_p1 = &p1; ¬°Listo! Tenemos nuestro apuntador con la direcci√≥n de una variable de tipo struct Point. Como recordar√°s por la nota anterior, es posible acceder a una variable para modificar o leer su valor haciendo uso de alg√∫n apuntador. ¬øC√≥mo realizamos esto para acceder a los campos de la estructura? B√°sicamente no existe diferencia con el m√©todo normal para acceder a un campo (un punto despu√©s del nombre de la variable, seguido del nombre del campo), solo queda agregar nuestro operador de desreferencia (*) y estaremos bien. No olvides que dicho operador es uno de los que tienen mayor precedencia en el lenguaje C o C++, por tanto, siempre es mejor asegurarse de que este operador sea el primero que act√∫e sobre nuestra variable. Veamos el siguiente ejemplo: /* Usamos el material del ejemplo anterior */ (*ptr_p1).x = 5; (*ptr_p1).y = 10; /* Si accedemos a la estructura, veremos que sus campos han sido modificados */ std::cout << X:  << p1.x << std::endl; std::cout << Y:  << p1.y << std::endl; // -- SALIDA -- // X: 5 // Y: 10 Aunque no lo creas, acceder a los campos de una estructura haciendo uso de alg√∫n apuntador es algo bastante com√∫n, por tanto, se decidi√≥ colocar syntactic sugar para que esta acci√≥n fuera m√°s sencilla y sobre todo legible para los desarrolladores. Por si te lo preguntas, syntactic sugar no es m√°s que un t√©rmino que hace referencia a algo que se a√±adi√≥ a un lenguaje de programaci√≥n para ofrecer una misma funcionalidad ya implementada pero haciendo uso de un estilo diferente. Un ejemplo de esto √∫ltimo ser√≠a al momento de realizar una operaci√≥n aritm√©tica sobre una misma variable: int a = 20; /* Sumamos un valor a la variable de forma normal */ a = a + 5; /* La acci√≥n de arriba pero haciendo uso de syntactic sugar */ a += 5; As√≠ pues, si queremos acceder al campo de una estructura por medio un apuntador, podemos irnos olvidando del operador de desreferencia y de los par√©ntesis extra y solo hacer uso del operador flecha (->). Veamos c√≥mo se usa: // Retiramos el asterisco, los par√©ntesis y sustituimos // el punto por el operador flecha ptr_p1->x = 4; ptr_p1->y = 8; // IMPORTANTE: Si utilizas el operador flecha, el compilador // supondr√° que la variable sobre la que est√°s actuando es un apuntador. p1->x = 0; // ERROR. Esto es igual a (*p1).x = 0 Normalmente se nos habla del operador flecha pero sin que nos ense√±en qu√© es lo que realmente est√° pasando detr√°s, aqu√≠ vemos que m√°s que un operador, solo es un agregado para facilitar una expresi√≥n. Pasando estructuras por referencia Recordemos que la pila es una regi√≥n en la memoria donde se van almacenando los par√°metros, las variables y los valores de retorno de cada una de las funciones que llamamos. Con base en esto, observa que si enviamos una estructura con varios campos a una funci√≥n, la pila tendr√° que generar espacio suficiente para guardar todos y cada uno de estos valores. Este proceso de ‚Äúcopiar‚Äù toma tiempo y, adem√°s, podr√≠a ocasionar un desbordamiento de la pila, provocando que el sistema operativo ‚Äúmate‚Äù a nuestro programa por querer acceder a regiones de memoria no permitidas. Tal y como lo expresamos al inicio de esta nota: ¬øc√≥mo ser√≠an de ayuda los apuntadores en este caso? Haciendo uso del famoso paso por referencia. A diferencia del paso por valor, donde cada par√°metro no es m√°s que una copia de la variable que le pasamos, en el paso por referencia tenemos que entregar solo la direcci√≥n de la variable. El hecho de que estemos pasando una direcci√≥n como par√°metro a una funci√≥n, no la excluye de ser copiada en la pila. ¬øCu√°l es el beneficio, entonces? Que la direcci√≥n solo tomar√≠a 8 bytes de espacio, a diferencia de lo que tomar√≠a copiar una estructura que contiene 5 enteros, es decir, 20 bytes en total (los tama√±os en bytes tanto para el apuntador como para el entero dependen del compilador). ¬øQu√© pasar√≠a si nuestra estructura tuviera m√°s estructuras como campos? Seguro que puedes imaginarlo. Para terminar En esta ocasi√≥n no solo vimos c√≥mo crear un apuntador para referirnos a un tipo de dato en particular, en este caso las estructuras, sino que tambi√©n vimos un caso pr√°ctico en el que los apuntadores pueden resultar ser muy √∫tiles para mejorar el rendimiento de nuestros programas. En la siguiente nota veremos algo sobre los apuntadores a funci√≥n, otro tema que resulta confuso para varias personas pero que, si has llegado hasta esta parte de la serie, seguro no tendr√°s mayor problema en llegar a dominarlo. Cualquier duda o sugerencia que tengas puedes expresarla en los comentarios, espero esta nota haya ayudado a que despejaras varias dudas. Nos vemos en la pr√≥xima. Hasta entonces."
      },
      {
        "id": 39,
        "autor": "Fernando Briano ",
        "pagina": "Picando Codigo",
        "fecha": "25/09/2007",
        "titulo": "Punteros de memoria en C",
        "link": "https://picandocodigo.net/2007/punteros-de-memoria-en-c/",
        "contenido": "El puntero de memoria es uno de los conceptos m√°s dif√≠ciles, aparentemente, de entender. Antes de darlos en algoritmos, ya hab√≠a le√≠do al respecto en libros e internet, y adem√°s repasamos el concepto en la reuni√≥n de C++. Una definici√≥n formal ser√≠a algo as√≠: Un puntero es un tipo de dato o variable que contiene como valor una direcci√≥n de memoria. O sea, en vez de ser una variable con un valor num√©rico como int, o float, guarda una direcci√≥n de memoria. Se le llama puntero porque apunta a la direcci√≥n de memoria que almacena. Es importante diferenciar dos aspectos del puntero. Ac√° viene lo ‚Äúdif√≠cil‚Äù, ya que es un concepto bastante abstracto, y se presta a confusiones. El puntero como tipo de datos que es, ocupa su lugar en la memoria, y contiene una direcci√≥n de memoria. Si nos imaginamos que la memoria de la computadora es un organizador con varios espacios. Cada espacio tiene su direcci√≥n √∫nica. Si en un espacio guardamos un entero, en el caj√≥n con direcci√≥n X tenemos el entero con valor Y. Un puntero puede por ejemplo guardar el valor de X, pero a su vez va a tener un valor distinto X1 que ser√° su propia direcci√≥n en la memoria. Resumiendo, es un tipo de variable que en vez de guardar un valor como ‚Äú42‚Äù o ‚Äúfernando‚Äù, guarda una direcci√≥n de memoria que puede parecerse a algo as√≠: 0xbff9a1e0 Esa direcci√≥n de memoria puede apuntar a un entero, caracter u otro tipo de dato. Un puntero ocupa 4 bytes en memoria en plataformas de 32 bits. Pero en las arquitecturas de 16 bits mide generalmente 2 bytes, y en las de 64 bits, mide 8 bytes (Gracias Francisco por el comentario) Actualmente, en lenguajes como Java o Visual Basic, los punteros se manejan de forma invisible para el programador. Por ejemplo en Visual Basic, cuando en una funci√≥n pasamos por par√°metro una variable ‚ÄúByRef‚Äù (por defecto se pasan ‚ÄúByVal‚Äù) estamos pasando un puntero. Esto supone la ventaja para el programador que no tiene que preocuparse por los punteros y los problemas que trae con la memoria, y s√≠ preocuparse por resolver el problema del algoritmo. Pero tambi√©n le quita todas las ventajas de optimizaci√≥n que traen. El problema con los lenguajes de alto nivel, es que ahora se crean los ‚Äúprogramadores Express‚Äù. Se les ense√±a alg√∫n lenguaje f√°cil orientado a objetos (l√©ase VB) para tener salida laboral r√°pida, y se olvidan muchos conceptos abstractos importantes como punteros y estructuras de datos. En el caso de mi curso, pasa en los primeros dos semestres, donde se ve todo en Visual Basic.Net, cuando se llega al tercer semestre y vemos Java, la mayor√≠a miran como si fuera japon√©s. Y ni hablar cuando llegamos a Algoritmos y estructuras de datos‚Ä¶ Pero eso da para otro post que ya tendr√° su lugar‚Ä¶ Siguiendo con los punteros: EJEMPLOS EN C Ejemplos punteros en C El primer programa que hice fue direccion.c para entender un poco m√°s el tema de direcciones de memoria. En mi caso al compilar y ejecutarlo, el resultado fue el valor de memoria que escrib√≠ m√°s arriba. Ahora si lo vuelvo a ejecutar da: 0xbfb8ddd0 Viendo el c√≥digo se nota que son solo dos l√≠neas. Al declarar una variable, reservamos el espacio en memoria para almacenar su valor. Y para conocer la direcci√≥n de memoria que se le asign√≥ a una variable, se usa el ampersand ‚Äú&‚Äù como operador de direcci√≥n (printf(%p \n, &var);). Si intent√°ramos guardar el valor de &var en una variable com√∫n, el compilador da un error, y si bien se puede correr el programa, el valor que guardamos no va a ser la direcci√≥n de memoria de la variable, sino ‚Äúbasura‚Äù. Por cierto, el error: warning: assignment makes integer from pointer without a cast parece bastante com√∫n cuando se trabaja con punteros. Significa que intentamos darle un valor puntero a una variable que no lo es. Declarando un puntero Declarar un puntero en C lleva el siguiente formato: tipoDeDato *nombre; Lo he visto de dos formas distintas, con el asterisco pegado al tipo de datos, y al nombre del puntero, y con gcc por lo menos, compila de ambas formas. Actualizado: Gracias a los aportes en los comentarios de yiyus y Francisco, puedo agregar: En C no importa cu√°ntos espacios pongas ni donde siempre y cuando los tokens queden bien separados, por eso tipoDeDatos*nombre; es tan v√°lido como: tipoDeDatos* nombre; Sin embargo, por cuesti√≥n de estilo el asterisco * deber√≠a estar junto al nombre de la variable en vez de el tipo: char *s, *t, *u; En vez de: char* s, t, u; Lo cual es incorrecto, ya que ¬¥t¬¥ y ¬¥u¬¥no son declaradas como punteros. (citado de http://www.psgd.org/paul/docs/cstyle/cstyle04.htm) El ejemplo siguiente declara una variable entera de nombre ‚Äòvar‚Äò y un puntero de valor entero y nombre ‚Äòpunt‚Äò. Apuntamos el puntero ‚Äòpunt‚Äò a la direcci√≥n de memoria de ‚Äòvar‚Äò. Le d√≠ el valor 7 al entero, ya que en caso de no darle un valor, nos va a mostrar cualquier dato basura que hubiera en ese espacio de memoria al momento de declarar la variable. Ahora, imprimimos en pantalla el valor de ‚Äòvar‚Äò que es 7. Despu√©s se imprime su direcci√≥n de memoria con el especificador de formato ‚Äú%p‚Äù (muestra valor puntero o direcci√≥n de memoria) y el ampersand &. En la siguiente l√≠nea, se muestra el valor que guard√≥ el puntero ‚Äòpunt‚Äò, con %p y ‚Äòpunt‚Äò, que podemos ver si compilamos y ejecutamos, que es el mismo valor que la direcci√≥n de memoria de ‚Äòvar‚Äò. Por √∫ltimo, mostramos la direcci√≥n de memoria de ‚Äòpunt‚Äò. Escribiendo el c√≥digo y compilando puede ir adquiriendo el concepto de puntero, direcci√≥n de memoria y las posibles confusiones. √âste post es solo a modo de ejemplo para ir agarr√°ndole la mano al tema. M√°s adelante ir√© posteando sobre usos √∫tiles de los punteros como enlazar estructuras de datos en estructuras din√°micas y pasar argumentos por referencia. Por ahora eso, espero que a alguien le sirva. En lo personal me sirve mucho para practicar y dejar los conceptos m√°s claros. Los fuentes fueron compilados usando gcc 4.1 en GNU/Debian Etch. Si encuentras alg√∫n error o quieres hacer alg√∫n comentario, cr√≠tica o aporte, por favor deja un comentario. Hay mucho m√°s para estudiar respecto a los punteros como dereferenciaci√≥n, segmentation fault y dem√°s golpes, pero por ahora lo dejamos ac√°. Posts relacionados"
      },
      {
        "id": 40,
        "autor": "Nacho Cabanes",
        "pagina": "Aprende a Programar",
        "fecha": "27/07/2014",
        "titulo": "9.2. ¬øQu√© son los punteros?",
        "link": "https://www.aprendeaprogramar.com/mod/resource/view.php?id=648",
        "contenido": "9.2. ¬øQu√© son los punteros? Un puntero no es m√°s que una direcci√≥n de memoria. Lo que tiene de especial es que normalmente un puntero tendr√° un tipo de datos asociado: por ejemplo, un ‚Äúpuntero a entero‚Äù ser√° una direcci√≥n de memoria en la que habr√° almacenado (o podremos almacenar) un n√∫mero entero. Vamos a ver qu√© s√≠mbolo usamos en C para designar los punteros: int num; /* num es un n√É¬∫mero entero */ int *pos; /* pos es un puntero a entero (direcci√É¬≥n de memoria en la que podremos guardar un entero) */ Es decir, pondremos un asterisco entre el tipo de datos y el nombre de la variable. Ese asterisco puede ir junto a cualquiera de ambos, tambi√©n es correcto escribir int* pos; Esta nomenclatura ya la hab√≠amos utilizado aun sin saber que era eso de los punteros. Por ejemplo, cuando queremos acceder a un fichero, hacemos FILE* fichero; Antes de entrar en m√°s detalles, y para ver la diferencia entre trabajar con ‚Äúarrays‚Äù o con punteros, vamos a hacer dos programas que pidan varios n√∫meros enteros al usuario y muestren su suma. El primero emplear√° un ‚Äúarray‚Äù (una tabla, de tama√±o predefinido) y el segundo emplear√° memoria que reservaremos durante el funcionamiento del programa. El primero podr√≠a ser as√≠: /*---------------------------*/ /*  Ejemplo en C n¬∫ 71:      */ /*  C071.C                   */ /*                           */ /*  Sumar varios datos       */ /*  Version 1: con arrays    */ /*                           */ /*  Curso de C,              */ /*    Nacho Cabanes          */ /*---------------------------*/ #include <stdio.h> int main() { int datos[100];  /* Preparamos espacio para 100 numeros */ int cuantos;     /* Preguntaremos cuantos desea introducir */ int i;           /* Para bucles */ long suma=0;     /* La suma, claro */ do { printf(Cuantos numeros desea sumar? ); scanf(%d, &cuantos); if (cuantos>100)  /* Solo puede ser 100 o menos */ printf#40;Demasiados. Solo se puede hasta 100.); } while (cuantos>100);  /* Si pide demasiado, no le dejamos */ /* Pedimos y almacenamos los datos */ for (i=0; i<cuantos; i++) { printf(Introduzca el dato n√∫mero %d: , i+1); scanf(%d, &datos[i]); } /* Calculamos la suma */ for (i=0; i<cuantos; i++) suma += datos[i]; printf(Su suma es: %ld\n, suma); return 0; } Los m√°s avispados se pueden dar cuenta de que si s√≥lo quiero calcular la suma, lo podr√≠a hacer a medida que leo cada dato, no necesitar√≠a almacenar todos. Vamos a suponer que s√≠ necesitamos guardarlos (en muchos casos ser√° verdad, si los c√°lculos son m√°s complicados). Entonces nos damos cuenta de que lo que hemos estado haciendo hasta ahora no es eficiente: Si quiero sumar 1000 datos, o 500, o 101, no puedo. Nuestro l√≠mite previsto era de 100, as√≠ que no podemos trabajar con m√°s datos. Si s√≥lo quiero sumar 3 n√∫meros, desperdicio el espacio de 97 datos que no uso. Y el problema sigue: si en vez de 100 n√∫meros, reservamos espacio para 5000, es m√°s dif√≠cil que nos quedemos cortos pero desperdiciamos much√≠sima m√°s memoria. La soluci√≥n es reservar espacio estrictamente para lo que necesitemos, y eso es algo que podr√≠amos hacer as√≠: /*---------------------------*/ /*  Ejemplo en C n¬∫ 72:      */ /*  C072.C                   */ /*                           */ /*  Sumar varios datos       */ /*  Version 2: con punteros  */ /*                           */ /*  Curso de C,              */ /*    Nacho Cabanes          */ /*---------------------------*/ #include <stdio.h> #include <stdlib.h> int main() { int* datos;      /* Necesitaremos espacio para varios numeros */ int cuantos;     /* Preguntaremos cuantos desea introducir */ int i;           /* Para bucles */ long suma=0;     /* La suma, claro */ do { printf(Cuantos numeros desea sumar? ); scanf(%d, &cuantos); datos = (int *) malloc (cuantos * sizeof(int)); if (datos == NULL)  /* Si no hay espacio, avisamos */ printf(No caben tantos datos en memoria.); } while (datos == NULL);  /* Si pide demasiado, no le dejamos */ /* Pedimos y almacenamos los datos */ for (i=0; i<cuantos; i++) { printf(Introduzca el dato n√∫mero %d: , i+1); scanf(%d, datos+i); } /* Calculamos la suma */ for (i=0; i<cuantos; i++) suma += *(datos+i); printf(Su suma es: %ld\n, suma); free(datos); return 0; } Este fuente es m√°s dif√≠cil de leer, pero a cambio es mucho m√°s eficiente: funciona perfectamente si s√≥lo queremos sumar 5 n√∫meros, pero tambi√©n si necesitamos sumar 120.000 (y si caben tantos n√∫meros en la memoria disponible de nuestro equipo, claro). Vamos a ver las diferencias: En primer lugar, lo que antes era int datos[100] que quiere decir ‚Äúa partir de la posici√≥n de memoria que llamar√© datos, querr√© espacio para a guardar 100 n√∫meros enteros‚Äù, se ha convertido en int* datos que quiere decir ‚Äúa partir de la posici√≥n de memoria que llamar√© datos voy a guardar varios n√∫meros enteros (pero a√∫n no s√© cuantos)‚Äù. Luego reservamos el espacio exacto que necesitamos, haciendo datos = (int *) malloc (cuantos * sizeof(int)); Esta orden suena complicada, as√≠ que vamos a verla por partes: ‚Äúmalloc‚Äù es la orden que usaremos para reservar memoria cuando la necesitemos (es la abreviatura de las palabra ‚Äúmemory‚Äù y ‚Äúallocate‚Äù). Como par√°metro, le indicamos cuanto espacio queremos reservar. Para 100 n√∫meros enteros, ser√≠a ‚Äú100*sizeof(int)‚Äù, es decir, 100 veces el tama√±o de un entero. En nuestro caso, no son 100 n√∫meros, sino el valor de la variable ‚Äúcuantos‚Äù. Por eso hacemos ‚Äúmalloc (cuantos*sizeof(int))‚Äù. Para terminar, ese es el espacio que queremos reservar para nuestra variable ‚Äúdatos‚Äù. Y esa variable es de tipo ‚Äúint *‚Äù (un puntero a datos que ser√°n n√∫meros enteros). Para que todo vaya bien, debemos ‚Äúconvertir‚Äù el resultado de ‚Äúmalloc‚Äù al tipo de datos correcto, y lo hacemos forzando una conversi√≥n como vimos en el apartado 2.4 (operador ‚Äúmolde‚Äù), con lo que nuestra orden est√° completa: datos = (int *) malloc (cuantos * sizeof(int)); Si ‚Äúmalloc‚Äù nos devuelve NULL como resultado (un ‚Äúpuntero nulo‚Äù), quiere decir que no ha encontrado ninguna posici√≥n de memoria en la que nos pudiera reservar todo el espacio que le hab√≠amos solicitado. Para usar ‚Äúmalloc‚Äù deberemos incluir ‚Äústdlib.h‚Äù al principio de nuestro fuente. La forma de guardar los datos que teclea el usuario tambi√©n es distinta. Cuando trabaj√°bamos con un ‚Äúarray‚Äù, hac√≠amos scanf(%d, &datos[i]) (‚Äúel dato n√∫mero i‚Äù), pero con punteros usaremos scanf(%d, datos+i) (en la posici√≥n datos + i). Ahora ya no necesitamos el s√≠mbolo ‚Äúampersand‚Äù (&). Este s√≠mbolo se usa para indicarle a C en qu√© posici√≥n de memoria debe almacenar un dato. Por ejemplo, float x; es una variable que podremos usar para guardar un n√∫mero real. Si lo hacemos con la orden ‚Äúscanf‚Äù, esta orden no espera que le digamos en qu√© variable deber guardar el dato, sino en qu√© posici√≥n de memoria. Por eso hacemos scanf(%f, &x); En el caso que nos encontramos ahora, int* datos ya se refiere a una posici√≥n de memoria (un puntero), por lo que no necesitamos & para usar ‚Äúscanf‚Äù. Finalmente, la forma de acceder a los datos tambi√©n cambia. Antes le√≠amos el primer dato como datos[0], el segundo como datos[1], el tercero como datos[2] y as√≠ sucesivamente. Ahora usaremos el asterisco (*) para indicar que queremos saber el valor que hay almacenado en una cierta posici√≥n: el primer dato ser√° *datos, el segundo *(datos+1), el tercero ser√° *(datos+2) y as√≠ en adelante. Por eso, donde antes hac√≠amos suma += datos[i]; ahora usamos suma += *(datos+i); Tambi√©n aparece otra orden nueva: free. Hasta ahora, ten√≠amos la memoria reservada est√°ticamente, lo que supone que la us√°bamos (o la desperdici√°bamos) durante todo el tiempo que nuestro programa estuviera funcionando. Pero ahora, igual que reservamos memoria justo en el momento en que la necesitamos, y justo en la cantidad que necesitamos, tambi√©n podemos volver a dejar disponible esa memoria cuando hayamos terminado de usarla. De eso se encarga la orden ‚Äúfree‚Äù, a la que le debemos indicar qu√© puntero es el que queremos liberar."
      },
      {
        "id": 41,
        "autor": "programacioniiuno",
        "pagina": "programacioniiuno",
        "fecha": "00/00/0000",
        "titulo": "Estructuras de datos definidas por el usuario en C",
        "link": "https://sites.google.com/site/programacioniiuno/temario/unidad-2---tipo-abstracto-de-dato/estructuras-de-datos-definidas-por-el-usuario-en-c",
        "contenido": "Tipos de dato y relaci√≥n con checkeos Hasta ahora ven√≠an (ven√≠amos) trabajando con problemas simples de programaci√≥n para familiarizarnos con los conceptos b√°sicos de la programaci√≥n estructura, como secuencia de instrucciones, iteraciones (for, while, etc) y decisiones (if, switch, etc). Adem√°s de variables, funciones, asignaciones, etc. Otra cosa que vimos es el proceso que sufre un programa para que, a partir del c√≥digo fuente como lo escribimos, se transforme en algo ejecutable. Por ejemplo, a trav√©s de la compilaci√≥n. En los lenguajes compilados, existen entonces 2 etapas: la compilaci√≥n que sucede durante el desarrollo o escritura del c√≥digo, y luego la ejecuci√≥n del c√≥digo compilado. Existe entonces en algunos lenguajes, la idea de poder atajar los problemas cuanto antes, en ese primer paso, mediante checkeos en tiempo de compilaci√≥n. En general si bien existen variantes (como duck-typing o tipos estructurales), lo m√°s tradicional es que estos checkeos se basen en informaci√≥n de tipos. Qu√© es un tipo ? Tipo de dato inform√°tico es un atributo de una parte de los datos que indica al ordenador (y/o al programador) algo sobre la clase de datos sobre los que se va a procesar. Esto incluye imponer restricciones en los datos, como qu√© valores pueden tomar y qu√© operaciones se pueden realizar. Tipos de datos comunes son: enteros, n√∫meros de coma flotante (decimales), cadenas alfanum√©ricas, fechas, horas, colores, etc. De Wikipedia. Qu√© es un struct ? Algo interesante del concepto de tipo es que permite una abstracci√≥n, es decir, cuando decimos float, ya todos pensamos en ciertas condiciones que va a tener el contenido de esa variable (n√∫mero decimal). M√°s all√° de que luego todo termine representado como bytes internamente. Los bytes quedan escondidos para nosotros, porque el hecho de que existan es un tema de implementaci√≥n o representaci√≥n. No es necesario saber c√≥mo se guarda el float, porque lo que necesitamos es poder usarlo (sumarlo, restarlo, etc). Este concepto de abstracci√≥n estar√≠a bueno poder extenderlo, no solo para utilizar los tipos b√°sicos como int, float, char, etc, si no, para poder tambi√©n nosotros crear abstracciones, por ejemplo que un Producto, tenga c√≥digo y precio, y as√≠ no tener que pasar variables sueltas por todas nuestras funciones. Si el d√≠a de ma√±ana queremos agregar una caracter√≠stica a nuestros productos, no tendr√≠amos que modificar todas las funciones que lo utilizan. Un struct en C es una forma de agrupar miembros, es decir variables, bajo un mismo nombre. Definici√≥n y uso de un Struct struct Producto { long codigo; float precio; }; Estamos definiendo ac√° un struct con identificador Producto, que tiene dos miembros: con nombre y tipo. Luego para utilizarlo: struct Producto unProducto; unProducto.codigo = 123456789L; unProducto.precio = 2.50; printf(Producto con codigo %lu y precio $%.2f, unProducto.codigo, unProducto.precio); Ac√° estamos declarando una variable de tipo struct Producto, que se llama unProducto. Al declarar la variable C autom√°ticamente aloca espacio en memoria para el struct. El tama√±o que ocupa un struct es el tama√±o de sus miembros. Es decir que se aloca memoria para sus miembros autom√°ticamente. No hace falta alocar con malloc din√°micamente. Otra cosa que vemos ac√° es que con el punto (.), accedemos a los miembros del struct. Structs y funciones Los structs se pueden utilizar para tipar variables, con lo que podemos utilizarlos en la declaraci√≥n de funciones. Entonces, si quisi√©ramos hacer una funci√≥n para imprimir productos, no har√≠a falta pasar todas sus propiedades como par√°metros, sino un solo par√°metro de tipo struct Producto. Esto: void imprimir(long codigo, float precio) { printf(Producto con codigo %lu y precio $%.2f, codigo, precio); } Pasar√≠a a esto: void imprimir(struct Producto unProducto) { printf(Producto con codigo %lu y precio $%.2f, unProducto.codigo, unProducto.precio); } Como consecuencia tenemos un c√≥digo m√°s legible, ya que en el primer caso, la funci√≥n no expresa claramente en su firma (m√©todo y par√°metros) que es para imprimir un producto. Por otro lado, acoplamos m√°s fu√©rtemente la nueva funci√≥n al tipo Producto. Es l√≥gico, porque es una consecuencia de lo que quer√≠amos. Pero bueno, veamos que antes el imprimir pod√≠a ser utilizado para cualquier cosa, no solo para un Producto. No as√≠, ahora. Necesito un struct Producto. Punteros a structs y pasaje por referencia Como vimos en Punteros, Referencias y Direcciones el pasaje de par√°metros en C es siempre por valor. Es decir que los par√°metros se copian al scope de la nueva funci√≥n. Por lo tanto, las modificaciones no toman efecto sobre las variables del que invoc√≥ a la funci√≥n. Ahora qu√© pasa cuando pasamos por par√°metro un struct ? void aumentarPrecio(struct Producto producto) { producto.precio += 0.5; } Si hacemos... aumentarPrecio(unProducto); imprimir(unProducto); Vamos a ver que imprime en pantallas... Producto con codigo 123456789 y precio $2.50 Producto con codigo 123456789 y precio $2.50 Es decir que al igual que con un par√°metro simple, si modificamos uno de los miembros de un struct que se pas√≥ por valor, tampoco toma efecto. Esto es porque tambi√©n se hace una copia del struct completo al pasarlo por par√°metro, Esto se resuelve de la misma forma que ya vimos, pas√°ndo un puntero al struct Modificamos la funci√≥n entonces para que reciba un puntero al struct. void aumentarPrecio(struct Producto *producto) { producto->precio += 0.5; } Y vamos a notar que ya no vamos a poder hacer: producto.precio, esto es porque producto es ahora un puntero, no el struct en s√≠. Para poder acceder a uno de sus miembros deber√≠amos primer desreferenciar el puntero con * y luego acceder al miembro, as√≠: (*producto).precio Pero C ya tiene otro operador para simplificar la sintaxis de esto, que es el -> producto->precio Con este cambio, ahora el main va a imprimir corr√©ctamente: Producto con codigo 123456789 y precio $2.50 Producto con codigo 123456789 y precio $3.00 TypeDef En C podemos definir tipos como aliases a otros tipos. Es decir, definir otro nombre para un tipo ya existente. El objetivo de esto es poder tener un c√≥digo m√°s legible. Donde legible quiere decir que sea m√°s f√°cil de entender para quien no lo escribi√≥, pero conoce el dominio. O tambi√©n para quien quiz√°s si sabe programar, pero no conoce el dominio. Veamos un ejemplo primero del typedef. Declaramos un nuevo tipo pesos que es en realidad un float typedef float pesos; int main() { pesos miSaldo = 33.5; printf(Mi saldo es %.2f, miSaldo); } Luego lo usamos en la variable miSaldo. Es importante se√±alar que la variable sigue teniendo el mismo tipo de dato original, es decir, es un float. Y puedo pasarla como par√°metro de tipo float a cualquier funci√≥n. Y lo mismo si fuera valor de retorno. En cualquier momento yo puedo elegir usar float o pesos, y no se hacen checkeos ni habr√° incompatibilidades de tipos. Veamos un ejemplo un poquito m√°s grande para enteder c√≥mo afecta la claridad del c√≥digo. Un main con una funci√≥n para convertir de pesos a dolares: float pesosADolares(float pesos) { return pesos * 5; } int main(void) { float saldoPesos = 3.2; float saldoDolares = pesosADolares(saldoPesos); printf(Usted tiene $ %.2f (que equivalen a U$S %.2f), saldoPesos, saldoDolares); } Con typedef quedar√≠a: typedef float dolar; typedef float pesos; dolar pesosADolares(pesos pesos) { return pesos * 5; } int main(void) { pesos saldoPesos = 3.2; dolar saldoDolares = pesosADolares(saldoPesos); printf(Usted tiene $ %.2f (que equivalen a U$S %.2f), saldoPesos, saldoDolares); } De hecho podr√≠amos pensar en reducir el nombre de la funci√≥n ya que el uso de typedefs hace m√°s clara su intenci√≥n: dolar convertir(pesos pesos) { return pesos * 5; } Cuanto m√°s mi c√≥digo se parece a una definici√≥n del dominio, m√°s f√°cil de entender, mantener y modificar. Existen muchas buenas pr√°cticas de c√≥digo que se dice que aportan a una caracter√≠stica del c√≥digo llamada Intention Revealing, por ej: Definir nombres claros para las variables, en lugar de cosas como: ptr, var1, var2, tmp, etc Evitar comentarios de c√≥digo y en su lugar separar las partes en funciones chiquitas usando el nombre de la funci√≥n para expresar qu√© es lo que hace. El uso de structs para definir abstracciones de nuestro negocio en lugar de utilizar variables sueltas Y la que vemos ac√°, usar aliases de tipos o nuestros propios tipos en lugar de tipos b√°sicos dispersos por todo nuestro c√≥digo. Pueden ver un ejemplito simple y una buena descripci√≥n en wikipedia Intentional Programming Typedef's para structs Como vimos los structs tambi√©n definen un tipo de dato. Uno compuesto. Asign√°ndole un nombre a un grupo de miembros de diversos tipos. Pero vimos que para tipar una variable con uno de estos structs, o un par√°metro de funci√≥n, etc, deb√≠amos escribir struct Producto, y no solo el nombre del struct (Producto). Si queremos hacer eso mismo, debemos definir un typedef al struct. Ejemplo sin typedef struct Producto elDeMenorPrecio(struct Producto productos[]) { ... } Y con typedef typedef struct Producto Producto; Producto elDeMenorPrecio(Producto productos[]) { ... }"
      },
      {
        "id": 42,
        "autor": "Hugo Delgado",
        "pagina": "Akus.net",
        "fecha": "26/03/2020",
        "titulo": "Estructuras y Uniones en C - Arrays de estructuras",
        "link": "https://disenowebakus.net/estructuras.php",
        "contenido": "Concepto de estructura Una estructura es un conjunto de una o m√°s variables, de distinto tipo, agrupadas bajo un mismo nombre para que su manejo sea m√°s sencillo. Su utilizaci√≥n m√°s habitual es para la programaci√≥n de bases de datos, ya que est√°n especialmente indicadas para el trabajo con registros o fichas. La sintaxis de su declaraci√≥n es la siguiente: struct tipo_estructura { tipo_variable nombre_variable1; tipo_variable nombre_variable2; tipo_variable nombre_variable3; }; Donde tipo_estructura es el nombre del nuevo tipo de dato que hemos creado. Por √∫ltimo, tipo_variable y nombre_variable son las variables que forman parte de la estructura. Para definir variables del tipo que acabamos de crear lo podemos hacer de varias maneras, aunque las dos m√°s utilizadas son √©stas: UNA FORMA DE DEFINIR LA ESTRUCTURA: struct trabajador { char nombre[20]; char apellidos[40]; int edad; char puesto[10]; }; struct trabajador fijo, temporal; OTRA FORMA struct trabajador { char nombre[20]; char apellidos[40]; int edad; char puesto[10]; }fijo, temporal; En el primer caso declaramos la estructura, y en el momento en que necesitamos las variables, las declaramos. En el segundo las declaramos al mismo tiempo que la estructura. El problema del segundo m√©todo es que no podremos declarar m√°s variables de este tipo a lo largo del programa. Para poder declarar una variable de tipo estructura, la estructura tiene que estar declarada previamente. Se debe declarar antes de la funci√≥n main. El manejo de las estructuras es muy sencillo, as√≠ como el acceso a los campos ( o variables ) de estas estructuras. La forma de acceder a estos campos es la siguiente: variable.campo; Donde variable es el nombre de la variable de tipo estructura que hemos creado, y campo es el nombre de la variable que forma parte de la estructura. temporal.edad=25; Lo que estamos haciendo es almacenar el valor 25 en el campo edad de la variable temporal de tipo trabajador. Otra caracter√≠stica interesante de las estructuras es que permiten pasar el contenido de una estructura a otra, siempre que sean del mismo tipo naturalmente: fijo=temporal; Al igual que con los otros tipos de datos, tambi√©n es posible inicializar variables de tipo estructura en el momento de su declaraci√≥n: struct trabajador fijo={Pedro,Hern√°ndez Su√°rez, 32, gerente}; Si uno de los campos de la estructura es un array de n√∫meros, los valores de la inicializaci√≥n deber√°n ir entre llaves: struct notas { char nombre[30]; int notas[5]; }; struct notas alumno={Carlos P√©rez,{8,7,9,6,10}}; Estructuras y funciones Podemos enviar una estructura a una funci√≥n de las dos maneras conocidas: Por valor: su declaraci√≥n ser√≠a: void visualizar(struct trabajador); Despu√©s declarar√≠amos la variable fijo y su llamada ser√≠a: visualizar(fijo); Por √∫ltimo, el desarrollo de la funci√≥n ser√≠a: void visualizar(struct trabajador datos) EJEMPLO /* Paso de una estructura por valor. */ #include <stdio.h> struct trabajador { char nombre[20]; char apellidos[40]; int edad; char puesto[10]; }; void visualizar(struct trabajador); main() /* Rellenar y visualizar */ { struct trabajador fijo; printf(Nombre: ); scanf(%s,fijo.nombre); printf(\nApellidos: ); scanf(%s,fijo.apellidos); printf(\nEdad: ); scanf(%d,&fijo.edad); printf(\nPuesto: ); scanf(%s,fijo.puesto); visualizar(fijo); } void visualizar(struct trabajador datos) { printf(Nombre: %s,datos.nombre); printf(\nApellidos: %s,datos.apellidos); printf(\nEdad: %d,datos.edad); printf(\nPuesto: %s,datos.puesto); } Por referencia: su declaraci√≥n ser√≠a: void visualizar(struct trabajador *); Despu√©s declararemos la variable fijo y su llamada ser√° visualizar(&fijo); Por √∫ltimo, el desarrollo de la funci√≥n ser√°: void visualizar(struct trabajador *datos) F√≠jate que en la funci√≥n visualizar, el acceso a los campos de la variable datos se realiza mediante el operador ->, ya que tratamos con un puntero. En estos casos siempre utilizaremos el operador ->. Se consigue con el signo menos seguido de mayor que. EJEMPLO /* Paso de una estructura por referencia. */ #include <stdio.h> struct trabajador { char nombre[20]; char apellidos[40]; int edad; char puesto[10]; }; void visualizar(struct trabajador *); main() /* Rellenar y visualizar */ { struct trabajador fijo; printf(Nombre: ); scanf(%s,fijo.nombre); printf(\nApellidos: ); scanf(%s,fijo.apellidos); printf(\nEdad: ); scanf(%d,&fijo.edad); printf(\nPuesto: ); scanf(%s,fijo.puesto); visualizar(&fijo); } void visualizar(struct trabajador *datos) { printf(Nombre: %s,datos->nombre); printf(\nApellidos: %s,datos->apellidos); printf(\nEdad: %d,datos->edad); printf(\nPuesto: %s,datos->puesto); } Arrays de estructuras Es posible agrupar un conjunto de elementos de tipo estructura en un array. Esto se conoce como array de estructuras: EJEMPLO struct trabajador { char nombre[20]; char apellidos[40]; int edad; }; struct trabajador fijo[20]; As√≠ podremos almacenar los datos de 20 trabajadores. Ejemplos sobre como acceder a los campos y sus elementos: para ver el nombre del cuarto trabajador, fijo[3].nombre;. Para ver la tercera letra del nombre del cuarto trabajador, fijo[3].nombre[2];. Para inicializar la variable en el momento de declararla lo haremos de esta manera: struct trabajador fijo[20]={{Jos√©,Herrero Mart√≠nez,29},{Luis,Garc√≠a S√°nchez,46}}; Typedef Es posible agrupar un conjunto de elementos de tipo estructura en un array. Esto se conoce como array de estructuras: El lenguaje 'C' dispone de una declaraci√≥n llamada typedef que permite la creaci√≥n de nuevos tipos de datos. Ejemplos: typedef int entero; /* acabamos de crear un tipo de dato llamado entero */ entero a, b=3; /* declaramos dos variables de este tipo */ Su empleo con estructuras est√° especialmente indicado. Se puede hacer de varias formas: UNA FORMA DE HACERLO: struct trabajador { char nombre[20]; char apellidos[40]; int edad; }; typedef struct trabajador datos; datos fijo,temporal; OTRA FORMA: typedef struct { char nombre[20]; char apellidos[40]; int edad; }datos; datos fijo,temporal; CITAR ART√çCULO Para tareas, investigaciones, tesis, libros, revistas, blogs √≥ art√≠culos acad√©micos Referencia en Formato APA: Delgado, Hugo. (2020). Estructuras y Uniones en C - Arrays de estructuras. Recuperado 23 de mayo, 2021, de https://disenowebakus.net/estructuras.php"
      },
      {
        "id": 43,
        "autor": "Isaac",
        "pagina": "ArchiTecnologia",
        "fecha": "27/11/2019",
        "titulo": "Programaci√≥n: estructura de un programa C ‚Äì Parte 2",
        "link": "https://architecnologia.es/programacion-estructura-de-un-programa-c-parte-2",
        "contenido": "Segunda parte de la serie de entradas que explican la estructura de un programa en lenguaje C dentro de la serie Programaci√≥n. Una vez ya tienes claro la diferencia entre los paradigmas de la programaci√≥n estructurada versus la programaci√≥n orientada a objetos, ahora vamos a ver los conceptos b√°sicos y c√≥mo se distribuye un c√≥digo fuente y los algoritmos para C. Algo b√°sico si quieres ser un ¬´arquitecto¬ª de programas y que suele obviarse en muchos cursos y manuales‚Ä¶ Cuando escribes tu primer ¬´Hola Mundo¬ª, simplemente copias las instrucciones o pones ciertas partes del c√≥digo ah√≠ porque lo has le√≠do en otro lugar. Pero ¬ørealmente sabes cu√°l es la funci√≥n de cada parte? Tal vez muchos simplemente entiendan la funci√≥n printf() que es la que muestra el mensaje en pantalla. Pero sin el resto que la acompa√±a, el programa no funcionar√≠a. Es decir, tal vez te hayan ense√±ado, o hayas aprendido de forma autodidacta, la parte menos trascendental de todas las que aparecen. De hecho, esa funci√≥n no ser√≠a nada sin la cabecera stdio.h que has incluido al inicio del c√≥digo. Estructura de datos y de control Ya sabes que el paradigma de programaci√≥n estructurada se compone de una estructura de datos y otra de control, algo as√≠ como los paths datos y control de una CPU si te gusta la serie Microarquitectura de este blog. Los datos ya sabes que son simplemente el conjunto de datos (constantes, variables,‚Ä¶) que se manejan o almacenan durante la ejecuci√≥n del programa. En cambio, la estructura de control es la que controla c√≥mo se va a ejecutar el programa. Esta estructura de control son una serie de instrucciones ordenadas. La forma de ordenarlas es clave dentro de este paradigma, ya que solo cuentan con un solo punto de entrada y un punto de salida. Dentro de estas estructuras existen varios tipos: Secuenciales:  las instrucciones se ejecutan en orden, desde la primera a la √∫ltima, sin saltar ninguna. Selectivas: evaluando si una condici√≥n es verdadera o falsa, se elige una opci√≥n (una o varias instrucciones). De iteraci√≥n: una acci√≥n que se repite una cantidad de veces definida o indefinidamente. Ser√° una condici√≥n la que determine hasta cuando. Todas estas estructuras se mezclan y combinan para componer los programas., aunque algunos programas sencillos puedan usar solo alg√∫n tipo concreto, pero no es lo normal. Estructura del algoritmo y del c√≥digo Si recuerdas art√≠culos previos, dije que saber crear un algoritmo o usar pseudoc√≥digo puede ser vital para saber dise√±ar un programa desde cero. Algunos cursos y manuales simplemente se basan en darte snippets de c√≥digo para que los copies, los pruebes, o los modifiques. Pero cuando terminas ese curso, e intentas dise√±ar un programa por ti mismo, no sabes ni por donde empezar. Estar√°s completamente perdido y lo que intentar√°s hacer es buscar otro ejemplo de c√≥digo fuente que te pueda servir  de base‚Ä¶ ¬øY si no existe porque lo que intentas hacer es novedoso? ¬°Te quedas anclado! Otro de los escoyos que encuentras a la hora de crear un programa es la de no saber c√≥mo escribirlo cuando no usas otro c√≥digo como referencia, puesto que no te han ense√±ado c√≥mo se estructura y para qu√© sirve cada parte. Vamos a ver un ejemplo de pseudoc√≥digo en C para ir luego desgranando cada parte: //Comentario de una sola l√≠nea /*Comentarios cuando ocupan m√°s de una l√≠nea para determinar d√≥nde est√° el comienzo y donde se encuentra el final. En estos comentarios del inicio se suele especificar para qu√© sirve el programa o algunos datos de inter√©s para mantenedores, consideraciones, etc.*/ #include <stdio.h>    //Declaraci√≥n de las cabeceras o bibliotecas a incluir. #include <conio.h> void bienvenido(char nombre):  //Prototipo de funciones char nombre[100];   //Declaraci√≥n de variables y constantes globales main()  //Programa principal { int num1, num2, suma;   //Declaraci√≥n de variables y constantes locales printf(Introduce un nombre:\n);    //Funciones o instrucciones... El cuerpo del programa scanf(%s, &nombre); printf(Introduce un n√∫mero:\n); scanf(%d, &num1); printf(Introduce otro n√∫mero:\n); scanf(%d, &num2); suma=num1+num2; bienvenido(nombre);     //Llamada a la funci√≥n printf(La suma es: %d, suma); getch(); return(); } void bienvenido(char nombre[])    //Declaraci√≥n de funciones { printf(\n Un saludo %s, nombre);           //Otro m√≥dulo getch(); } Ahora ir√© desglosando parte a parte de este ejemplo simple: Comentarios: pueden ir en cualquier parte del programa y a estas alturas deber√≠as saber c√≥mo introducirlos de entradas previas de esta serie de Programaci√≥n. Si van al principio suelen ser referentes a la descripci√≥n del programa, consideraciones importantes, etc. Y si van a lo largo del programa ser√°n comentarios sobre lo que hace una determinada parte, etc. Ya sabes que estos comentarios ser√°n ignorados por el compilador, es decir, no tienen efecto, pero sirve para todos los que lean el c√≥digo con fines de modificarlo o mantenerlo. Declaraci√≥n de cabeceras: se incluyen las bibliotecas donde se encuentran las funciones que se van a usar durante el programa, como stdio.h que contiene definida la funci√≥n printf, etc. Tambi√©n se pueden declarar funciones, variables, constantes, etc. Ya lo vimos en unos art√≠culos previos si recuerdas lo que era el Precompilador. Prototipo de funciones: en este caso no llevan el .h, pero avisan igualmente al compilador que existe una funci√≥n que va a regresar un determinado tipo de dato y qu√© par√°metros va a usar. Declaraci√≥n de variables y constantes: pueden ser globales, que se van a usar en todo el programa, es decir, en todas esas partes o m√≥dulos, pero tambi√©n las hay locales. En el caso de las locales, solo se usar√°n en una parte espec√≠fica. Se pueden declarar en cualquier parte, aunque se recomienda hacerlo al principio. Por cierto, esto es lo que pertenece a esa estructura de datos de la que hablamos‚Ä¶ Funci√≥n o programa principal: en este caso main() que lo puedes encontrar con varios formatos. Es la parte por la que debe comenzar el programa por tanto, avisa al compilador de la forma en la que ordenar√° las instrucciones del binario resultante. Esta funci√≥n contendr√° sus instrucciones de control y datos entre {}, formando el cuerpo principal del programa. Ya sabes que todo lo que vaya delante del return(0), que pone fin, y cuando finaliza con √©xito no devolver√° nada en este caso. En caso contrario aparecer√≠a un c√≥digo de error. En programas complejos se recomienda sustituir el return(0) por EXIT_SUCESS;, pero esto ya lo veremos m√°s adelante‚Ä¶ En ocasiones puedes encontrar solo main(), otras int main(), void main(), int main(void), etc., en funci√≥n de si devuelve un valor num√©rico, un valor vac√≠o, etc. Casi siempre suelen estar vac√≠as o con void, que al caso es igual, pero no siempre lo est√°n. Por ejemplo cuando el programa debe devolver alg√∫n valor al sistema operativo o a una aplicaci√≥n. Algunos compiladores pueden no aceptar algunos de estos formatos‚Ä¶ Declaraci√≥n de funciones: las sentencias o funciones con las que trabajar√° el programa y que las crea el propio programador, es decir, no son como printf y similares, que se encuentran definidas en los archivos de cabecera (prefabricadas). En este caso se crean desde cero. Aunque no es estrictamente necesario, ya que lo √∫nico fundamental para un programa es la cabecera y funci√≥n main(). Espero que ahora lo tengas un poco m√°s claro‚Ä¶"
      },
      {
        "id": 44,
        "autor": "Aula Facil",
        "pagina": "Aula Facil",
        "fecha": "00/00/2021",
        "titulo": "Introducir y leer datos de la estructura",
        "link": "https://www.aulafacil.com/cursos/programacion/lenguaje-de-programacion-c/introducir-y-leer-datos-de-la-estructura-l17635",
        "contenido": "Introducir y leer datos de la estructura Veamos ahora como introducir los datos de todos los alumnos de forma sencilla y luego mostrar estos datos por pantalla. Para que el ejemplo no se haga tan extenso, hagamos un poco m√°s peque√±a la estructura, solo pondremos el nombre y la edad de cada alumno: 38-1 Una vez modificada la estructura vamos a la funci√≥n main, donde crearemos un array de 3 alumnos e introduciremos todos sus datos. Como imaginar√©is, lo ideal tanto para introducir datos como para leerlos es hacerlo a trav√©s de bucles, para no tener que repetir instrucciones. 38-2 Lo primero, crear un array de 3 alumnos: struct estructura_alumnos alumnos[3]; Con esta instrucci√≥n tenemos dicho array. Ahora vamos a introducir los datos de todos los alumnos con un bucle for: //Bucle para introducir todos sus datos for (int i = 0; i < 3; i++) { printf(Introduce nombre del alumno %i: , i+1); gets(alumnos[i].nombre); //gets lee incluso espacios en String printf(Introduce edad del alumno %i: , i+1); scanf(%i, &alumnos[i].edad); //Recoge la edad while(getchar()!='\n'); //Bucle que vac√≠a buffer de entrada } El bucle tiene que ir desde 0 a 3. Y dentro del bucle pedimos al usuario que introduzca nombre y edad de los alumnos. gets(alumnos[i].nombre); Utilizamos la funci√≥n gets para introducir los nombres. Para acceder al alumno i se hace con los corchetes, como en cualquier array. Y luego ., y detr√°s del punto escribimos el nombre de la variable de la estructura en la que queremos introducir el dato. En este caso ser√≠a .nombre y .edad. Esta l√≠nea nos sirve para vaciar el buffer de entrada del programa: while(getchar()!='\n'); Sin esta l√≠nea no funcionar√≠a bien la inclusi√≥n de datos. Es necesario ponerla; para comprenderla hace falta saber m√°s sobre C, pero ahora mismo no nos incumbe. Ya tenemos la estructura con los datos introducidos por el usuario. Ahora solo nos queda leer los datos de todos los alumnos, de nuevo con un bucle for para recorrer todo el array. //LEER LOS DATOS DE LOS ALUMNOS for (int i = 0; i < 3; i++) { printf(\nALUMNO %i \n, i+1); //Muestra numero de alumno printf(Nombre: %s\n, alumnos[i].nombre); //Nombre de dicho alumno printf(Edad: %i \n\n, alumnos[i].edad); //Edad de dicho alumno } A trav√©s de los printf se muestran los datos como venimos haciendo durante todo el curso. Lo √∫nico que tenemos que saber es que para acceder a los datos hay que poner el . detr√°s del array, seguido del nombre del dato que queramos leer. Para que quede m√°s bonito hemos puesto el n√∫mero de alumno que est√° mostrando. Mostramos el alumno i+1 para que no se muestre alumno 0, ya sab√©is. El c√≥digo del programa lo ten√©is aqu√≠: Descargar LeerEstructuras.cpp Y el v√≠deo de muestra:"
      },
      {
        "id": 45,
        "autor": "Marcela Sena",
        "pagina": "Medium",
        "fecha": "31/01/2019",
        "titulo": "Estructuras de Datos",
        "link": "https://medium.com/techwomenc/estructuras-de-datos-a29062de5483",
        "contenido": "Lo primero que debemos tener claro es la definici√≥n de ‚Äúestructura de datos‚Äù y que a partir de esta definici√≥n parten otros conceptos y tipos. Que las estructuras de datos se estudian como conceptos sobre programaci√≥n, y no sobre un lenguaje de programaci√≥n en espec√≠fico, por lo que cada lenguaje puede tener diferentes implementaciones de estructuras de datos. En este post no cubrir√© el tema de complejidad algor√≠tmica de las estructuras, pero si mencionar√© conceptos que hacen referencia a dicha complejidad, sin llegar a fondo. Estructuras de Datos Una ‚Äúestructura de datos‚Äù es una colecci√≥n de valores, la relaci√≥n que existe entre estos valores y las operaciones que podemos hacer sobre ellos; en pocas palabras se refiere a c√≥mo los datos est√°n organizados y c√≥mo se pueden administrar. Una estructura de datos describe el formato en que los valores van a ser almacenados, c√≥mo van a ser accedidos y modificados, pudiendo as√≠ existir una gran cantidad de estructuras de datos. Lo que hace espec√≠fica a una estructura de datos es el tipo de problema que resuelve. Algunas veces necesitaremos una estructura muy simple que s√≥lo permita almacenar 10 n√∫meros enteros consecutivamente sin importar que se repitan y que podamos acceder a estos n√∫meros por medio de un √≠ndice, porque nuestro problema a resolver est√° basado en 10 n√∫meros enteros solamente. O tal vez nos interese almacenar N cantidad de n√∫meros enteros y que se puedan ordenar al momento de insertar uno nuevo, por lo que necesitaremos una estructura m√°s flexible. ¬øPor qu√© son √∫tiles las estructuras de datos? Las estructuras de datos son √∫tiles porque siempre manipularemos datos, y si los datos est√°n organizados, esta tarea ser√° mucho m√°s f√°cil. Considera el siguiente problema: ¬øDe qu√© forma puedo saber si una palabra tiene exactamente las mismas letras que otra palabra? O dicho de otra forma, ¬øc√≥mo saber si una palabra es una permutaci√≥n de otra palabra?. Si queremos resolver este problema con papel y l√°piz, basta con escribir las palabras y visualmente identificar si ambas palabras tienen las mismas letras, una forma r√°pida es contar mentalmente el n√∫mero de cada tipo de letra en ambas palabras y si tienen el mismo n√∫mero entonces si es una permutaci√≥n. Como resolver el problema de permutaci√≥n de palabras en papel Pero si quisi√©ramos resolverlo mediante programaci√≥n tenemos que decirle a la computadora como saber que es una palabra y decirle c√≥mo debe comparar las palabras de la misma forma en que lo resolvimos en papel y l√°piz, ¬øSe te ocurre alguna forma?. Qu√© tal si pensamos en las palabras como una estructura de casillas de letras secuenciales (array √≥ arreglo) donde cada letra representa una casilla en esta estructura. A cada casilla le damos un √≠ndice con el cual podemos acceder a ella para saber qu√© letra tiene contenida, esto le indicar√° a la computadora c√≥mo reconocer una palabra. Estructura de datos array Ahora, para resolver el problema debemos saber c√≥mo comparar las palabras y sus letras, lo primero que podemos evaluar es el length √≥ longitud de la palabra, o sea, cu√°ntos caracteres tiene; si las palabras tienen diferente n√∫mero de caracteres entonces no tiene sentido comparar m√°s, ya sabemos que NO tendr√°n exactamente las mismas letras. Lo siguiente ser√° contar las letras por tipo de letra. En el ejemplo anterior de las palabras ‚Äúcasa‚Äù y ‚Äúsaca‚Äù contamos las letras mentalmente, pero las escribimos en el papel con una estructura muy espec√≠fica, cada letra que encontramos se asocia al n√∫mero que contamos; entonces, ¬øhabr√° alguna estructura de datos que me ayude a asociar las letras con el n√∫mero que contamos?, la respuesta es s√≠. Podemos pensar en esta asociaci√≥n como una estructura de tipo key-value (llave-valor) llamada dictionary √≥ diccionario, donde la letra es la llave y su valor asociado es el n√∫mero contado; adem√°s, en esta estructura no debemos repetir la llave porque de lo contrario tendremos letras repetidas y no podremos contar, es por eso que la estructura dictionary es distinta al array, ya que en el array si podemos repetir letras, pero en esta otra estructura no deber√≠amos permitirlo ya que eso ser√≠a lo que nos permita resolver el problema de contar. Estructura de datos map De modo que para operar la estructura array tenemos que hacerlo recorriendo una a una todas las casillas para obtener las letras mediante su √≠ndice; la casilla 0 contiene a la letra ‚Äúc‚Äù, la casilla 1 contiene la letra ‚Äúa‚Äù y as√≠ sucesivamente. Para el caso de la estructura dictionary podemos decir que vamos a operar en ella a trav√©s de su key (llave); la llave ‚Äúc‚Äù tiene asociado el valor 1, la llave ‚Äúa‚Äù tiene asociado el valor 2, y as√≠ sucesivamente. Cada vez que encontremos una letra la pondremos en la estructura dictionary, si no existe se agrega y se asocia con el valor 1, s√≠ ya existe entonces ‚Äúcontamos‚Äù y a su valor le sumamos +1. Hasta este punto las estructuras de datos nos han ayudado a resolver este problema con el simple hecho de tener nuestros valores organizados y definiendo la forma en la que podemos operar sobre ellos; a√∫n quedan varios pasos m√°s para resolver el problema por completo pero eso pasa a ser objeto de otro tema en programaci√≥n que son los algoritmos. Por ahora nos basta con identificar las estructuras de datos. Tipos de estructuras de datos Al hablar de estructuras de datos debemos pensar en primera instancia en c√≥mo los datos se representan en la memoria, ¬øse trata de estructuras contiguas o enlazadas?, al partir de esta pregunta podemos darnos la idea correcta sobre la base de nuestra estructura y c√≥mo es que los datos se van a almacenar. Las estructuras contiguamente asignadas est√°n compuestas de bloques de memoria √∫nicos, e incluyen a los arrays, matrices, heaps, y hash tables. Las estructuras enlazadas est√°n compuestas de distintos fragmentos de memoria unidos por pointers √≥ punteros, e incluyen a los lists, trees, y graphs. Los contenedores son estructuras que permiten almacenar y recuperar datos en un orden determinado sin importar su contenido, en esta se incluyen los stacks y queues. Debo aclarar que esta es una clasificaci√≥n muy espec√≠fica basada en el libro ‚ÄúThe Algorithm Design Manual de Steven S. Skiena‚Äù, despu√©s de leer distintas clasificaciones esta es la que se me hizo m√°s sencilla y f√°cil de comprender. En internet podr√°n encontrar una lista larga de estructuras de datos, sin embargo en este post s√≥lo abarcaremos las mas conocidas y esenciales para entender este concepto, ¬°Comenzamos!. Array Esta estructura es ‚Äúla‚Äù fundamental de las estructuras contiguamente asignadas. Arrays √≥ arreglos son estructuras de datos de tama√±o fijo de modo que cada elemento puede ser eficientemente ubicado por su index (√≠ndice) √≥ direcci√≥n. Exactamente como lo vimos en el ejemplo anterior un array tiene una tama√±o fijo y una direcci√≥n (index) con la cual podemos localizar de forma r√°pida un elemento en el arreglo, de modo que podemos apuntar a un elemento en el array de la siguiente forma: array[index], donde array es el nombre de nuestra estructura, seguida de dos ‚Äúcorchetes‚Äù que abren y cierran, donde especificamos el index que deseamos apuntar. Un array uni-dimensional con 6 elementos Los arrays muestran algunas ventajas con respecto a otras estructuras, como por ejemplo: Al tener un espacio contiguo en memoria cada index de cada elemento del array apunta directamente a una direcci√≥n de memoria, de esta forma podemos acceder arbitrariamente a los datos de forma instant√°nea puesto que sabemos la direcci√≥n de memoria exacta. Esto deriva en un acceso de tiempo constante dado por los index. Los arrays son puramente datos lo que significa que no es necesario desperdiciar espacio en memoria almacenando informaci√≥n extra que ayude a la localizaci√≥n de sus elementos como es el caso de las estructuras enlazadas, los arrays tienen eficiencia de espacio. Localidad de memoria, es com√∫n que en la programaci√≥n los datos de una estructura sean iterados (o recorridos) y los arrays son buenos para esto ya que exhiben excelente localizaci√≥n de memoria, permiti√©ndonos aprovechar la alta velocidad de la cach√© en computadoras modernas. Ejemplo de como crecer un dynamic array La gran desventaja de los arrays es que no podemos ajustar su tama√±o a la mitad de la ejecuci√≥n de un programa, pero ¬øy qu√© tal si creamos uno nuevo con la nueva dimensi√≥n deseada?; esto ser√≠a bueno si supi√©ramos el tama√±o que deseamos todo el tiempo, pero si no lo sabemos s√≥lo tenemos 2 opciones: crear una array lo suficientemente grande para almacenar nuestros datos, pero esto deriva en un desperdicio de memoria totalmente innecesario, √≥ podemos crear un nuevo array, doblar el tama√±o de √©ste cada vez que se necesite crecer y copiar los datos del array anterior al nuevo array, hacer esto tiene el mismo nivel de complejidad que si tuvi√©ramos un array √∫nico suficientemente grande, pero con la ventaja de que s√≥lo va a crecer cu√°ndo sea necesario, evitando as√≠ desperdiciar memoria. Es pues que de esta forma podemos alargar un array en tiempo de ejecuci√≥n, a este concepto se le conoce como dynamic arrays √≥ arreglos din√°micos. Los arrays son la base de muchos otros tipos de estructuras de datos como acabamos de ver con los arreglos din√°micos. Otra estructura muy com√∫n que nos ayuda a representar datos reales son las llamadas matrices o tablas que no son mas que arrays de m√∫ltiples dimensiones. Pensemos, si un arreglo es una colecci√≥n consecutiva de valores, se puede decir que son de tipo lineal en una dimensi√≥n plana √≥ uni-dimensionales, si quisi√©ramos formar una matriz o tabla (matrix o table) podr√≠amos crear un array bi-dimensional, lo que quiere decir que tendremos que localizar a un elemento por su index [i , j], o bien su ubicaci√≥n lineal a la derecha y hacia abajo como en un plano cartesiano con dimensiones xy asemejando a una tabla, o podr√≠amos crear un array tri-dimensional, agregando una dimensi√≥n m√°s de ‚Äúfondo‚Äù, que har√≠a que localiz√°ramos a un elemento en su index [i, j, k], en plano cartesiano como xyz. Adem√°s existe una tercer clasificaci√≥n conocida como jagged arrays o matrices dentadas como se ve en la siguiente imagen, donde vemos un arreglo de tipo bi-dimensional pero con la diferencia de que una de sus dimensiones no es rectangular sino que puede tener distintos tama√±os formando as√≠ una matriz dentada. Clasificaci√≥n de arrays en m√∫ltiples dimensiones Puedo decir que este es un resumen sobre los arrays, uno que sin duda nos ayudar√° a identificar de forma m√°s r√°pida el tipo de ‚Äúarray‚Äù que necesitamos usar. Estructuras enlazadas (linked structures) La magia de las estructuras enlazadas es dada por los pointers o punteros, que como su nombre lo indica apuntan a una direcci√≥n de memoria donde se encuentra ubicado un valor. Los pointers son los encargados de mantener los ‚Äúenlaces‚Äù entre valores de modo que es posible tener una secuencia de valores todos enlazados por pointers. Si ponemos atenci√≥n a la definici√≥n de los pointers podemos deducir que los valores no necesariamente tienen que estar localizados en memoria uno despu√©s del otro como en le caso de los arrays que son contiguamente asignados, por lo que podemos tener los valores ubicados en distintas localidades de la memoria y a√∫n as√≠ representar un colecci√≥n de valores consecutivos. Representaci√≥n de una secuencia de valores enlazada por punteros Como se observa en la imagen, tenemos una secuencia de valores enlazados por pointers llamados nodos, que est√°n representados por un cuadro vac√≠o y una flecha. El cuadro vac√≠o representa el valor con la direcci√≥n de memoria a donde est√° apuntando el valor que contiene, de modo que: el valor 12 est√° enlazado por medio de un pointer que guarda la ubicaci√≥n del siguiente valor en la secuencia que es el 19 y este a su vez guarda la ubicaci√≥n al valor 37. Cuando hablemos de estructuras enlazadas debemos siempre pensar en que adem√°s de almacenar el valor que deseamos, debemos tener un espacio extra donde debemos almacenar la direcci√≥n de memoria del siguiente valor. Despu√©s de una breve introducci√≥n a los pointers podemos pasar a la estructura mas com√∫n de las estructuras enlazadas que son las linked lists o listas enlazadas. Linked lists Comencemos por definir una ‚Äúlista‚Äù. Una lista es aquella estructura que representa un n√∫mero contable de valores ordenados donde un mismo valor puede repetirse y considerarse un valor distinto a otro ya existente. Las listas son consideradas secuencias de valores y c√≥mo ya ve√≠amos en la explicaci√≥n anterior sobre pointers estos se pueden aplicar para implementar una lista de tal forma que las caracter√≠sticas principales de una lista ser√≠an: Cada nodo en nuestra lista contiene uno o m√°s campos que contienen el valor que deseamos almacenar. Cada nodo contiene al menos un campo pointer apuntando a otro nodo, lo que significa que podemos tener 2 pointers, uno que apunta a un nodo consecuente y otro que apunta a un nodo previo formando as√≠ una lista doblemente enlazada (double linked list). Es necesario tener un pointer que apunte a la cabeza de la estructura para as√≠ saber por d√≥nde comenzar. Representaci√≥n de una liked list con sus respectivos punteros (imagen tomada del libro ‚ÄúThe Algorithm Design Manual‚Äù) ¬øRecuerdan cuando explic√°bamos el problema de la permutaci√≥n de una palabra?, espec√≠ficamente cuando habl√°bamos de representar una palabra en un array donde cada letra era una casilla, bien, aqu√≠ tenemos una lista de palabras lo cual puede claramente significar que es una lista de arrays. La mayor√≠a de los lenguajes de programaci√≥n representan a las ‚Äúcadenas‚Äù (palabras, secuencia de caracteres, etc) como arrays de caracteres, es por eso que con otra estructura como las lists podemos tener secuencias de palabras pudiendo representar un p√°rrafo de un libro o de un post de medium que habla sobre estructuras de datos :p Ahora debo mencionar que las 3 operaciones b√°sicas soportadas por una linked list son: b√∫squeda, inserci√≥n y eliminaci√≥n de nodos. Suena obvio ¬øno creen?, para explicar esto har√© una comparaci√≥n sobre ambos tipos de estructuras y quiz√° as√≠ quede m√°s claro. Array vs Linked list Una diferencia grande entre los arrays vs linked lists es que insertar o eliminar de una linked list es m√°s f√°cil ya que no tiene tama√±o fijo y lo √∫nico que debemos hacer para insertar o eliminar un valor es simplemente apuntar al nuevo nodo creado, √≥ apuntar al siguiente nodo de la lista si un nodo fue eliminado. En un array no existe esta flexibilidad. Si tenemos una gran cantidad de valores siempre ser√° m√°s f√°cil mover pointers de una valor a otro que mover los valores en s√≠. En un array podemos provocar un desbordamiento de memoria (memory overflow) si queremos insertar un valor extra y ya hemos excedido el tama√±o del array, lo cual no suceder√≠a en una linked list. Por otro lado en una linked list necesitamos m√°s espacio en memoria para almacenar los pointers. Los arrays tienen un mejor manejo del acceso aleatorio a los valores y son mucho mejores en la ubicaci√≥n de los datos en memoria y aprovechamiento de la cach√©. ¬øCu√°l es mejor? Ninguna es mejor que la otra, todo depender√° de lo que necesitemos resolver. Imaginemos que estamos creando una estructura para almacenar los usuarios de nuestra aplicaci√≥n, esta estructura debe guardar el username y su password, ya dijimos que las linked list son r√°pidas para insertar y eliminar, entonces ¬øusar√≠amos una linked list?, si podr√≠amos. Ahora si us√°ramos la linked list y quisi√©ramos obtener un username porque queremos saber su password para el log-in de nuestra aplicaci√≥n ¬øser√≠a mejor usar un array?, el acceso en los arrays es m√°s r√°pido ya que sabiendo la ubicaci√≥n obtendremos el dato directamente, cosa que en la linked list no podr√≠amos. Entonces, ¬øc√≥mo resolvemos este problema si queremos insertar y eliminar de forma eficiente, y tambi√©n queremos acceder a los datos de forma eficiente?, podr√≠amos combinar ambas estructuras, s√≠, hacer un array de linked list. De esta forma podr√≠amos asignar a cada casilla del array una linked list por cada letra del abecedario, si deseamos agregar un username ‚ÄúMarcela‚Äù ir√≠amos directamente a la casilla de la letra M e insertar√≠amos un nuevo nodo con el username y su password en la linked list. Y si queremos obtener el username podemos de nuevo ir a la casilla de la M y buscar en el linked list. De esta forma evitar√≠amos buscar en todos los usernames hasta encontrar el que queremos, y obtener y agregar nuevos datos se volver√≠a mas f√°cil y r√°pido. Contenedores Las estructuras de tipo contenedor se caracterizan principalmente por la forma particular de recuperaci√≥n ordenada de datos que soportan, y en los dos tipos principales de contenedores (stack y queue) el orden de recuperaci√≥n depende del orden de inserci√≥n. Stack Un stack o pila, soporta la recuperaci√≥n ordenada de datos last-in, first-out (LIFO) o bien: el √∫ltimo dato en entrar, el primer dato en salir. De la misma forma en que se hace en una pila de platos limpios, si necesitamos un plato limpio vamos a la pila y tomamos el primero de la pila, que en realidad fue el √∫ltimo plato que agregamos a ella. Las pilas son estructuras que encontramos de muchas formas en el mundo real, siempre que podamos apilar alg√∫n objeto como libros, cazuelas, pel√≠culas o la forma en la que metemos latas de refresco en el refrigerador :) Representaci√≥n de un stack y sus operaciones push y pop Tomando en cuenta lo anterior podemos pensar que si usamos un stack es porque probablemente el orden de la recuperaci√≥n de datos no nos importa tanto, simplemente queremos apilarlos y des-apilarlos, por lo que las operaciones fundamentales en un stack son push y pop para poner y obtener datos de la pila. Con push() insertamos un elemento en el tope de la pila, y con pop() retornamos y removemos el elemento en el tope de la pila, como se ve en la imagen. Queue Una queue o cola, soporta la recuperaci√≥n ordenada de datos first-in, first-out (FIFO) o bien: el primer dato en entrar, es el primer dato en salir. Justo como una cola en el banco cuando vamos a realizar alguna operaci√≥n con nuestra cuenta bancaria, si todos los asistentes est√°n ocupados se genera una cola donde el primero que lleg√≥ ser√° el primero en ser atendido y el resto esperamos en la cola. Este tipo de estructuras se utiliza mucho en el control de tiempos de espera de servicios, tiempos de ejecuci√≥n en un CPU, de conexi√≥n de red, o en el mundo real en una cola para las tortillas, para entrar en una avenida r√°pida, etc. Representaci√≥n de una queue y sus operaciones enqueue y dequeue En este tipo de estructura el orden s√≠ importa, pues siempre el primero de la cola debe ser el primero en ser atendido y el resto de forma ordenada esperan su turno. Las operaciones de esta estructura son: enqueue y dequeue para encolar y des-encolar (poner y obtener de la cola). De modo que enqueue() inserta un elemento al final de la cola, y dequeue() retorna y remueve el primer elemento de la cola. Conclusi√≥n Las estructuras de datos existen para ayudarnos en la compleja tarea de resolver problemas en programaci√≥n, no importa el lenguaje de programaci√≥n que utilices, si vas a manejar datos de cualquier tipo siempre caer√°s en el uso de estructuras de datos. Dicho esto, podemos concluir que tener una base s√≥lida de entendimiento sobre las caracter√≠sticas de una estructura de datos nos llevar√°n a hacer la mejor elecci√≥n para resolver nuestro problema, y de esta forma alejarnos de hacer una mala elecci√≥n que nos pueda costar mucho: mucha memoria, mucho tiempo de ejecuci√≥n, mucho tiempo de desarrollo. En una segunda parte, escribir√© sobre los diccionarios, hash tables, √°rboles y grafos. Referencias http://www.algorist.com/"
      },
      {
        "id": 46,
        "autor": "Joseba Fuentes ",
        "pagina": "OpenWebinars",
        "fecha": "18/10/2019",
        "titulo": "¬øQu√© son las estructuras de datos y por qu√© son tan √∫tiles?",
        "link": "https://openwebinars.net/blog/que-son-las-estructuras-de-datos-y-por-que-son-tan-utiles/",
        "contenido": "Las estructuras de datos son una forma de organizar los datos en la computadora, de tal manera que nos permita realizar unas operaciones con ellas de forma muy eficiente. Es decir, igual que un array introducimos un dato y eso es pr√°cticamente inmediato, no siempre lo es, seg√∫n qu√© estructuras de datos y qu√© operaciones. Depende que algoritmo queramos ejecutar, habr√° veces que sea mejor utilizar una estructura de datos u otra estructura que nos permita m√°s velocidad. Por este motivo es interesante conocer algo m√°s que simplemente los arrays o los hashmaps que casi todo el mundo conoce. Estructuras de datos m√°s conocidas Arrays Imagen 0 en ¬øQu√© son las estructuras de datos y por qu√© son tan √∫tiles? Constan de un √≠ndice para acceder a una posici√≥n concreta y del valor que el mismo almacena. Mont√≠culos binarios Imagen 1 en ¬øQu√© son las estructuras de datos y por qu√© son tan √∫tiles? Es una forma de guardar los datos de tal manera, que, aunque no est√©n ordenados, se puedan retirar de ese conjunto datos de forma ordenada. Esto permite una gran velocidad, por ejemplo, a la hora de implementar una cola de prioridades donde queremos que cada elemento que insertemos, si insertamos de repente muchos elementos con una prioridad, el primero que se coja sea el que tenga m√°s o menos prioridad, depende del tipo de mont√≠culo. Pilas Imagen 2 en ¬øQu√© son las estructuras de datos y por qu√© son tan √∫tiles? Sirven, por ejemplo, para implementar el proceso de deshacer, como cuando escribimos en un editor de texto y pulsamos CTRL+Z, lo que podemos implementar con una pila. Como vemos en la imagen, tenemos una pila vac√≠a, el bloque 1 ser√≠a equivalente a escribir algo. El bloque 2 ser√≠a el equivalente a borrar una letra, por ejemplo. Cuando utilizamos deshacer, lo que har√≠a ser√≠a coger la √∫ltima acci√≥n realizada, que tendr√≠a una funci√≥n que har√≠a ciertas operaciones con el hecho de haber borrado una letra y la volver√≠a a poner. Colas Imagen 3 en ¬øQu√© son las estructuras de datos y por qu√© son tan √∫tiles? Es otra estructura de datos muy √∫til, que sirve, entre otras cosas, para implementar una cola o para comunicar procesos as√≠ncronos. Por qu√© son √∫tiles las estructuras de datos Las estructuras de datos son √∫tiles porque nos permiten tener una bater√≠a de herramientas para solucionar ciertos tipos de problemas. Adem√°s, nos permiten hacer un software m√°s eficiente optimizando recursos, algo muy √∫til para IoT y para los entornos que trabajan con Big Data."
      },
      {
        "id": 47,
        "autor": "Martin Cruz",
        "pagina": "martincruz",
        "fecha": "21/10/2012",
        "titulo": "Registros en C++ / Uso de struct en C++",
        "link": "https://blog.martincruz.me/2012/10/registros-en-c-uso-de-struct-en-c_4493.html",
        "contenido": "octubre 21, 2012 Un registro, en programaci√≥n, es un tipo de dato estructurado formado por la uni√≥n de varios elementos bajo una misma estructura. Estos elementos pueden ser, o bien datos elementales (entero, real, car√°cter,...), o bien otras estructuras de datos. A cada uno de esos elementos se le llama campo. Un ejemplo de eso seria hacer un registro de vendedores donde nos pedir√≠an informaci√≥n sobre, nombre, apellido, direcci√≥n, DNI, numero de art√≠culos, articulos vendidos, art√≠culos que quedan, precio de cada uno, el precio de todos los art√≠culos de cada vendedor; para todo eso necesitariamos usar REGISTROS ya que solo con vectores no prodriamos afrontar el problema. Aqui les dejare un el ejercicio del mismo que me dejaron el la universidad sobre un registro de vendedores implementado en C++ y lo compartire con ustedes. El enunciado del problema es el siguiente: Implementa en C++: Debo registrar vendedores (dni, nombres, apellidos, direcci√≥n(calle, numero, urbanizaci√≥n) ) con sus respectivos productos vendidos (producto, cantidad, precioventa). Implementa el sistema usando registros y funciones. El sistema debe permitir: Registrar ‚ÄúN‚Äù vendedores con sus respectivos ‚ÄúPk‚Äù productos. Mostrar todos los vendedores con todos sus datos y sus respectivos productos. Mostrar los datos de un vendedor espec√≠fico (ingresando su n√∫mero de orden) Mostrar los productos vendidos de un vendedor espec√≠fico (ingresando su n√∫mero de orden): producto, cantidad, precioventa, Subtotal. y finalmente el Total. Subtotal = cantidad * precioventa Total = sumatoria de los subtotales Eliminar un vendedor espec√≠fico (ingresando su n√∫mero de orden) B√∫squeda por dni: ingresa el dni de un vendedor y que muestre su direcci√≥n Implementaci√≥n: /* * C++ - Agenda con uso de struct * * Copyright 2014 Martin Cruz Otiniano * * Site: martincruz.me */ #include <iostream> #include <stdlib.h> #define MAXCAD 50 #define MAX_V 100     // numero de vendedores #define MAX_PV 100    // maximo de productos vendidos using namespace std; struct unProducto { char name_prod[MAXCAD];  // nombre del producto int  cantidad; int  precio  ; int  subtotal; }; struct variosProductos { int numProd ;             // numero de productos por vendedor unProducto vp[MAX_PV];      //varios productos cada uno en una posicion del  vector int precioTotal ; }; struct Vendedor { char nombre[MAXCAD]   ; char apellido[MAXCAD] ; char direccion[MAXCAD]; int  DNI     ; variosProductos P  ; }; struct Vendedor lista[MAX_V]; // creamos un array de tvendedores struct Vendedor aux; void registrar_productos(int nv, int np) { // nv -> numero de vendedor for(int i=0; i<np; i++) { cout<<\n\tProducto << i+1 <<endl; cin.ignore(); cout<<\t\tNombre   :  ; cin.getline( lista[nv].P.vp[i].name_prod, MAXCAD ); //cin.ignore(); cout<<\t\tCantidad : ; cin>> lista[nv].P.vp[i].cantidad ; //cin.ignore(); cout<<\t\tPrecio   : ; cin>> lista[nv].P.vp[i].precio ; lista[nv].P.vp[i].subtotal = lista[nv].P.vp[i].cantidad * lista[nv].P.vp[i].precio ;  // subtotal = precio*cantidad if(lista[nv].P.vp[i].subtotal==0) cout<<Subtotal 0; lista[nv].P.precioTotal = lista[nv].P.precioTotal +  lista[nv].P.vp[i].subtotal ; } } void registrar_vendedores(int n) { int np ;  //  numero de productos por cada vendedor for(int i=0; i<n; i++) { cout<<\nVENDEDOR << i+1 << \n; cin.ignore();  cout <<    Nombres   : ;  cin.getline( lista[i].nombre, MAXCAD   ); cin.ignore();  cout <<    Apellidos : ;  cin.getline( lista[i].apellido, MAXCAD ); cin.ignore();  cout <<    Direccion : ;  cin.getline( lista[i].direccion, MAXCAD); cin.ignore();  cout <<    D N I     : ;  cin>> lista[i].DNI ; cout<<\n   > Numero de productos: ;      cin>> lista[i].P.numProd ; registrar_productos( i ,lista[i].P.numProd ); } } void datosVendedor(int x, int num) { if(num>0) { cout<<endl<<endl; cout << \t << lista[x].nombre <<' '<< lista[x].apellido << endl; cout <<    DNI      :  << lista[x].DNI       << endl; cout <<    Direccion:  << lista[x].direccion << endl; } else cout<<\n\tRegistro vacio..!; } void prodVendedor(int x, int num) { if(num>0) { cout<<endl<<endl; cout <<    Productos de  << lista[x].nombre <<' '<< lista[x].apellido << endl<<endl; for(int i=0; i<lista[x].P.numProd; i++) { cout<<\n   Producto << i+1                      <<endl; cout<<\tNombre  :  << lista[x].P.vp[i].name_prod  <<endl; cout<<\tCantidad:  << lista[x].P.vp[i].cantidad <<endl; cout<<\tPrecio  :  << lista[x].P.vp[i].precio     <<endl; cout<<\tSubtotal:  << lista[x].P.vp[i].subtotal <<endl ; } cout<<endl; cout<<  ---------------------------<<endl; cout<<  PRECIO TOTAL:   << lista[x].P.precioTotal; } else cout<<\n\tRegistro vacio..!; } void mostrar_productos(int nv) { cout<<   Productos: \n\n; for(int i=0; i<lista[nv].P.numProd; i++) { cout<<\t-  << lista[nv].P.vp[i].name_prod <<endl ; } } void mostrar_vendedores(int num) { if( num>0) { cout<<\n\nMostrando lista de Vendedores\n; for(int i=0; i<num; i++) { cout<<endl<<endl; cout<< i+1<<. << lista[i].nombre <<' '<< lista[i].apellido << endl; cout <<    DNI      :  << lista[i].DNI       << endl; cout <<    Direccion:  << lista[i].direccion << endl; mostrar_productos( i ); cout<<endl; } } else cout<<\n\tRegistro vacio..!; } void eliminar_vendedor( int x, int &num) { if(num>0) { for(int i=x; i<num-1; i++) lista[i] = lista[i+1]; num--; } else cout<<\n\tRegistro vacio..!; } void buscar_vendedor( int num) { int band = 0; if(num>0) { for(int i=0; i<num; i++) { if(lista[i].DNI==aux.DNI) { cout<<\n\n La direccion de <<lista[i].nombre<< <<lista[i].apellido<< es : <<lista[i].direccion <<endl ; band = 1 ; break; } } } else cout<<\n\tRegistro vacio..!; if(band==0) cout<<\n\n\tEl vendedor no fue encontrado..! :S<<endl; } void menu1() { cout<<\n\t\tREGISTRO DE VENDEDORES\n\n; cout<< 1. Registrar vendedores                       <<endl; cout<< 2. Mostrar registro de vendedores y productos <<endl; cout<< 3. Mostrar datos de un vendedor               <<endl; cout<< 4. Mostrar productos vendidos de un vendedor  <<endl; cout<< 5. Eliminar vendedor del registro             <<endl; cout<< 6. Buscar direccion de vendedor por DNI       <<endl; cout<< 7. Salir                                      <<endl; cout<<\n Ingrese opcion : ; } /*                      funcion principal ------------------------------------------------------------------------------*/ int main() { int num=0;  // numero de vendores int op;   // opcion del menu int num_vendedor ; system(color 0b); do { menu1();  cin>> op; switch(op) { case 1: cout<<\n Numero de vendedores: ; cin>> num; registrar_vendedores(num);  cout<<endl; break; case 2: mostrar_vendedores(num); break; case 3: cout<<\n Ingrese numero de vendedor: ; cin>> num_vendedor ; datosVendedor( num_vendedor-1, num); break; case 4: cout<<\n Ingrese numero de vendedor: ; cin>> num_vendedor ; prodVendedor( num_vendedor-1, num); break; case 5: cout<<\n Ingrese numero de vendedor: ; cin>> num_vendedor ; eliminar_vendedor( num_vendedor-1, num); cout<Vendedor eliminado ..!<<endl; break; case 6: cout<<\n Ingrese numero de DNI: ; cin>> aux.DNI; buscar_vendedor(num); break; } cout<<endl<<endl; system(pause);  system(cls); } while(op != 7); return 0; } view rawagenda.cpp hosted with ‚ù§ by GitHub Estructura de Datos"
      },
      {
        "id": 48,
        "autor": "Universidad T√©cnica Federico Santa Mar√≠a",
        "pagina": "progra",
        "fecha": "00/00/0000",
        "titulo": "Datos de una persona",
        "link": "http://progra.usm.cl/apunte/c/datos-persona.html",
        "contenido": "El siguiente programa le pide al usuario ingresar su nombre completo, su rut y su fecha de nacimiento. Como salida, se muestra la edad del usuario. #include <stdio.h> #include <stdlib.h> #define ANNO_ACTUAL 2012 #define LARGO_NOMBRE 50 #define LARGO_RUT 10 struct fecha { int dia; int mes; int anno; }; struct persona { char nombre[LARGO_NOMBRE + 1]; char rut[LARGO_RUT + 1]; struct fecha fecha_nacimiento; }; int fecha_es_valida(struct fecha f) { int dias_mes[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; if (f.mes < 1 || f.mes > 12) return 0; if (f.dia < 1 || f.dia > dias_mes[f.mes]) return 0; return 1; } int main() { struct persona p; printf(Nombre completo: ); scanf(%[^\n], p.nombre); printf(Rut: ); scanf(%s, p.rut); printf(Fecha de nacimiento (dia mes anno): ); scanf(%d, &p.fecha_nacimiento.dia); scanf(%d, &p.fecha_nacimiento.mes); scanf(%d, &p.fecha_nacimiento.anno); if (!fecha_es_valida(p.fecha_nacimiento)) { fprintf(stderr, Fecha es invalida\n); exit(1); } printf(\n); printf(%s tiene %d annos.\n, p.nombre, ANNO_ACTUAL - p.fecha_nacimiento.anno); exit(0); } Adem√°s, el programa verifica que la fecha de nacimiento sea v√°lida, revisando que el mes est√© entre 1 y 12, y que el d√≠a tenga sentido para ese mes. Para simplificar, nos hemos echado los a√±os bisiestos al bolsillo. Macros de preprocesador La primera cosa extra√±a que vemos en este programa son las l√≠neas que comienzan con #define. Estas l√≠neas son instrucciones para el preprocesador, que es un componente del compilador que hace algunas sustituciones en el c√≥digo antes de que comience realmente a ser compilado. Estas sustituciones se llaman macros, y son definidas por el programador usando la instrucci√≥n #define. Cada vez que aparece la macro en el c√≥digo, el preprocesador la reemplaza literalmente por lo que aparezca a su derecha en el #define. Es com√∫n usar macros para definir una √∫nica vez al principio del programa los largos de los arreglos. Estos valores suelen aparecer muchas varias veces durante el programa; por ejemplo, en las declaraciones y en los ciclos que los recorren. En nuestro programa, hemos definido las macros LARGO_NOMBRE y LARGO_RUT, que son los largos de los strings. Si m√°s adelante uno quisiera modificar el programa para que alguno de estos strings tenga un largo diferente, bastar√≠a con modificar la macro asociada para que autom√°ticamente el programa siga estando correcto. Hay que tener muy claro que las macros no son variables. Son s√≥lo abreviaciones que son reemplazadas tal cual cada vez que aparecen en el c√≥digo. Para distinguirlas de las variables, se sigue la convenci√≥n de ponerle a las macros nombres en may√∫sculas. En la l√≠nea de comandos, usted puede usar el programa cpp para ver c√≥mo queda el c√≥digo despu√©s de ser preprocesado: $ cpp personas.c Estructuras Una estructura es un tipo de datos que agrupa varios valores en uno solo. A diferencia de los arreglos, los componentes de una estructura pueden ser de tipos diferentes. Las estructuras en C se usan para lo mismo que las tuplas en Python: para agrupar datos que, por su naturaleza, deben ser tratados como un √∫nico valor. El ejemplo t√≠pico es crear una estructura para almacenar una fecha: struct fecha { int dia; int mes; int anno; }; Esta definici√≥n crea un nuevo tipo de datos llamado struct fecha, que contiene tres valores enteros. El punto y coma despu√©s de la llave es obligatorio; un error muy com√∫n es omitirlo. Una variable de tipo struct fecha debe ser declarada de la misma forma que las dem√°s variables: struct fecha f; Una vez declarada la variable f, sus miembros pueden ser accedidos poniendo su nombre despu√©s de un punto: f.dia = 21; f.mes = 5; f.anno = 1879; Note que las estructuras no se desempaquetan como las tuplas de Python. No es necesario ya que se puede acceder a los campos a trav√©s de su nombre, y no por su posici√≥n. Los campos de una estructura pueden ser de cualquier tipo, incluso arreglos u otra estructura. En el ejemplo, la estructura persona est√° compuesta de dos strings y una estructura fecha. Inicializaci√≥n de arreglos y estructuras La funci√≥n fecha_es_valida utiliza el arreglo dias_mes para tener a la mano cu√°ntos d√≠as tiene cada mes. Para que el mes m est√© asociado al elemento m del arreglo, dejamos un valor de relleno en la posici√≥n 0, que no corresponder√° a ning√∫n mes. En vez de llenar el arreglo elemento por elemento: dias_mes[1] = 31; dias_mes[2] = 28; dias_mes[3] = 31; /* ... */ podemos usar la siguiente sintaxis para inicializarlo: int dias_mes[] = {0, 31, 28, 31, /* ... */ }; Al inicializar el arreglo de esta manera no es necesario especificar su tama√±o. En nuestro programa, el arreglo dias_mes ser√° de largo trece. La misma sintaxis se puede usar para inicializar los elementos de una estructura: struct fecha hoy = {29, 2, 2011}; La sintaxis de inicializaci√≥n s√≥lo puede ser usada en la misma declaraci√≥n, no m√°s adelante en el programa: int a[5]; a = {900, 100, 600, 300, 200};  /* Esto es ilegal. */ Leer una l√≠nea completa El descriptor de formato %s indica a la funci√≥n scanf que debe leer un string. Lo que hace la funci√≥n es leer texto hasta encontrarse con el primer caracter en blanco (como un espacio o un salto de l√≠nea). Esto no resulta √∫til cuando el string que interesa s√≠ tiene espacios entre medio. En el caso de nuestro programa, necesitamos un nombre completo, en que el nombre y el apellido est√°n separados por un espacio. Para leer el nombre completo del usuario, usamos el descriptor de formato %[^\n]. Esto significa literalmente ¬´leer todos los caracteres que no sean saltos de l√≠nea¬ª. Salidas est√°ndar y de error Cada vez que uno imprime cosas usando la funci√≥n printf, lo que realmente ocurre es que el texto es enviado a un flujo de datos denominado salida est√°ndar. Podemos pensar en la salida est√°ndar como un canal de comunicaci√≥n entre nuestro programa y la consola. En todos los programas en C, la salida est√°ndar est√° disponible para escribir cosas en ella. Pero adem√°s los programas tienen tambi√©n otro flujo de datos, llamado salida de error, que est√° destinada exclusivamente para escribir en ella mensajes de error. Los nombres de las salidas est√°ndar y de error en un programa son, respectivamente, stdin y stderr. En nuestro programa, usamos la salida de error para imprimir un mensaje antes de abortar el programa cuando se ha ingresado una fecha inv√°lida. Para esto, usamos la funci√≥n fprintf. Esta funci√≥n es muy parecida a printf, salvo que recibe como primer par√°metro el flujo de datos en que se escribir√° el mensaje. M√°s adelante utilizaremos fprintf para escribir datos en archivos. Por omisi√≥n, ambas salidas est√°n conectadas con la consola, por lo que los mensajes impresos en ambas aparecen mezclados unos con otros, sin distinci√≥n. La gracia es que es posible redirigir por separado a cualquiera de ellas hacia otros mecanismos de salida, como un archivo, o de frent√≥n suprimirlos. Por lo tanto, es una buena pr√°ctica escribir los mensajes de error en stderr. Ejercicios ¬øQu√© imprime el siguiente programa? Pruebe el programa y explique el resultado. #include <stdio.h> #define DOS    1 + 1 #define SIETE  3 + 4 int main() { int m = DOS * SIETE; printf(%d\n, m); return 0; }"
      },
      {
        "id": 49,
        "autor": "TheMushrr00m",
        "pagina": "La espora del hongo",
        "fecha": "29/04/2015",
        "titulo": "Estructura de Datos ‚Äì Listas Ligadas (Enlazadas) en Lenguaje C",
        "link": "https://laesporadelhongo.com/estructura-de-datos-listas-ligadas-en-c/",
        "contenido": "Hola a todos los que lleguen a leer esta entrada. En esta ocasi√≥n les dejo un video-tutorial que tuve que realizar en mi materia de Estructura de Datos, en el cual, deb√≠a mostrar como implementar las listas ligadas en el lenguaje de Programaci√≥n C. Aclar√≥ que tal vez ustedes puedan tener otra forma para realizarlo, o al ver el v√≠deo se les ocurra alguna manera mas eficiente, si es as√≠, quedo abierto a leer sus comentarios al respecto. Tambi√©n les dejo la presentaci√≥n que utilic√© en el v√≠deo, se que es algo simple pero intent√© explicar todo durante el v√≠deo, en fin, para algo podr√≠a servirles. Listas Ligadas Simples (Presentaci√≥n) Y por si no fuera suficiente para ustedes, tambi√©n les dejo el c√≥digo fuente que realic√© y se muestra en el v√≠deo, les recomiendo utilicen el IDE que yo utilizo, el cual es ¬´Code Blocks¬´, a mi parecer es la mejor opci√≥n para escribir c√≥digo C, claro, esto si no lo hacen desde alg√∫n sistema *nix, si es as√≠, les recomiendo que lo hagan a lo hardcore desde terminal con Nano, Vim o Emacs. en Windows. Code Blocks Logo Si se animaron a probarlo, pueden descargarlo directamente desde su Sitio Web. Y bien, espero sus comentarios sobre el v√≠deo, claro, siempre y cuando no sean acerca de la edici√≥n del v√≠deo, o de la forma en que hablo, les comento que lo realic√© 2 horas antes de ir a la Universidad, estaba desvelado y no estaba 100% concentrado. Era broma, si quieren comentar lo que sea no duden en hacerlo. Saludos."
      },
      {
        "id": 50,
        "autor": "Yennifer Gomez",
        "pagina": "tecnoinformatic",
        "fecha": "27/05/2020",
        "titulo": "Estructura de datos: Descripci√≥n, ejemplos, y m√°s",
        "link": "https://tecnoinformatic.com/c-programacion/estructura-de-datos/",
        "contenido": "La ciencia en el √°rea de computaci√≥n est√° en un constante desarrollo debido a que con cada actualizaci√≥n se tiene la capacidad de realizar de una estructura de datos y algoritmos. Es por eso que este art√≠culo se va a explicar algunos detalles importantes a tener en cuenta para su aplicaci√≥n y correcta ejecuci√≥n. Estructura-de-datos-2 √çndice de Contenido [Ocultar] 1 Estructura de Datos 1.1 Descripci√≥n 2 Ejemplos 2.1 Vector 2.2 Vector Asociativo 2.3 Registro 2.4 Uni√≥n 2.5 Tipo Variante 2.6  Conjunto 2.7 Multiconjunto 2.8 Grafo 2.9 √Årbol 2.10 Clase Estructura de Datos La estructura de datos es una manera espec√≠fica en c√≥mo realizar la organizaci√≥n de datos y de la informaci√≥n que se tiene en un equipo. Por medio de este orden se puede aplicar de una manera muy eficiente logrando la aplicaci√≥n que se necesite. Por cada aplicaci√≥n que se utilice se requiere diversos tipos de estructuras de datos de modo que pueda ser empleada para tareas determinadas y con un alto rendimiento. A trav√©s de cada aplicaci√≥n se puede realizar un proyecto espec√≠fico por lo que la estructura de la informaci√≥n de la computadora e puede organizar de tal manera que se pueda ejecutar de la forma correcta. Descripci√≥n Se conoce que la estructura de datos es un medio donde se tiene la capacidad de poder controlar diversos datos incluso se puede manejar una amplia cantidad de informaci√≥n con un alto rendimiento y eficiencia. Su aplicaci√≥n es variada debido a que la red dispone de una gran cantidad de datos e la cual se pueda manejar seg√∫n se tenga la necesidad. Su aplicaci√≥n puede basarse en las grandes bases de datos y en los grandes servicios de indizaci√≥n de la red, es decir, del internet dando la posibilidad de emplear de forma √≥ptima el dise√±o correspondiente de diversos algoritmos determinados. Es por ello que la principal descripci√≥n para la estructura de datos e que consisten en la clave de dise√±ar algoritmo de una forma muy eficiente logrando los resultados deseados. Presenta algunos m√©todos caracter√≠sticas para establecer la base y el lenguaje de programaci√≥n que se va a aplicar. Se destaca que en cada programa y en cada algoritmo es el factor fundamental para la organizaci√≥n del software correspondiente resaltando que cada paso cumple con un requisito esencial para la estructura que va a disponer. Como la estructura de datos es la clave para el dise√±o del software correspondiente y que se encuentra basado en la capacidad que dispone del equipo de podo que se tenga la posibilidad de recuperar y de poder guardar los datos determinados en cualquier sitio de la memoria. Si deseas conocer sobre la programaci√≥n de sistemas de desarrollo de un software determinado, entonces se recomienda leer el articulo de Microservicios, donde se explica cada uno de los aspectos importantes que presenta como sus caracter√≠sticas, sus ventajas, las desventajas y algunos ejemplos Ejemplos Estructura-de-datos-3 La estructura de datos es fundamental para cualquier sistema que disponga el equipo, de modo que pueden existir muchas formas de estructura y de organizaci√≥n que se pueda implementar a los datos almacenados en ella computadora. Si deseas conocer que es lo que permite organizar y preparar un ordenador en funci√≥n de que pueda cumplir con las operaciones, entonces se recomienda leer el articulo de Programaci√≥n Inform√°tica, donde se explica como permiten seguir una secuencia de √≥rdenes y pasos. Al realizar esta organizaci√≥n de los datos se tiene la capacidad de aplicar una serie de operaciones espec√≠ficas de modo que da al usuario herramientas para el desarrollo del software. Es por ello que a continuaci√≥n se presenta algunos ejemplos de la estructura de datos que se aplican en los equipos y que se encuentran basados sobre otras estructuras simples: Vector Es un conjunto de elementos que se encuentran estructurado de una forma especial y especifica De una forma general cada elemento que se disponga son del mismo tipo Se puede acceder a estos elementos mediante l aplicaci√≥n de un entero como un √≠ndice de manera que se tenga que se√±alar el elemento que se desee Puede presentar algunas implementaciones b√°sicas las cuales pueden dar las palabras de la memoria adyacente de los elementos que se encuentre en cada rearreglo Con cada modificaci√≥n que se realice se puede cambiar o variar el tama√±o de la longitud Tambi√©n puede disponer de una longitud fija determinada Vector Asociativo Es una variable caracterizada por ser flexible Su flexibilidad es mayor que el de una matriz Da la opci√≥n de agregar pares nombre valor Tambi√©n permite eliminar pares nombre valor Cuenta con una tabla de hash Facilita el arreglo asociativo que se realiza Registro Es tambi√©n conocido como estructura o como tupia Consiste en una estructura de datos que se pueden anexar Basado en un valor el cual dispone de otros valores Generalmente su forma b√°sica es un n√∫mero fijo Su valor puede ser en secuencia Cuenta con un √≠ndice por nombres para facilitar la b√∫squeda de valores y variables caracterices Dispone de elementos que son denominados como Campos y tambi√©n como Celdas Estructura-de-datos-4 Uni√≥n Es una estructura de datos que se√±ala de forma esencial el conjunto de tipos de datos que pueden ser guardadas en un lugar en especifico Dispone de algunas funciones diferentes al Registro Cuenta de un solo valor que se aplica a la vez Permite asignar el espacio requeridos para almacenar los tipos de datos, es por ello que dicho lugar debe ser suficiente para contener los datos y la informaci√≥n especifica Tipo Variante Se conoce como el registro variante Tambi√©n es llamado como la uni√≥n discriminada Dispone de un campo adicional Se encarga de indicar y resaltar el tipo que presente a tiempo real Conjunto Es un tipo de datos abstracto Da la capacidad de guardar valores espec√≠ficos No requiere que al guardar los datos se disponga de un orden especifico y particular Tampoco almacena valores que se encuentre duplicados Multiconjunto Es otro tipo de datos abstracto Se encarga de guardar y ubicar los diversos valores espec√≠ficos dados No almacena los valores por un orden particular, sino que los almacena a medida que se ingrese Permite almacenar valores que est√©n repetidos Grafo Es una estructura de datos que se encuentra conectada Se encuentra constituidas por nodos Cada nodo que dispone posee un valor especifico Tambi√©n los nodos contienen referencias de otros nodos Tiene la capacidad de aplicarse para dar una representaci√≥n de redes Puede dar referencia entre cada nodo Dispone de algunas conexiones las cuales contienen direcciones, es decir, algunos de puntos de entrada y salida √Årbol Consiste en un caso diferente o especifico de grafo Se encuentra en la aplicaci√≥n de los ciclos que no se permiten Dispone de un camino a partir de un nodo hasta otro nodo El nodo de partida se conoce como ra√≠z Presenta una colecci√≥n de √°rboles el cual es com√∫nmente conocida como bosque Clase Es una plantilla especifica Aplicada para la elaboraci√≥n de objetos de datos Est√° basado en un modelo que es predefinido Se emplea como una representaci√≥n abstracta de conceptos Introducen diversos campos como lo son los registros y las operaciones Da la posibilidad de realizar una consulta por el valor de dichos campos Tambi√©n puede cambiar los valores espec√≠ficos"
      },
      {
        "id": 51,
        "autor": "Tutoriales Programacion ya",
        "pagina": "tutorialesprogramacionya",
        "fecha": "00/00/0000",
        "titulo": "45 - Estructuras din√°micas en C: Listas gen√©ricas ordenadas",
        "link": "https://www.tutorialesprogramacionya.com/cya/detalleconcepto.php?punto=45&codigo=45&inicio=30",
        "contenido": "45 - Estructuras din√°micas en C: Listas gen√©ricas ordenadas Una lista gen√©rica es ordenada si cuando insertamos informaci√≥n en la lista queda ordenada respecto al campo info (sea de menor a mayor o a la inversa) Ejemplo: insertar(10); lista ordenada insertar(5) lista ordenada insertar(7) lista ordenada insertar(50) lista ordenada Podemos observar que si recorremos la lista podemos acceder a la informaci√≥n de menor a mayor. No se requiere una funci√≥n para ordenar la lista, sino que siempre permanece ordenada, ya que se inserta ordenada. Programa: programa168.c Ver video #include<stdio.h> #include<conio.h> #include<stdlib.h> struct nodo { int info; struct nodo *sig; }; struct nodo *raiz=NULL; void liberar() { struct nodo *reco = raiz; struct nodo *bor; while (reco != NULL) { bor = reco; reco = reco->sig; free(bor); } } int vacia() { if (raiz == NULL) return 1; else return 0; } void imprimir() { struct nodo *reco=raiz; printf(Lista completa.\n); while (reco!=NULL) { printf(%i ,reco->info); reco=reco->sig; } printf(\n); } void insertar(int x) { struct nodo *nuevo; nuevo=malloc(sizeof(struct nodo)); nuevo->info = x; nuevo->sig=NULL; if (raiz == NULL) { raiz = nuevo; } else { if (x<raiz->info) { nuevo->sig = raiz; raiz = nuevo; } else { struct nodo *reco = raiz; struct nodo *atras = raiz; while (x >= reco->info && reco->sig != NULL) { atras = reco; reco = reco->sig; } if (x >= reco->info) { reco->sig = nuevo; } else { nuevo->sig = reco; atras->sig = nuevo; } } } } int main() { insertar(10); insertar(5); insertar(7); insertar(50); imprimir(); liberar(); getch(); return 0; } La funci√≥n insertar la resolvemos de la siguiente forma: Creamos primeramente el nodo, ya que siempre se insertar√° la informaci√≥n en la lista: struct nodo *nuevo; nuevo=malloc(sizeof(struct nodo)); nuevo->info = x; nuevo->sig=NULL; Se puede presentar las siguientes situaciones, si est√° vac√≠a la lista, lo insertamos inmediatamente: if (raiz == NULL) { raiz = nuevo; } Si no est√° vac√≠a la lista, verificamos si lo debemos insertar en la primera posici√≥n de la lista (analizamos si la informaci√≥n a insertar es menor a lo apuntado por raiz en el campo info): if (x<raiz->info) { nuevo->sig = raiz; raiz = nuevo; } Sino analizamos si lo debemos insertar en medio o al final de la lista. Mientras la informaci√≥n a insertar sea mayor o igual a la informaci√≥n del nodo que visitamos ( x>=reco->info) y no lleguemos al final de la lista (reco->sig!=NULL) avanzamos reco al siguiente nodo y fijamos un puntero en el nodo anterior (atras) struct nodo *reco = raiz; struct nodo *atras = raiz; while (x >= reco->info && reco->sig != NULL) { atras = reco; reco = reco->sig; } Cuando salimos del while si la condici√≥n (x>=reco->info) continua siendo verdadera significa que se inserta al final de la lista, en caso contrario se inserta en medio de la lista: if (x >= reco->info) { reco->sig = nuevo; } else { nuevo->sig = reco; atras->sig = nuevo; } Problema propuesto Se tiene la siguiente declaraci√≥n de nodo: struct nodo { char usuario[51]; struct nodo *sig; }; Implementar una lista ordenada con respecto al campo usuario. Ver video Soluci√≥n Retornar"
      },
      {
        "id": 52,
        "autor": "Tutoriales Programacion ya",
        "pagina": "tutorialesprogramacionya",
        "fecha": "00/00/0000",
        "titulo": "47 - Estructuras din√°micas en C: Listas gen√©ricas circulares",
        "link": "https://www.tutorialesprogramacionya.com/cya/detalleconcepto.php?punto=47&codigo=47&inicio=45",
        "contenido": "47 - Estructuras din√°micas en C: Listas gen√©ricas circulares Una lista circular simplemente encadenada la podemos representar gr√°ficamente: lista circular simplemente encadenada en C Observemos que el puntero sig del √∫ltimo nodo apunta al primer nodo. En este tipo de listas si avanzamos raiz no perdemos la referencia al nodo anterior ya que es un c√≠rculo. Una lista circular puede tambi√©n ser doblemente encadenada: lista circular doblemente encadenada en C El puntero ant del primer nodo apunta al √∫ltimo nodo de la lista y el puntero sig del √∫ltimo nodo de la lista apunta al primero. Resolveremos algunos m√©todos para administrar listas gen√©ricas circulares doblemente encadenadas para analizar la mec√°nica de enlace de nodos. Programa: programa172.c Ver video #include<stdio.h> #include<conio.h> #include<stdlib.h> struct nodo { int info; struct nodo *sig; struct nodo *ant; }; struct nodo *raiz=NULL; void liberar() { if (raiz != NULL) { struct nodo *reco = raiz->sig; struct nodo *bor; while (reco != raiz) { bor = reco; reco = reco->sig; free(bor); } free(raiz); } } int vacia() { if (raiz == NULL) return 1; else return 0; } void insertarPrimero(int x) { struct nodo *nuevo; nuevo=malloc(sizeof(struct nodo)); nuevo->info = x; if (raiz == NULL) { nuevo->sig = nuevo; nuevo->ant = nuevo; raiz = nuevo; } else { struct nodo *ultimo = raiz->ant; nuevo->sig = raiz; nuevo->ant = ultimo; raiz->ant = nuevo; ultimo->sig = nuevo; raiz = nuevo; } } void insertarUltimo(int x) { struct nodo *nuevo; nuevo=malloc(sizeof(struct nodo)); nuevo->info = x; if (raiz == NULL) { nuevo->sig = nuevo; nuevo->ant = nuevo; raiz = nuevo; } else { struct nodo *ultimo = raiz->ant; nuevo->sig = raiz; nuevo->ant = ultimo; raiz->ant = nuevo; ultimo->sig = nuevo; } } void imprimir() { if (!vacia()) { struct nodo *reco = raiz; do { printf(%i ,reco->info); reco = reco->sig; } while (reco != raiz); printf(\n); } } int cantidad() { int cant = 0; if (!vacia()) { struct nodo *reco = raiz; do { cant++; reco = reco->sig; } while (reco != raiz); } return cant; } void borrar(int pos) { if (pos <= cantidad()) { if (pos == 1) { if (cantidad() == 1) { free(raiz); raiz = NULL; } else { struct nodo *bor = raiz; struct nodo *ultimo = raiz->ant; raiz = raiz->sig; ultimo->sig = raiz; raiz->ant = ultimo; free(bor); } } else { struct nodo *reco = raiz; int f; for (f = 1; f <= pos - 1; f++) reco = reco->sig; struct nodo *bor = reco; struct nodo *anterior = reco->ant; reco = reco->sig; anterior->sig = reco; reco->ant = anterior; free(bor); } } } int main() { insertarPrimero(100); insertarPrimero(45); insertarPrimero(12); insertarPrimero(4); printf(Luego de insertar 4 nodos al principio\n); imprimir(); insertarUltimo(250); insertarUltimo(7); printf(Luego de insertar 2 nodos al final\n); imprimir(); printf(Cantidad de nodos:%i\n, cantidad()); printf(Luego de borrar el de la primer posicion:\n); borrar(1); imprimir(); printf(Luego de borrar el de la cuarta posicion:\n); borrar(4); imprimir(); liberar(); getch(); return 0; } Para insertar al principio de una lista circular doblemente encadenada: void insertarPrimero(int x) Creamos un nodo y guardamos la informaci√≥n: struct nodo *nuevo; nuevo=malloc(sizeof(struct nodo)); nuevo->info = x; Si la lista est√° vac√≠a luego tanto el puntero sig y ant apuntan a si mismo ya que debe ser circular (y raiz apunta al nodo creado): if (raiz == NULL) { nuevo->sig = nuevo; nuevo->ant = nuevo; raiz = nuevo; } En caso que la lista no est√© vac√≠a disponemos un puntero al final de la lista (el puntero ant del primer nodo tiene dicha direcci√≥n): else { struct nodo *ultimo = raiz->ant; El nodo a insertar lo enlazamos previo al nodo apuntado por raiz: nuevo->sig = raiz; nuevo->ant = ultimo; raiz->ant = nuevo; ultimo->sig = nuevo; Finalmente hacemos que raiz apunte al nodo creado luego de haber hecho todos los enlaces: raiz = nuevo; Para insertar un nodo al final de la lista: void insertarUltimo(int x) El algoritmo es id√©ntico al m√©todo que inserta al principio con la salvedad que no desplazamos raiz con la direcci√≥n del nodo creado (es decir al insertar en la posici√≥n anterior del primer nodo lo que estamos haciendo realmente es insertar al final de la lista): void insertarUltimo(int x) { struct nodo *nuevo; nuevo=malloc(sizeof(struct nodo)); nuevo->info = x; if (raiz == NULL) { nuevo->sig = nuevo; nuevo->ant = nuevo; raiz = nuevo; } else { struct nodo *ultimo = raiz->ant; nuevo->sig = raiz; nuevo->ant = ultimo; raiz->ant = nuevo; ultimo->sig = nuevo; } } Para imprimir la lista ya no podemos disponer un puntero reco que apunte al primer nodo y que se detenga cuando encuentre un nodo que el atributo sig almacene NULL. void imprimir () Si la lista no est√° vac√≠a disponemos un puntero en el primer nodo y utilizamos un do/while para recorrer la lista. La condici√≥n del do/while es que se repita mientras el puntero reco sea distinto a raiz (es decir que no haya dado toda la vuelta a la lista): void imprimir() { if (!vacia()) { struct nodo *reco = raiz; do { printf(%i ,reco->info); reco = reco->sig; } while (reco != raiz); printf(\n); } } Para borrar el nodo de una determinada posici√≥n: void borrar (int pos) Debemos primero identificar si es el primero de la lista (ya que en este caso se modifica el puntero externo raiz): if (pos <= cantidad()) { if (pos == 1) Si es el primero y el √∫nico de la lista hacemos que raiz apunte a NULL y borramos el nodo: if (cantidad() == 1) { free(raiz); raiz = NULL; } Sino disponemos un puntero al final de la lista, avanzamos raiz y enlazamos el √∫ltimo nodo con el segundo de la lista: struct nodo *bor = raiz; struct nodo *ultimo = raiz->ant; raiz = raiz->sig; ultimo->sig = raiz; raiz->ant = ultimo; free(bor); En caso que queremos borrar un nodo que se encuentra en medio de la lista o inclusive al final debemos recorrer con un for hasta el nodo que queremos borrar y luego disponemos un puntero en el nodo anterior y otro puntero en el nodo siguiente. Seguidamente procedemos a enlazar los nodos: struct nodo *reco = raiz; int f; for (f = 1; f <= pos - 1; f++) reco = reco->sig; struct nodo *bor = reco; struct nodo *anterior = reco->ant; reco = reco->sig; anterior->sig = reco; reco->ant = anterior; free(bor); void liberar() Para borrar todos los nodos de la lista mediante un ciclo repetitivo avanzamos a partir del segundo nodo de la lista mientras el puntero reco sea distinto a la direcci√≥n del primer nodo: void liberar() { if (raiz != NULL) { struct nodo *reco = raiz->sig; struct nodo *bor; while (reco != raiz) { bor = reco; reco = reco->sig; free(bor); } free(raiz); } } Cuando salimos de la estructura repetitiva eliminamos el √∫ltimo nodo que nos queda que es el primero de la lista, utilizamos el mismo puntero raiz para eliminarlo: free(raiz); Retornar"
      },
      {
        "id": 53,
        "autor": "Andres",
        "pagina": "Lenguaje C",
        "fecha": "00/00/0000",
        "titulo": "LISTAS EN LENGUAJE C",
        "link": "http://programacion-de-lenguaje.blogspot.com/2015/05/listas.html",
        "contenido": "LENGUAJE C Inicio Temas Videos Articles Contact LISTAS EN LENGUAJE C una lista enlazada es una de las estructuras de datos fundamentales, y puede ser usada para implementar otras estructuras de datos. Consiste en una secuencia de nodos, en los que se guardan campos de datos arbitrarios y una o dos referencias, enlaces o punteros al nodo anterior o posterior. El principal beneficio de las listas enlazadas respecto a los vectores convencionales es que el orden de los elementos enlazados puede ser diferente al orden de almacenamiento en la memoria o el disco, permitiendo que el orden de recorrido de la lista sea diferente al de almacenamiento. Una lista enlazada es un tipo de dato autorreferenciado porque contienen un puntero o enlace  a otro dato del mismo tipo. Las listas enlazadas permiten inserciones y eliminaci√≥n de nodos en cualquier punto de la lista en tiempo constante (suponiendo que dicho punto est√° previamente identificado o localizado), pero no permiten un acceso aleatorio. LISTAS SIMPLES ENLAZADAS La lista enlazada b√°sica es la lista enlazada simple la cual tiene un enlace por nodo. Este enlace apunta al siguiente nodo (o indica que tiene la direcci√≥n en memoria del siguiente nodo) en la lista, o al valor NULL o a la lista vac√≠a, si es el √∫ltimo nodo. Ejemplo  de una lista sencilla o lista simple: #include<stdio.h> #include<conio.h> #include<stdlib.h> #include<alloc.h> Aqu√≠ damos a conocer la Asignaci√≥n de una lista como una estructura que almacena datos struct nodo{ int valor;        // Valor que va tener la estructura en cada uno en este caso es un numero entero struct nodo *siguiente; //Apuntador hacia el siguiente nodo o enlace }; typedef struct nodo *TipoLista; //Definicion del nombre de la lista //declaracion de funciones que posee la listas void Insertar(TipoLista &l, int v  ); void EliminarRegistro(TipoLista &l, int v); void VaciarLista(TipoLista &l); int  ListaVacia(TipoLista l); void MostrarLista(TipoLista l); void Modificar(TipoLista l, int v,int n); //***************************** int main() { TipoLista lista = NULL; Inicio de listas en Nulo int op,x,n; TipoLista p; do { clrscr(); //MENU DE OPCIONES printf(***MENU***\n\n); printf(1. Agregar dato\n); printf(2. Modificar dato\n); printf(3. Mostrar datos\n); printf(4. Eliminar dato\n); printf(5. Vaciar lista\n); printf(6. Salir\n\n); printf(Digite la opcion: ); scanf(%d,&op); switch(op) { case 1: do {  // SE CREAUNA LISTA HASTA QUE EL USUARIO PRECIONE 0 clrscr(); printf(Digite  Cero (0) para salir\n); printf(Digite el dato que desea agregar:); scanf(%d,&x); if (x!=0) Insertar(lista,x);//ENVIO DE VALOR AL PROCESO DE INSERTAR DATOS A LISTA }while (x!=0); getch(); break; case 2: MostrarLista(lista); printf(\n Digite el dato que desea modificar:); scanf(%d,&x);            //MODIFICACION DE DATOS printf(\n Digite el dato nuevo:); scanf(%d,&n);    //LEE NUEVO DATO Modificar(lista,x,n); //ENVIO A FUNCION DE ENCONTRAR DATO Y CAMBIAR A ACTUAL getch(); break; case 3: MostrarLista(lista); getch(); break; case 4: MostrarLista(lista); printf(Digite el dato que desea eliminar:); scanf(%d,&x); EliminarRegistro(lista,x);  //ELIMINA DATO QUE  VERIFICA EL USUARIO getch(); break; case 5: //  BorrarLista(lista); break; default: printf(Opcion no valida!\n); getch(); } } while(op!=6); getchar(); return 0; } //*********** //Lista Vacia int ListaVacia(TipoLista lista) { return (lista == NULL); } //************************** //Insertar registro void Insertar(TipoLista &lista, int valor) { TipoLista nuevo; nuevo = new(struct nodo); nuevo->valor = valor; nuevo->siguiente = lista; lista  = nuevo; } //************************** //Imprimir lista void MostrarLista(TipoLista lista) { TipoLista nodo = lista; if(ListaVacia(nodo)) printf(Lista vacia\n); else { while(nodo) { printf(%d -> , nodo->valor); nodo = nodo->siguiente; } printf(\n); } } //************************** //Modificar void Modificar(TipoLista lista, int v,int n) { TipoLista nodo; int ban = 0; nodo = lista; while(nodo) { if(nodo->valor == v) { nodo->valor=n; ban=1; printf(Registro Modificado\n); MostrarLista(lista); } nodo = nodo->siguiente; } if(ban== 0) printf(No se encontro el registro\n); } //************************** //Eliminar void EliminarRegistro(TipoLista &lista, int v) { TipoLista nodo, anterior; nodo= lista; int ban =0; if(lista!=NULL) { while(nodo!=NULL) { if(nodo->valor==v) { ban=1; printf(Registro Eliminado\n); if(nodo==lista) lista = lista->siguiente; else anterior->siguiente = nodo->siguiente; delete(nodo); return; } anterior = nodo; nodo =nodo->siguiente; } } else printf( Lista vacia..!\n); if(ban==0 ) printf(No se encontro el registro\n); } //Vaciar toda la lista void VaciarLista(TipoLista &lista) { TipoLista nodo; // nodo= lista; if(lista!=NULL) { while(lista!=NULL) { nodo =lista; lista = lista->siguiente; delete(nodo); } } else printf( Lista vacia..!\n); } About the author Andres Deja tu comentario : 2 comentarios: luis12 de febrero de 2019, 13:53 bloqueate el ctrl s Responder Picando codigo c3 de octubre de 2020, 00:21 Hola, que tal, estuve mirando tu c√≥digo de Lista. Tu c√≥digo lo provee. Con el compilador Dev C++. al compilar tiene muchos errores. Algunos son por falta declarar algunas funciones, adem√°s de los ;. No compila. Fijate de revisar el ejercicio. Saludos !! Gast√≥n. Responder Entrada m√°s recienteP√°gina PrincipalEntrada antigua Search... SUSCRIPCION YOUTUBE Andres Realpe PROTECCION CAMARA POPULAR POSTS no imageMATRICES EN C COLAS EN CCOLAS EN C LISTAS EN LENGUAJE CLISTAS EN LENGUAJE C GRAFOS EN CGRAFOS EN C no imagePILAS EN C no imageARBOLES B+ ARBOLES BINARIOSARBOLES BINARIOS ARBOLES EN CARBOLES EN C LISTAS DOBLEMENTE ENLAZADASLISTAS DOBLEMENTE ENLAZADAS ARREGLOS EN CARREGLOS EN C ACERCA DE M√ç Unknown Ver mi perfil completo ARCHIVO DEL BLOG ‚ñº  2015 (15) ‚ñº  mayo (15) ARBOLES AVL GRAFOS EN C ARBOLES BINARIOS ARBOLES B+ ARBOLES EN C MEMORIAS DIN√ÅMICAS LISTAS EN LENGUAJE C COLAS EN C PILAS EN C LISTAS DOBLEMENTE ENLAZADAS FUNCIONES Y PROCEDIMIENTOS MATRICES EN C Punteros ARREGLOS EN C LENGUAJE DE PROGRAMACI√ìN ( C ) Segun como lo estip... Copyright ¬© 2013 Lenguaje c - BTemplate by SoraTemplates and Blogger Themes."
      },
      {
        "id": 54,
        "autor": "Ernanvr",
        "pagina": "Platzi",
        "fecha": "00/00/2020",
        "titulo": "Pasos para crear un nodo en C (listas enlazadas)",
        "link": "https://platzi.com/tutoriales/1740-lenguaje-c-2019/6402-pasos-para-crear-un-nodo-en-c-listas-enlazadas/",
        "contenido": "Platzi isotipo Platzi Logo LIVE Platzi Live EMPRESAS Cursos Blog Foro Agenda TV Planes Cont√°ctanos INICIAR SESI√ìN Buscar en Platzi InicioCurso de Introducci√≥n a C 2019 Pasos para crear un nodo en C (listas enlazadas) Ern√°n Alexander ernanvr Seguramente m√°s de alguno quedar√° estancado en alguno de los temas de este curso, especialmente lo que estamos inici√°ndonos en el mundo de la tecnolog√≠a. Por ello realic√© un peque√±o tutorial sobre c√≥mo crear un nodo, para facilitar la comprensi√≥n del tema, ya que personalmente se me dificult√≥ much√≠simo. Here we go: Pasos para crear un nodo. a) Crear la estructura Nodo y el tipo NODO. Hay una diferencia entre typedef y struct, el primero se trata de copiar el tipo de variable, algo as√≠ como el copiar formato de office. Ejemplo: typedef int A; A a; Mi forma de interpretarlo es que le enviamos la instrucci√≥n al procesador que copie el formato de la variable A, y lo pegue en las nuevas variables que creamos seguidas de la A. Pr√°cticamente la variable A se vuelve un tipo de variable. En cambio struct creamos un √°rbol de variables, y a eso se le debe el nombre struct, que significa ‚Äúestructura‚Äù en espa√±ol. El objetivo de la utilizaci√≥n de esta palabra reservada es darle m√°s orden a las variables de nuestro programa, ya que permite agrupar las que estan relacionadas, como en una ficha cliente, nombre y direcci√≥n, es conveniente acceder a ellas mediante una estructura llamada cliente. Ejemplo: Struct Cliente { char nombre[100]; char direccion[100]; }; Volviendo a los Nodos, junto con la estructura creamos el typedef, pero con una caracter√≠stica √∫nica: la autoreferencia. Esto se logra creando un puntero del tipo estructura dentro del nodo, que permitir√° enlazar otros nodos. Ya s√©, parece que dar√° alg√∫n error, y esto es parecido al efecto de poner dos espejos uno frente del otro, pero as√≠ es el proceso, hazlo sin miedo. Ejemplo: typedef struct Node { int var_1; char var_2[5]; struct Node * next; } NODE; b) Crear la funci√≥n que dar√° existencia al nodo. Debido a que se recurrir√° en varias ocasiones a una serie de pasos para crear los nodos, es eficiente crear una funci√≥n para realizar la actividad y as√≠ ahorrar unas l√≠neas de c√≥digo. Los pasos que deben guardarse en una funci√≥n son: Declarar la funci√≥n como tipo puntero NODO. Creaci√≥n de la variable tipo NODO, declarado anteriormente. Reservar memoria para la variable. Apuntar el puntero next a NULL por defecto. Asignarle los datos recibidos como argumentos de la funci√≥n a las variables correspondientes (pr√°cticamente registrar la data del nodo). Retornar el puntero tipo NODO. Ejemplo: NODE* createNode(int number){ NODE* newNode; newNode= malloc(sizeof(NODE)); newNode->next = NULL; newNode->number = number; return newNode; c) Crear la cabecera y resto de componentes de la lista enlazada Antes de crear un nodo, debemos saber si ser√° una cabecera, cola o un nodo intermedio. Si queremos crear una cabecera declaramos una nueva variable puntero tipo NODO, y le asignamos un nodo con la funci√≥n declarada en paso anterior. Si queremos crear un nodo cola o intermedio, recorremos la lista hasta llegar al nodo cola, o al nodo que queremos anexar uno nuevo, y asignamos un nuevo nodo a su variable next, de esa manera hacemos que apunten al nuevo nodo que creamos. Ejemplo: NODE * start = NULL, * current; if(start= NULL) { start = createNode(number); } else { current = start; while(current->next) { current = current->next; }; current->next = createNode(number); Punto importante: para recorrer los nodos, siempre debe hacerse desde la cabecera, y se logra con funciones loop como while. Este ejemplo, start es la cabecera, y current es la herramienta que nos sirve para recorrer la cadena de los nodos, gracias a la variable del struct next. 1 hace un a√±o IoT Escribe tu comentario SebaC11 SebaC11 8450 Puntos 9 meses excelente aporte! Lo √∫nico para aclarar que en esta parte: typedef struct Nodo { int var_1; char var_2[5]; struct Node * next; } NODO la autoreferencia debe ser el mismo nombre del struct , para no confundir ambos deber√≠an ser ‚Äúnode‚Äù. typedef struct Node { int var_1; char var_2[5]; struct Node * next; } NODO Muhas gracias! ernanvr ernanvr 5 meses Corregido!!, gracias por la observaci√≥n. Entradas relacionadas Asignaci√≥n din√°mica de memoria Las funciones que realizan un manejo activo de la memoria del sistema requieren todas ellas para su correcto funcionamiento la inclusi√≥n, me irvingjuarez irvingjuarez Punteros Al ver que mucho de mis compa√±eros tuvieron problemas al saber que son y como se utilizan los punteros, me decide a crear este articulo en d irvingjuarez irvingjuarez Directivas pre-procesador En un programa escrito en C, es posible incluir diversas instrucciones para el compilador dentro del c√≥digo fuente del programa. Estas instr irvingjuarez irvingjuarez Sentencias de control break y continue RECOMENDACIONES Antes de que entres a este tutorial es necesario que ya tengas conocimientos del lenguaje de programaci√≥n C y que sepas util irvingjuarez irvingjuarez Platzi Transformamos la econom√≠a de nuestros pa√≠ses entrenando a la pr√≥xima generaci√≥n de profesionales en tecnolog√≠a. Aprende en nuestras redes: Marketing Startups Ingl√©s Dise√±o y UX Desarrollo e Ingenier√≠a Habilidades Blandas Contenido Digital Negocios y Emprendimiento Certificadores oficiales en tecnolog√≠as IBM Unity Reconocidos y premiados por Y Combinator ASU + GSV Summit Ent√©rate de todas las novedades en educaci√≥n, negocios y tecnolog√≠a Ingresa tu correo electr√≥nico Ingresa tu correo electr√≥nico Preguntas frecuentes Cont√°ctanos Prensa Conferencias T√©rminos y Condiciones Privacidad Estudiantes Hola PT EN De LATAM con para el mundo"
      },
      {
        "id": 55,
        "autor": "Pedro Gonz√°lez Ruiz",
        "pagina": "pedrogonzalezruiz",
        "fecha": "25/10/2015",
        "titulo": "Listas enlazadas en C",
        "link": "http://www.pedrogonzalezruiz.net/listas/listas.html",
        "contenido": "Listas enlazadas en C Pedro Gonz√°lez Ruiz Listas Una lista es una estructura din√°mica de datos. Cada objeto de la estructura est√° formado por los datos junto con un puntero al siguiente objeto. Al manejar punteros, los datos no tienen por qu√© estar situados en posiciones consecutivas de la memoria, y lo m√°s normal, es que est√©n dispersos. Debe imaginarse una lista de la siguiente forma: (O1, O2, ... , On) O1 es el primer objeto y est√° constituido por dos partes: los datos que pretendemos almacenar, que simb√≥licamente llamaremos D1, y un puntero p1 que apuntar√° al siguiente objeto, en √©ste caso O2, es decir: Discusi√≥n an√°loga para O2 y as√≠ sucesivamente. El final de la lista es el objeto On, cuyo puntero pn apunta a NULL, es decir, a ning√∫n sitio. De esta forma, podemos saber cual es el final de la lista. Cada elemento de datos, por ejemplo, el D1 de antes, ser√° una estructura (struct) en el sentido del lenguaje C. Una lista vac√≠a la representaremos de varias formas, que son: ‚àÖ (s√≠mbolo matem√°tico del conjunto vac√≠o), NULL o tambi√©n por (). T√©cnicamente hablando, una lista l contiene la direcci√≥n del primer objeto. Las listas no tienen problemas para crecer a izquierda, centro o derecha, dependiendo de lo que se pretenda conseguir. La √∫nica pega es la memoria disponible. Tambi√©n, las listas engloban a las pilas y colas. En consecuencia, saber manejar bien las listas, implica conocer m√°s cosas. Si, como consecuencia de la lectura de este art√≠culo, llega a aprender y dominar las listas, y tiene tiempo, debe plantearse estudiar el lenguaje LISP (de LISt Processing, es decir, manejo de listas), que desde mi punto de vista, es el mejor lenguaje de programaci√≥n de todos los que conozco. Las listas tambi√©n pueden estar doblemente enlazadas, es decir, cada objeto, contiene dos punteros, uno de ellos, al siguiente, como antes, y otro, al anterior. De esta forma, puede ir hacia adelante y hacia atr√°s (vea la siguiente figura): Estas no las vamos a tratar aqu√≠, aunque haciendo peque√±as modificaciones al programa, lo conseguir√° sin dificultad. Definici√≥n de lista en C Seg√∫n comentamos en el apartado anterior, es conveniente separar los datos de los punteros, as√≠ que la definici√≥n de lista es la siguiente: struct lista { /* lista simple enlazada */ struct dato datos; struct lista *sig; }; donde en alg√∫n lugar hay que definir la estructura dato. Si cambiamos esta √∫ltima, la lista tambi√©n cambia y no hay que hacer cambios en ella. Las variables est√°n claras, datos es el objeto D1 comentado antes, y sig es el puntero que apunta al siguiente objeto (el p1 de la figura). Para inicializar una lista, basta con escribir: struct lista *l; /* declaraci√≥n */ l = NULL; /* inicializaci√≥n */ Este par de sentencias constituyen la forma de crear una lista vac√≠a, es decir, l = ‚àÖ Operaciones con listas Calcular la longitud de una lista es decir, el n√∫mero de elementos que contiene. El algoritmo no puede ser m√°s simple, inicializamos un contador a cero, y vamos recorriendo la lista, incrementando dicho contador, hasta encontrar el NULL final. En concreto: /* Devuelve la longitud de una lista */ int longitudl(struct lista *l) { struct lista *p; int n; n = 0; p = l; while (p != NULL) { ++n; p = p->sig; } return n; } Insertar un dato al comienzo de una lista En concreto, sea x una estructura tipo dato y l = (O1, O2, ... , On) una lista. Despu√©s de la operaci√≥n debe quedar (x, O1, O2, ... , On) Para esto, debemos aprender a crear un nuevo nodo, lo cual es una llamada a malloc, en concreto: struct lista *creanodo(void) { return (struct lista *) malloc(sizeof(struct lista)); } Una vez visto esto, debemos hacer lo siguiente: y la funci√≥n es: /* Inserta dato al comienzo de la lista (para pilas) */ struct lista *insertacomienzo(struct lista *l, struct dato x) { struct lista *q; q = creanodo(); /* crea un nuevo nodo */ q->datos = x; /* copiar los datos */ q->sig = l; l = q; return l; } Insertar un dato al final de una lista En concreto, sea x una estructura tipo dato y l = (O1, O2, ... , On) una lista. Despu√©s de la operaci√≥n debe quedar (O1, O2, ... , On, x) Aqu√≠ debemos distinguir si l = ‚àÖ, o no. En el primer caso, debe quedar l = (x), y si l ‚â† ‚àÖ debemos situarnos en el √∫ltimo y asignar los punteros: y la funci√≥n es: /* Inserta dato al final de la lista (para colas) */ struct lista *insertafinal(struct lista *l, struct dato x) { struct lista *p,*q; q = creanodo(); /* crea un nuevo nodo */ q->datos = x; /* copiar los datos */ q->sig = NULL; if (l == NULL) return q; /* la lista argumento no es vac√≠a. Situarse en el √∫ltimo */ p = l; while (p->sig != NULL) p = p->sig; p->sig = q; return l; } Insertar un dato en una lista ordenada Se entiende por lista ordenada una lista en la que se ha definido una funci√≥n de ordenaci√≥n. Para aclarar las cosas, volvemos a nuestra imagen de lista: l = (O1, O2, ... , On) Sabemos que cada objeto O est√° formado por dos partes: el dato D y el puntero sig, con lo cual tenemos tambi√©n la sucesi√≥n de los datos: (D1, D2, ... , Dn) La lista est√° ordenada cuando tenemos definida una funci√≥n binaria f sobre los datos de forma que (D, E son estructuras tipo dato): D < E ‚áî f(D,E) = -1 D = E ‚áî f(D,E) = 0 D > E ‚áî f(D,E) = 1 Como es evidente, los valores -1,0,1 son totalmente arbitrarios y podr√≠an sustituirse por cualquier otros. Lo hacemos as√≠ por analog√≠a con los valores de retorno de algunas funciones del lenguaje C. Cuando se haya definido una funci√≥n de ordenaci√≥n sobre una lista, diremos que la lista est√° ordenada, y escribiremos: D1 ‚â§ D2 ‚â§ ‚Ä¶ ‚â§ Dn o tambi√©n: O1 ‚â§ O2 ‚â§ ‚Ä¶ ‚â§ On Veamos algunos ejemplos: En cada estructura D hay un campo para el nombre de la persona, de nombre nombre. Si queremos ordenar la lista por orden alfab√©tico creciente de nombres de personas, la funci√≥n de ordenaci√≥n es strcmp de la librer√≠a est√°ndar, de forma que: D < E ‚áî strcmp(D.nombre,E.nombre) = -1 D = E ‚áî strcmp(D.nombre,E.nombre) = 0 D > E ‚áî strcmp(D.nombre,E.nombre) = 1 Esta funci√≥n distingue entre may√∫sculas y min√∫sculas, es decir, no es lo mismo Juan que juan, raz√≥n por la cual, la librer√≠a est√°ndar provee tambi√©n de la funci√≥n strcasecmp que hace lo mismo, pero no distingue entre aquellas. En cada estructura D hay un campo para la fecha de nacimiento de una persona, constituida por tres variables enteras, que son, el d√≠a, mes y a√±o de nacimiento, de nombres respectivos d, m y a. Si queremos ordenar a las personas por fecha de nacimiento creciente, hemos de utilizar el orden lexicogr√°fico de estos tres valores, en concreto: Comparamos en primer lugar los a√±os de nacimiento. Si D.a < E.a, hemos acabado, la fecha de D es inferior a la de E, retorna -1. Si D.a > E.a, hemos acabado, la fecha de D es superior a la de E, retorna 1. En caso contrario, los a√±os son iguales, y hemos de pasar al siguiente punto. Comparamos en segundo lugar los meses de nacimiento. Si D.m < E.m, hemos acabado, la fecha de D es inferior a la de E, retorna -1. Si D.m > E.m, hemos acabado, la fecha de D es superior a la de E, retorna 1. En caso contrario, los meses son iguales, y hemos de pasar al siguiente punto. Comparamos en √∫ltimo lugar los d√≠as de nacimiento. Si D.d < E.d, hemos acabado, la fecha de D es inferior a la de E, retorna -1. Si D.d > E.d, hemos acabado, la fecha de D es superior a la de E, retorna 1. En caso contrario, las fecha son id√©nticas, retorna 0. En fin, debe ya resultar evidente lo que pretendemos, sea x una estructura tipo dato y l = (O1, O2, ... , On) una lista ordenada, es decir: O1 ‚â§ O2 ‚â§ ‚Ä¶ ‚â§ On queremos insertar x en l de forma que la lista resultante est√© tambi√©n ordenada. Un argumento de la funci√≥n es la funci√≥n de ordenaci√≥n, la cual ser√° un puntero a funci√≥n, de forma que cambiando esta funci√≥n, la lista pueda ordenarse por criterios distintos. El algoritmo es sencillo, pero exige una b√∫squeda previa, en concreto: Si la lista l es vac√≠a, entonces l = (x). Si no, es decir, si la lista no es vac√≠a, recorremos la lista hasta que encontremos el sitio adecuado para insertar el dato, concretamente, cuando x ‚â§ D, siendo D el dato actual. Para este apartado, necesitamos ir apuntando el nodo anterior, para hacer los enlaces correctamente. Tambi√©n necesitamos un indicador para parar la b√∫squeda, cuando se encuentre el sitio. Por √∫ltimo, insertar el dato en ese lugar. Veamos un ejemplo aclaratorio, y para simplificar, imaginemos un orden num√©rico sobre la lista, la cual se representar√° por sus valores. Sea l = (7, 15, 28), y el dato a insertar x = 19. Recorremos la lista hasta que x ‚â§ D. Como 19 > 7 y 19 > 15, hay que parar en el tercer elemento, ya que 19 ‚â§ 28. En este punto, el nodo anterior ant es 15 y el nodo actual es D = p = 28, y si es q el nodo correspondiente a (19), entonces, antes de insertar: Insertamos con las siguientes instrucciones: ant->sig = q; q->sig = p; Es decir: El algoritmo falla cuando no hay anterior, es decir, cuando ant = NULL. Cuando esto ocurre, la inserci√≥n es al comienzo, cuesti√≥n ya tratada en un apartado anterior. Observe que el algoritmo anterior tambi√©n funciona cuando p = NULL, es decir, cuando el objeto a insertar es al final de la lista. En este caso, las sentencias: ant->sig = q; q->sig = p; se convierten en: ant->sig = q; q->sig = NULL; lo cual es correcto. Finalmente, la funci√≥n de inserci√≥n es: /* Inserta un dato en una lista ordenada. La nueva lista debe quedar ordenada f es la funci√≥n de ordenaci√≥n */ struct lista *insertaordenado(struct lista *l, struct dato x, int (*f)(struct dato a, struct dato b)) { struct lista *p,*q,*ant; int ind; q = creanodo(); /* crea un nuevo nodo */ q->datos = x; /* copiar los datos */ q->sig = NULL; /* por defecto, puede cambiar */ if (l == NULL) { l = q; return l; } /* la lista no es nula */ ant = NULL; p = l; ind = 0; while (p != NULL && ind == 0) { if ((*f)(x,p->datos) <= 0) /* aqu√≠ hay que insertar */ ind = 1; else { ant = p; p = p->sig; } } if (ant == NULL) { /* inserci√≥n al comienzo */ q->sig = l; l = q; } else { /* inserci√≥n en medio o al final */ ant->sig = q; q->sig = p; } return l; } Eliminar un objeto de la lista En concreto, l = (O1, O2, ... , On) una lista y x una estructura tipo dato, objeto que queremos borrar de la lista. Vamos a utilizar un procedimiento recursivo, en concreto: Si l = ‚àÖ, no hay nada que borrar, retorna l. Si x = D1, entonces, liberamos la memoria de O1 y retornamos (O2, ... , On). Si no, eliminamos x en (O2, ... , On). La funci√≥n de borrado es: struct lista *elimina(struct lista *p, struct dato x, int (*f)(struct dato a, struct dato b)) { int cond; if (p == NULL) /* no hay nada que borrar */ return p; /* compara el dato */ cond = (*f)(x,p->datos); if (cond == 0) { /* encontrado! */ struct lista *q; q = p->sig; free(p); /* libera la memoria y hemos perdido el enlace, por eso se guarda en q */ p = q; /* restaurar p al nuevo valor */ } else /* no encontrado */ p->sig = elimina(p->sig,x,f); /* recurre */ return p; } Las versiones recursivas siempre son m√°s sencillas y elegantes que sus equivalentes iterativas. Un ejercicio interesante es programar la funci√≥n anterior en forma iterativa. Anular una lista En concreto, sea l = (O1, O2, ... , On) una lista. Queremos empezar de nuevo, haciendo que l = NULL. No basta con la ingenua instrucci√≥n: l = NULL; pues entonces, toda la memoria que le hemos pedido al sistema operativo se pierde para siempre. Por consiguiente, hay que devolver la memoria utilizada, con la siguiente funci√≥n: /* anula una lista liberando la memoria */ struct lista *anulalista(struct lista *l) { struct lista *p,*q; p = l; while (p != NULL) { q = p->sig; /* para no perder el nodo */ free(p); p = q; } return NULL; } y, por tanto, basta con escribir: l = anulalista(l); para que l sea la lista vac√≠a. Manejo del programa Descargue listas.tgz y siga las siguientes instrucciones: Abra un emulador de terminal, por ejemplo xterm, y sit√∫ese en un directorio donde tenga permiso de escritura para practicar. Descomprima aqu√≠ el archivo descargado, introduciendo: tar zxvf listas.tgz con lo que obtendr√° los fuentes listas.c,colas.c y pilas.c y tres archivos de datos que son: diezprimeros.txt, datos.txt y grande.txt que contienen 10, 20 y 164 personas respectivamente. Compile listas.c, para lo cual, introduzca: cc listas.c -o listas No debe tener problemas con la compilaci√≥n, pues solamente se han utilizado funciones est√°ndar del lenguaje C. La orden anterior crea el ejecutable listas. Este programa admite los siguientes argumentos: -h, muestra una peque√±a ayuda en pantalla -d archivo-de-datos, para cargar diferentes archivos de datos -a ancho-de-pantalla, para poder cambiar el ancho de pantalla, dependiendo de las capacidades del ambiente donde lo ejecute Si no introduce argumentos,por defecto, toma como archivo de datos diezprimeros.txt y el ancho de pantalla en 80 caracteres. Veamos algunos ejemplos: ./listas El archivo de datos es diezprimeros.txt y el ancho de pantalla es de 80 caracteres ./listas -d datos.txt El archivo de datos es datos.txt y el ancho de pantalla es de 80 caracteres ./listas -d datos.txt -a 140 El archivo de datos es datos.txt y el ancho de pantalla es de 140 caracteres Los archivos de datos son una simulaci√≥n aleatoria de nombres de personas, dni y fecha de nacimiento, preparados con el formato que exige el programa. Para comenzar a practicar y comprender los algoritmos, con el archivo de datos diezprimeros.txt es suficiente, ya que la impresi√≥n en pantalla no ocupa mucho espacio y le ayuda a entenderlo todo. En fin, si las condiciones son las adecuadas, el programa leer√° los datos y crear√° una lista ordenada por fecha de nacimiento creciente. Observe la l√≠nea dentro de main: l = leedatos(nomfich,&i,comparafecha); Si cambia el tercer argumento (puntero a funci√≥n) puede obtener diferentes √≥rdenes que son: comparafecha, ordena la lista por orden creciente de fechas. comparafechainversa, ordena la lista por orden decreciente de fechas. alfabetica, ordena la lista por orden creciente de nombres de personas. alfabeticainversa, ordena la lista por orden decreciente de nombres de personas. Como es evidente, cada vez que haga un cambio, debe volver a compilar el programa, ya que no se proporcionan opciones para hacerlo interactivamente. Por √∫ltimo, el programa presenta un men√∫ en pantalla. Algunas opciones son: Mostrar la lista gr√°ficamente. Se muestra en pantalla los datos le√≠dos del archivo dentro de una caja de texto, imitando los nodos. Insertar en la lista. Solicita el nombre de la persona, y para ello, no introduzca m√°s de 19 caracteres y sin espacios en blanco; el dni, mismo comentario al anterior, y la fecha de nacimiento, escr√≠bala en la forma dia/mes/a√±o, escribiendo los separadores. Ejemplos v√°lidos son: 15/1/1981, 3/2/2005, etc. Si cambia la funci√≥n de ordenaci√≥n en leedatos, tambi√©n debe cambiarla en la siguiente l√≠nea (dentro de main): l = insertaordenado(l,x,comparafecha); para respetar el orden. Borrar de la lista. Las celdas se borran por el nombre de la persona. El programa solicita el nombre de la persona. As√≠ pues, introduzca el nombre que quiere borrar. Si se encuentra, el nodo es borrado, en caso contrario, la lista queda igual. Finalmente, si encuentra alg√∫n error, comuniqu√©melo para su correcci√≥n. Pilas y colas Como ejemplo de aplicaci√≥n de listas, los dos programas pilas.c y colas.c, incluidos en el paquete, son peque√±as variaciones del principal listas.c, salvo que en las colas, la inserci√≥n de elementos es al final, y en las pilas, al principio. En ambos casos, las extracciones son al principio, con la funci√≥n: /* Extrae dato al comienzo de la lista (para pilas y colas) */ struct lista *pop(struct lista *l, struct dato *x) { if (l != NULL) { /* no hacer nada si l es nula */ struct lista *p,*q; p = l; q = p->sig; /* para no perder el enlace */ *x = p->datos; /* copiar el dato */ free(p); /* libera memoria */ l = q; return l; } } El uso de ambos programas es id√©ntico al de listas. Contacto Si desea hacer alg√∫n comentario, utilice la siguiente direcci√≥n de correo: Fecha de creaci√≥n: 26 de junio de 2010 Fecha de la √∫ltima modificaci√≥n: 25 de octubre de 2015"
      },
      {
        "id": 56,
        "autor": "Admin",
        "pagina": "Aprendo en casa",
        "fecha": "07/01/2019",
        "titulo": "LISTAS DE ENLACE SIMPLE CON UN SOLO PUNTERO",
        "link": "https://www.aprendoencasa.com/listas-de-enlace-simple-con-un-solo-puntero/",
        "contenido": "Ejercicios con soluci√≥n y pr√°cticas resueltas de programaci√≥n en c,nuevos ejercicios de programaci√≥n en lenguaje C. El enunciado de las pr√°cticas y ejercicios que se plantea es el siguiente: un nuevo ejercicio propuesto por una de nuestros seguidores del blog www.aprendoencasa.com que nos propone unos ejercicios o pr√°cticas en la que se plantea realizar una lista de enlace simple con punteros, la cual permita la inserci√≥n, eliminaci√≥n y listado de los elementos de la lista, no es la √∫nica forma de realizar el ejercicio, ni quiz√°s sea la mas adecuada seg√∫n los planteamientos de estructuras de datos, pero es f√°cilmente adaptable y comprensible para su modificaci√≥n. Vuelvo a comentar que no es la √∫nica soluci√≥n posible y que la forma de mejorar siempre estas pr√°cticas es que aport√©is vuestro granito de arena utilizando para ello los comentarios. Un saludo y gracias por vuestra visita. El ejercicio planteado es el siguiente: Pr√°cticas: Lista de Enlace simple con punteros Ejercicios y Practicas resueltas en lenguaje de programaci√≥n en lenguaje C, Cursos Online Gratuitos se plantea realizar una lista de enlace simple con punteros, la cual permita la inserci√≥n, eliminaci√≥n y listado de los elementos de la lista, no es la √∫nica forma de realizar el ejercicio, ni quiz√°s sea la mas adecuada seg√∫n los planteamientos de estructuras de datos, pero es f√°cilmente adaptable y comprensible para su modificaci√≥n. La soluci√≥n de los ejercicios que se plantean es la siguiente: A petici√≥n de un usuario del blog se ha insertado una nueva funci√≥n que busca y elimina un nodo intermedio de la lista /* Seg√∫n la petici√≥n de un usuario del blog www.aprendoencasa.comvamos a realizar un ejercicio o pr√°ctica con soluci√≥n la cual es de un nivel m√°s avanzado al habitual, la forma de solucionar la misma puede ser muy discutible seg√∫n con quien se hable y si se aplica a conciencia las estructuras de datos. En esta ocasi√≥n el ejercicio con soluci√≥n o pr√°ctica resuelta es una lista de enlace simple, la cual permite insertar elementos al final de la misma, realizar un listado de la lista, y borrar elementos de la lista, como novedad dejo a los usuarios que seg√∫n sus comentarios aporten inicialmente soluciones a la hora de seleccionar la opci√≥n denominada Salir la cual ha de realizar un borrado completo de la lista y terminar la ejecuci√≥n del programa, gracias de nuevo por sus visitas al blog www.aprendoencasa.es */ // Librerias utilizadas por el programa #include <stdio.h> #include <stdlib.h> #include <string.h> // Estructura para almacenar nodos de la lista // ser√° una lista de nombres // por lo tanto cada elemento de la lista estar√° // compuesto por una cadena que contendr√° el nombre // a almacenar y un puntero que servir√° para apuntar // al siguiente nodo de la lista, a este tipo de lista // se les denomina de enlace simple. typedef struct NodoLista { char Nombre[50]; struct NodoLista *Siguiente; } Nodo; // Predefinici√≥n de funciones int InsertarElemento(Nodo **); void ListarElementos(Nodo *); int BorrarElementoListaFinal(Nodo **); int BorrarElementoListaPrincipio(Nodo **); int BorrarElementoIntermedio(Nodo **); // Funci√≥n principal int main(int argc, char *argv[]) { // Crear el puntero Ra√≠z de la lista // y se inicializa a nulo como valor // inicial Nodo *Inicio = NULL; // Crear una variable para solicitar las // opciones del men√∫ int opcion=0; int opcion2=0; // Visualizar el menu de opciones do { printf(\n1.- Insertar elemento en la lista.); printf(\n2.- Listar elementos de la lista.); printf(\n3.- Borrar elemento de la lista.); printf(\n0.- Salir del programa.); printf(\n=====================================); printf(\nOpcion ...: ); scanf( %d,&opcion); switch(opcion) { case 1: // Insertar elemento de la lista // El puntero de inicio se ha de pasar por referencia // ya que es puede verse afectado si se inserta el primer // elemento de la lista InsertarElemento(&Inicio); break; case 2: // Listar elementos de la lista ListarElementos(Inicio); break; case 3: printf(\n(0) Volver Menu Anterior.); printf(\n(1) Borrar al final.); printf(\n(2) Borrar al principio.); printf(\n(3) Borrar Intermedio.); printf(\n.... ); scanf( %d,&opcion2); switch(opcion2) { case 1: BorrarElementoListaFinal(&Inicio); break; case 2: BorrarElementoListaPrincipio(&Inicio); break; case 3: BorrarElementoIntermedio(&Inicio); break; } break; } } while(opcion!=0); system(PAUSE ); return 0; } // Funci√≥n para insertar un elemento en la lista // al final de la misma, como se puede observar // el puntero de inicio que se recibe se ha pasado // por referencia y por tanto se ha de especificar // con un doble asterisco int InsertarElemento(Nodo **Inicio) { Nodo *Elemento = NULL; Nodo *Recorrer = NULL; Nodo *Ultimo = NULL; // Recorremos la lista hasta llegar al final // de la misma, en el puntero ultimo se quedara // almacenado la direcci√≥n de memoria del ultimo // elemento de la lista, si no existe ning√∫n elemento // en la lista se queda con valor nulo asignado // En primer lugar se asigna el contenido del puntero // de inicio al puntero recorrer Recorrer = *Inicio; while(Recorrer!=NULL) { Ultimo = Recorrer; Recorrer=Recorrer->Siguiente; } // Creamos el nuevo nodo o elemento que se quiere // insertar Elemento = (Nodo *)malloc(sizeof(Nodo)); // si ha existido un problema y no se crea el elemento // devolver un error, este tipo de interrupci√≥n del c√≥digo // es preferible realizarlo utilizando condicionales y // insertando un return para forzar la finalizaci√≥n de // la funci√≥n if(Elemento == NULL ) return -1; // Si se llega a este punto el elemento ha sido creado y // solicitamos el nombre que se ha de almacenar en el // mismo printf(\nTeclear Nombre : ); scanf( %s,Elemento->Nombre); // asignamos el valor nulo al puntero siguiente de la lista // ya que este elemento ser√° el ultimo de la misma y por // tanto no hay mas elementos posteriores Elemento->Siguiente = NULL; // Modificamos el puntero siguiente del ultimo elemento de la // lista para que apunte al elemento nuevo creado preguntando // primero si el valor de ultimo es null, ya que si es as√≠ // significa que el elemento nuevo creado es el primero y por // tanto hay que modificar el puntero de inicio if (Ultimo == NULL ) { // Es el primero de la lista *Inicio = Elemento; } else { // Es el ultimo de la lista Ultimo->Siguiente = Elemento; } // Salir de la funci√≥n sin errores return 0; } // Funci√≥n para listar elementos de la lista // Se recibe como valor el contenido del puntero // que indica el primer elemento de la lista void ListarElementos(Nodo *Inicio) { // Se crea una variable para recorrer la lista // asign√°ndole como primer valor el elemento al // cual apunta el puntero de inicio Nodo *Recorrer = Inicio; // Se visualiza un mensaje printf(\nListado de elementos de la lista); printf(\n===================================); // Si hay elementos en la lista se recorre // intercambiando el valor del puntero siguiente // asign√°ndolo al puntero recorrer que indica que // existe o no un elemento seg√∫n su valor while(Recorrer!=NULL) { // Se visualiza el elemento printf(\n%s,Recorrer->Nombre); // Se cambia al elemento siguiente Recorrer=Recorrer->Siguiente; } printf(\n===================================\n); } // Funci√≥n Borrar elemento de la lista al principio int BorrarElementoListaPrincipio(Nodo **Inicio) { // Variable para almacenar el elemento a borrar Nodo *Borrar=NULL; // Se comprueba si el puntero de inicio apunta a // alg√∫n elemento si es as√≠ es que existen elementos // y se puede borrar el primero en caso contrario // no existe ning√∫n elemento y no se puede borrar nada if (*Inicio==NULL) { printf(\nNo hay elementos que borrar\n); return -1; } else { Borrar = *Inicio; *Inicio = (*Inicio)->Siguiente; free (Borrar); } return 0; } // Funci√≥n Borrar elemento de la lista al final int BorrarElementoListaFinal(Nodo **Inicio) { Nodo *Borrar=NULL;; Nodo *Recorrer=NULL; Recorrer=*Inicio; if(Recorrer==NULL) { printf(\nNo existen elementos que borrar\n); return -1; } // Mientras no se llegue al ultimo elemento while(Recorrer->Siguiente!=NULL) { Borrar = Recorrer; Recorrer= Recorrer->Siguiente; } // Si borrar es null es que solo existe un elemento // y por tanto el valor de inicio ha de cambiar si no // es as√≠ existen mas elementos y se ha borrar el ultimo if(Borrar==NULL) { Borrar = *Inicio; *Inicio = NULL; free (Borrar); } else { free(Borrar->Siguiente); Borrar->Siguiente=NULL; } return 0; } // Funci√≥n Borrar elemento de la lista al principio int BorrarElementoIntermedio(Nodo **Inicio) { // Variables para usar la lista Nodo *Recorrer=NULL; Nodo *Borrar=NULL; Nodo *Anterior=NULL; // Variable para solicitar el elemento a borrar char NombreBuscar[30]; int encontrado=0; // Solicitar el nombre a eliminar printf(\nNombre a eliminar: ); scanf( %s,NombreBuscar); // Se comprueba si el puntero de inicio apunta a // alg√∫n elemento si es as√≠ es que existen elementos // y se puede borrar el primero en caso contrario // no existe ning√∫n elemento y no se puede borrar nada if (*Inicio==NULL) { printf(\nNo hay elementos que borrar\n); return -1; } else { // Recorrer la lista buscando el elemento printf(\nBuscando: %s ,NombreBuscar); Recorrer = *Inicio; Anterior = *Inicio; while(Recorrer!=NULL && encontrado==0) { // Se visualiza el elemento printf(.); if(strcmp(Recorrer->Nombre,NombreBuscar)==0) { printf( (Encontrado Ok)\n); encontrado=1; Borrar = Recorrer; if(Recorrer==*Inicio) { *Inicio = Recorrer->Siguiente; } else { Anterior->Siguiente = Borrar->Siguiente; } free(Borrar); } else { // Se cambia al elemento siguiente Anterior = Recorrer; Recorrer=Recorrer->Siguiente; } } } return 0; } Copy El resultado ha de ser similar al que se muestra en la siguiente imagen, al ejecutar el programa. Listas de enlace simple Ejercicios y practicas en C, listas de enlace simple. Ejercicios y practicas en C, listas de enlace simple. Ejercicios y practicas en C, listas de enlace simple. Gracias por vuestra visita y un saludo!!!"
      },
      {
        "id": 57,
        "autor": "NGuerrero",
        "pagina": "Programa en Linea",
        "fecha": "31/12/2019",
        "titulo": "La lista enlazada simple",
        "link": "https://www.programaenlinea.net/la-lista-enlazada-simple/",
        "contenido": "Prerrequisitos Los prerrequisitos son los tipos de datos, las estructuras, el uso de typedef, los punteros y las funciones usuario. Introducci√≥n El objetivo de este art√≠culo es el de comprender el uso de las listas enlazadas simples. Las listas enlazadas pueden ser utilizadas cuando se necesitan hacer varias operaciones de inserci√≥n y eliminaci√≥n de elementos. Definici√≥n Las listas enlazadas son estructuras de datos semejantes a los array salvo que el acceso a un elemento no se hace mediante un indice sino mediante un puntero. La asignaci√≥n de memoria es hecha durante la ejecuci√≥n. En una lista los elementos son contiguos en lo que concierne al enlazado. En cambio, mientras que en un array los elementos est√°n contiguos en la memoria, en una lista los elementos est√°n dispersos. El enlace entre los elementos se hace mediante un puntero. En realidad, en la memoria la representaci√≥n es aleatoria en funci√≥n del espacio asignado. El puntero siguiente del √∫ltimo elemento tiene que apuntar hacia NULL (el fin de la lista). Para acceder a un elemento, la lista es recorrida comenzando por el inicio, el puntero Siguientepermite el cambio hacia el pr√≥ximo elemento. El desplazamiento se hace en una sola direcci√≥n, del primer al √∫ltimo elemento. Si deseas desplazarte en las dos direcciones (hacia delante y hacia atr√°s) deber√°s utilizar las listas doblemente enlazadas. Construcci√≥n del modelo de un elemento de la lista Para establecer un elemento de la lista, ser√° utilizado el tipo struct. El elemento de la lista tendr√° un campo dato y un puntero siguiente. El puntero siguiente tiene que ser del mismo tipo que el elemento, si no, no podr√° apuntar hacia el elemento. El puntero siguiente permitir√° el acceso al pr√≥ximo elemento. Para tener el control de la lista es preferible guardar determindos elementos: el primer elemento, el √∫ltimo elemento, el n√∫mero de elementos. Para ello ser√° empleado otra estructura (no es obligatorio, pueden ser utilizadas variables). El puntero inicio tendr√° la direcci√≥n del primer elemento de la lista. El puntero fin albergar√° la direcci√≥n del √∫ltimo elemento de la lista. La variable tama√±o contiene el n√∫mero de elementos. Cualquiera sea la posici√≥n en la lista, los punteros inicio y fin apuntan siempre al primer y √∫ltimo elemento. El campo tama√±o contendr√° al numero de elementos de la lista cualquiera sea la operaci√≥n efectuada sobre la lista. Operaciones sobre las listas enlazadas Para la inserci√≥n y la eliminaci√≥n, una √∫nica funci√≥n bastar√° si est√° bien concebida de acuerdo a lo que se necesite. Debo recordar que este art√≠culo es puramente did√°ctico. Por lo tanto, he escrito una funci√≥n para cada operaci√≥n de inserci√≥n y eliminaci√≥n. Inicializaci√≥n Modelo de la funci√≥n: Esta operaci√≥n debe ser hecha antes de otra operaci√≥n sobre la lista. Esta comienza el puntero inicio y el puntero fin con el puntero NULL, y el tama√±o con el valor 0. La funci√≥n Inserci√≥n de un elemento en la lista A continuaci√≥n el algoritmo de inserci√≥n y el registro de los elementos: declaraci√≥n del elemento que se va a insertar, asignaci√≥n de la memoria para el nuevo elemento, llena el contenido del campo de datos, actualizaci√≥n de los punteros hacia el primer y √∫ltimo elemento si es necesario. Caso particular: en una lista con un √∫nico elemento, el primero es al mismo tiempo el √∫ltimo. Actualizar el tama√±o de la lista Para a√±adir un elemento a la lista se presentan varios casos: la inserci√≥n en una lista vac√≠a, la inserci√≥n al inicio de la lista, la inserci√≥n al final de la lista y la inserci√≥n en otra parte de la lista. Inserci√≥n en una lista vac√≠a Ejemplo de la funci√≥n: La funci√≥n retorna 1 en caso de error, si no devuelve 0. Las etapas son asignar memoria para el nuevo elemento, completa el campo de datos de ese nuevo elemento, el puntero siguiente de este nuevo elemento apuntar√° hacia NULL (ya que la inserci√≥n es realizada en una lista vac√≠a, se utiliza la direcci√≥n del puntero inicio que vale NULL), los punteros inicio y fin apuntaran hacia el nuevo elemento y el tama√±o es actualizado La funci√≥n Te esperamos en la segunda parte del articulo y otros en donde hablaremos mas acerca de estos temas, los cuales hoy en d√≠a son de vital importancia en el mundo de la tecnolog√≠a."
      },
      {
        "id": 58,
        "autor": "programacioniiuno",
        "pagina": "programacioniiuno",
        "fecha": " 21/04/2021",
        "titulo": "Listas Enlazadas en C",
        "link": "https://sites.google.com/site/programacioniiuno/mi-cursada/bitacoras/26042013-clase4-listasenlazadasenc",
        "contenido": "Intro Hasta el momento hemos estructurado nuestros datos en la memoria utilizando registros (Struct) y vectores. Tambi√©n, hemos vinculado alg√∫n registro con otro usando punteros, (Por ejemplo, cuando hacemos un registro con los datos b√°sicos de la persona y le agregamos un puntero a datos opcionales). Sin embargo la capacidad de enlazar registros nos permite realizar estructuras m√°s complejas, enlazando nodos entre ellos. La primer estructura que vemos siguiendo esta idea es la de una lista enlazada. Una lista enlazada compite en cierta forma con un array din√°mico (de esos que redimensionamos con realloc), ya que tanto con listas enlazadas o con vectores din√°micos podemos implementar un TDA al que denominamos Lista. En un breve an√°lisis descubrimos que una implementaci√≥n basada en array nos conviene en caso de tener un problema que requiera muchas b√∫squedas sobre los elementos, ya que puedo acceder directamente por el √≠ndice. Mientras que en una lista enlazada conviene en aquellos casos en que tenemos muchas modificaciones sobre la lista (se agregan o eliminan elementos bastante frecu√©ntemente) TDA Lista Definimos una primer interfaz de nuestro TDA, en el cual agregamos y borramos elementos por el final de la lista. TDA:Lista crearLista() -> Lista agregarAlFinal(Lista, Elemento) eliminarUltimo(Lista) liberarLista(Lista) y le agregamos un m√©todo para imprimir todos los elementos (s√≥lo para probar como funciona, ya que no le agregamos los m√©todos para consultar por un elemento). imprimir(Lista) imprimirLista(Lista) Implementaci√≥n: Structs Los elementos que queremos agregar y borrar a la lista son registros que corresponden a Personas (tienen nombre y edad). Aclaramos que Persona podr√≠a tener su propio TDA, pero como nos enfocamos en la Lista, dejamos el struct a la vista del usuario en el encabezado. Detectamos que necesitamos 3 structs para cumplir el objetivo. Lista: Nuestra lista lo √∫nico que necesita es un puntero al primer nodo. Nodo: Cada eslab√≥n de la lista tiene que contener un elemento y un puntero al que le sigue. Nos damos cuenta que Lista no puede ser Nodo ya que no tiene asociado un elemento. Elemento: Es lo que agregamos y quitamos a la lista (En clase lo llamamos Data) En lista.h tenemos: struct ListaStruct; typedef struct ListaStruct  Lista; struct DataStruct { char nombre[30]; int edad; }; typedef struct DataStruct Data; Y en lista.c struct NodoStruct { Data data; struct NodoStruct * siguiente; }; typedef struct NodoStruct Nodo; struct ListaStruct { Nodo * primero; }; Implementaci√≥n: constructor y destructor La construcci√≥n y destrucci√≥n de una lista es similar a lo que ya ven√≠amos trabajando. (ojo que el destructor m√°s adelante lo volvemos a modificar) lista.h Lista*  crearLista(); void liberarLista(Lista * lista); lista.c Lista*  crearLista() { Lista * lista =  malloc(sizeof(Lista)); lista->primero = NULL; return lista; } void liberarLista(Lista * lista) { free(lista); } Agregar un elemento al final Para agregar un elemento a la lista, detectamos que necesitamos hacer cosas distintas si se trata de una lista vac√≠a o una lista con alg√∫n elemento. Si es una lista vac√≠a, se necesita modificar el puntero primero que tiene la lista Si es una lista con elementos, se necesita modificar el puntero siguiente que tiene el √∫ltimo nodo. Como saber si una lista vac√≠a es algo que le puede intersar al usuario de nuestro TDA, lo agregamos al .h lista.h int listaVacia(Lista * lista); void agregarAlFinal(Lista * lista, char * nombre, int edad); lista.c int listaVacia(Lista * lista) { return lista->primero == NULL; } Nodo * crearNodo(char * nombre, int edad) { Nodo * nodo = malloc(sizeof(Nodo)); nodo->data.edad = edad; strcpy(nodo->data.nombre, nombre); nodo->siguiente = NULL; return nodo; } void agregarAlFinal(Lista *lista, char * nombre, int edad) { Nodo * nodo = crearNodo(nombre, edad); //si tengo que agregar al principio? if (listaVacia(lista)) { agregarEnListaVacia(lista, nodo); } else { agregarEnElFinal(lista, nodo); } } Agregar en la lista vac√≠a es sencillo: void agregarEnListaVacia(Lista * lista, Nodo * nodo) { lista->primero = nodo; } Pero agregar al final tiene una complejidad: recorrer la lista. Anteriormente, la √∫nica estructura que recorr√≠amos eran vectores, ya sea con notaci√≥n vectorial int i = 0; while (i < size) { vector[i]; //asi accedo a la info i++ } O con aritm√©tica de punteros int* p = vector; while (p < vector + size) { *p; //asi accedo a la info p++; } Pero para estas estructuras esa forma de recorrer no sirve, ya que los nodos no est√°n en espacios contiguos. Por eso para recorrer una estructura enlazada hacemos: Nodo * punteroVariable = lista->primero; while(punteroVariable != NULL) { *punteroVariable; //asi accedo a la info punteroVariable = punteroVariable->siguiente } Como para agregar un elemento del final necesito llegar hasta el √∫ltimo nodo pero sin pasarme la condici√≥n del while cambia: void agregarEnElFinal(Lista *lista, Nodo* nodo) { Nodo * punteroVariable = lista->primero; while(punteroVariable->siguiente != NULL) { punteroVariable = punteroVariable->siguiente; } //En este punto punteroVariable me apunta al √∫ltimo nodo de la lista punteroVariable->siguiente = nodo; } Actualizando el destructor Tomamos nota de que nuestro destructor solo est√° liberando el struct lista y no a sus nodos, por lo tanto modificamos el c√≥digo para recorrer la lista e ir liberando los nodos. Necesito una variable auxiliar para poder avanzar el puntero y luego liberar (ya que si lo hago en el orden inverso accedo a memoria que ya no es m√≠a) void liberarLista(Lista * lista) { Nodo * punteroVariable = lista->primero; Nodo * nodoALiberar; while (punteroVariable != NULL) { nodoALiberar = punteroVariable; punteroVariable = punteroVariable->siguiente; free(nodoALiberar); } free(lista); } Eliminando un elemento Cuando eliminamos un elemento, tambi√©n tenemos que tener en cuenta si estamos tratando con el √∫ltimo elemento de la lista o no, ya que en un caso hay que modificar el puntero del struct lista, mientras que en otro caso modificamos el siguiente del anteultimo elemento. Nuestra forma de resolverlo implica preguntar por la cantidad de elementos de la lista (Tambi√©n modificamos el TDA para exponer esa funci√≥n) lista.h void eliminarUltimo(Lista * lista); int tamanio(Lista * lista); lista.c Para contar simplemente contamos :) int tamanio(Lista * lista) { int count = 0; Nodo * puntero = lista->primero; while (puntero != NULL) { count++; puntero = puntero->siguiente; } return count; } El c√≥digo de eliminar al final es: void eliminarUltimo(Lista * lista) { if (tamanio(lista) == 1) { eliminarUnicoElemento(lista); } else { eliminarEnElFinal(lista); } } Eliminar un √∫nico elemento no trae problemas void eliminarUnicoElemento(Lista * lista) { free(lista->primero); lista->primero = NULL; } Pero para eliminar en el final nos damos cuenta que necesitamos dos punteros, porque si tenemos uno s√≥lo, al detectar el √∫ltimo elemento de la lista se nos escap√≥ el anteultimo, el cual necesitamos para indicarle que es el nuevo final de la lista seteando  NULL en su siguiente. void eliminarEnElFinal(Lista * lista) { Nodo * anterior = lista->primero; Nodo * actual = lista->primero->siguiente; while (actual->siguiente != NULL) { anterior = actual; actual = actual->siguiente; } free(actual); anterior->siguiente = NULL; } En este punto ya tenemos nuestro TDA completo, sin embargo una cosa que le quisimos agregar y nos oblig√≥ a pensar un poco m√°s es el agregar un elemento con una posici√≥n. Si la posici√≥n a agregar es 0 (el primer elemento) significa que tenemos que modificar el puntero del struct lista, en otro caso hay que modificar el siguiente de un nodo. lista.h void agregarEnPosicion(Lista * lista, int posicion, char * nombre, int edad); lista.c void agregarEnPosicion(Lista * lista, int posicion, char * nombre, int edad) { Nodo * nodo = crearNodo(nombre, edad); if (posicion == 0) { agregarPrimero(lista, nodo); } else { agregarEnElMedioOAlFinal(lista, posicion, nodo); } } Cuando analizamos la opci√≥n de agregar en la primer posici√≥n, nos damos cuenta que el c√≥digo a escribir puede ser el mismo tanto de si se trata de una lista vac√≠a o una lista llena. Hay que: asignar el siguiente del nuevo nodo a lo que antes se conoc√≠a como el primer elemento de la lista. Si no exist√≠a el nodo, el primero es NULL y por ende el siguiente del nuevo nodo tambi√©n ser√° NULL indicando as√≠ el final de la lista. Luego hay que hacer que el puntero primero del struct  lista apunte al nodo. lista.c void agregarPrimero(Lista * lista, Nodo * nodo) { Nodo * primeroAnterior = lista->primero; lista->primero =  nodo; nodo->siguiente = primeroAnterior; } Una suerte parecida ocurre al modificar un elemento del medio o del final. el √∫ltimo elemento de la lista tiene NULL como siguiente y se traslada al siguiente del nuevo nodo si es que deb√≠a agregarse al final. Al igual que lo hicimos anteriormente, necesitamos recordar el nodo anterior del buscado. lista.c void agregarEnElMedioOAlFinal(Lista * lista, int posicion, Nodo * nodo) { Nodo * anterior = lista->primero; Nodo * actual = lista->primero->siguiente; int count = 1; while (count < posicion) { anterior = actual; actual = actual->siguiente; count++; } nodo->siguiente = actual; anterior->siguiente = nodo; } Estas funciones las usamos desde un main de prueba. por ejemplo: main.c #include lista.h #include <stdio.h> int main(int argc, char **argv) { Lista * lista; lista = crearLista(); agregarAlFinal(lista, Javier, 30); agregarAlFinal(lista, Leo, 32); agregarEnPosicion(lista, 1, Pablo, 29); imprimirLista(lista); printf(\n) eliminarUltimo(lista); imprimirLista(lista); liberarLista(lista); return 0; } Que nos qued√≥ en el tintero (y que ya est√°n en condiciones de resolver solitos) Hacer un eliminar que reciba una posici√≥n Modificar la funci√≥n agregarAlFinal para que reutilice el m√©todo que recibe una posici√≥n"
      },
      {
        "id": 59,
        "autor": "Vladimiro Camaleo",
        "pagina": "Loguea me",
        "fecha": "17/04/2020",
        "titulo": "Punteros y listas enlazadas",
        "link": "https://www.loguea.me/2020/04/17/punteros_y_listas_enlazadas.html",
        "contenido": "Una de las estructuras de datos b√°sicas en computaci√≥n, aunque tal vez no tan conocida, es la lista enlazada. Hace tiempo, el profesor David Brailsford de la universidad de Nottingham explic√≥ en un video en Computerphile c√≥mo funcionan las listas enlazadas. El profesor usa bloques de Lego para comunicar de manera simple las ideas detr√°s de esto. En esta entrada abordar√© las mismas ideas, pero con enfoque en el c√≥digo m√°s que en las analog√≠as. Despu√©s de todo, es dif√≠cil mejorar el excelente trabajo del profesor Brailsford. Un nodo Una lista consta de una serie de nodos enlazados por medio de punteros. El primer paso para entenderlas es empezar por uno de sus componentes. typedef struct _nodo { char *palabra; struct _nodo *siguiente; } Nodo; Esto combina dos conceptos de C: Las estructuras, que se declaran con la palabra struct seguida del nombre que le daremos. Las estructuras agrupan varios tipos de variables primitivas. Declaraci√≥n de tipo, que usa la palabra typedef y al final de la llave una palabra clave que lo identificar√°. Esto nos permite declarar nuevos tipos de variables. Nota que la estructura nodo contiene un puntero de tipo char, que permite guardar palabras; y un puntero de tipo nodo, que permite apuntar hacia el siguiente nodo en la lista. Ahora necesitamos une m√©todo para de crear nodos. Como haremos esto frecuentemente lo mejor es poner el c√≥digo en una funci√≥n. Nodo *crear_nodo(char *texto) { Nodo *nodo = NULL; nodo = (Nodo *)malloc(sizeof(Nodo)); nodo->palabra = texto; nodo->siguiente = NULL; return nodo; } Analicemos paso a paso la funci√≥n: La declaraci√≥n indica que esta funci√≥n regresa un puntero de tipo Nodo. La primera l√≠nea crea un puntero de tipo Nodo que no apunta a ning√∫n lado, por eso tiene el valor NULL. Algunos programadores recomiendan establecer el valor de nuevos punteros expl√≠citamente a NULL. Enseguida reservamos memoria para el nuevo nodo. Esta linea tiene dos partes principales. La instrucci√≥n malloc que reserva memoria del tama√±o indiciado en su par√°metro y regresa un puntero que apunta hacia ese registro creado en la memoria. Luego la expresi√≥n entre par√©ntesis convierte el puntero en un puntero de tipo Nodo (esto se conoce como pointer casting). Las expresiones nodo->texto y nodo->palabra asignan los valores correspondientes dentro de la estructura. La notaci√≥n con flechas se usa para asignaci√≥n en punteros de estructuras. Para manipular estructuras directamente se usa un punto. Finalmente return nodo termina la ejecuci√≥n del c√≥digo en la funci√≥n y regresa el valor de nodo. Y bueno, as√≠ es C, control preciso a cambio de una sintaxis rebuscada. Ahora vamos a probar nuestro generador de nodos en el programa principal: int main(void) { Nodo *cabeza = NULL; cabeza = crear_nodo(nariz); printf(La palabra es: %s \n, cabeza->palabra); return 0; } Por supuesto la salida al compilar y ejecutar el programa es la siguiente: La palabra es: nariz Enlazando nodos Ahora que podemos crear nodos, vamos conectarlos para crear una lista enlazada. Haremos esto directamente en nuestra funci√≥n principal: cabeza->siguiente = crear_nodo(papel); cabeza->siguiente->siguiente = crear_nodo(pie); Agregamos dos nodos adicionales. La lista completa queda identificada por el nodo que est√° a la cabeza. Ahora bien, hay que imprimir la lista completa, y hacerlo usando un mont√≥n de flechas para acceder a cada nodo no es la forma m√°s eficiente. As√≠ que vamos a escribir una funci√≥n para imprimir todas las palabras en la lista: void imprimir_lista(Nodo *lista) { Nodo *temporal = NULL; temporal = lista; while (temporal) { printf(elemento: %s \n, temporal->palabra); temporal = temporal->siguiente; } } La √∫nica parte interesante aqu√≠ es el puntero temporal que nos permite recorrer cada elemento de la lista. La asignaci√≥n temporal = temporal->siguiente asigna al elemento temporal el siguiente en la lista, hasta que se encuentra con NULL. Si lo usamos en nuestra funci√≥n principal: imprimir_lista(cabeza); Obtenemos la salida de texto esperada. elemento: nariz elemento: papel elemento: pie Insertar elementos usando punteros dobles Ahora solo nos resta encontrar una mejor forma de insertar nuevos elementos en la lista, que no sea esa seguidilla de flechas apuntando hacia el siguiente elemento. Vamos a ser un poco ambiciosos. Nuestro objetivo es que cada que insertemos un nuevo elemento este se ubique correctamente en orden alfab√©tico. Estas son la cosas a considerar: Si insertamos un nuevo elemento al inicio debemos asegurarnos que el puntero cabeza apunta a la direcci√≥n de memoria correcta. Al insertar un elemento entre dos existentes hay que asegurarnos que todo se actualice correctamente. Debemos desconectar los nodos y reconectarlos asegur√°ndonos de que los campos siguiente de cada uno apuntan a donde deben apuntar. Esto adem√°s requiere un puntero temporal auxiliar. Hay que asegurarnos de que nos detendremos al encontrar el puntero NULL. Al insertar elementos al final de la lista debemos tener en cuenta que el campo siguiente del √∫ltimo elemento es un puntero nulo. Y por supuesto hay que encontrar una forma de determinar si una palabra va despu√©s de otra alfab√©ticamente. Esta parte f√°cil porque existe una funci√≥n en la librer√≠a string que hace eso. Tratar de implementar las consideraciones listadas requiere crear una funci√≥n espec√≠fica para cada caso. Pero existe un truco s√∫per f√°cil de implementar usando un puntero que apunta a un puntero. √âste es el c√≥digo: void insertar_elemento(Nodo **lista, Nodo *nuevo) { Nodo **rastreador = lista; while ((*rastreador != NULL) && strcmp((*rastreador)->palabra, nuevo->palabra) < 1) { rastreador = &(*rastreador)->siguiente; } nuevo->siguiente = *rastreador; *rastreador = nuevo; } Luego lo usamos en la funci√≥n principal. int main(void) { Nodo *cabeza = NULL; cabeza = crear_nodo(nariz); insertar_elemento(&cabeza, crear_nodo(papel)); insertar_elemento(&cabeza, crear_nodo(zapato)); insertar_elemento(&cabeza, crear_nodo(elefante)); insertar_elemento(&cabeza, crear_nodo(pie)); imprimir_lista(cabeza); return 0; } Y el resultado es el siguiente: elemento: elefante elemento: nariz elemento: papel elemento: pie elemento: zapato C√≥mo funciona Aunque la implementaci√≥n es simple, el entender la funci√≥n insertar_elemento no lo es tanto. Vamos a analizarla con cuidado. La funci√≥n toma dos par√°metros: un puntero hacia un puntero de tipo Nodo, y un puntero de tipo Nodo. El usar un puntero hacia un puntero, o una referencia doble, parece extra√±o pero es justo esto lo que simplifica el c√≥digo. La l√≠nea Nodo **rastreador = lista crea un puntero que apunta hacia el puntero del inicio de la lista. Esto es importante, este puntero apunta hacia la direcci√≥n de memoria que contiene los registros donde encontraremos cada nodo. El bucle while verifica que no hayamos llegado al final de la lista o sobrepasado la siguiente palabra en orden alfab√©tico. El rastreador actualiza su valor apuntando al siguiente registro de memoria en la lista en cada paso, tal como lo hace el puntero en la funci√≥n imprimir_lista. La pen√∫ltima l√≠nea de la funci√≥n garantiza que el campo siguiente del nodo que vamos a insertar apunta hacia el elemento correcto. La √∫ltima l√≠nea actualiza el valor del puntero rastreador, que previamente apuntaba al elemento inmediatamente siguiente al nodo que insertaremos. Esto garantiza que el puntero inmediatamente anterior actualiza correctamente su campo siguiente. Para entender claramente la funci√≥n hay que entender correctamente qu√© hace un puntero doble. La primera vez que se encuentra uno esta sintaxis puede tomar un buen rato comprender lo que est√° pasando. Mi √∫nica recomendaci√≥n es releer el c√≥digo y tratar con diferente ejemplos, hasta que est√©s seguro de que entiendes c√≥mo funciona. A continuaci√≥n puedes ver el c√≥digo completo de lo que discutimos en este post: #include <stdlib.h> #include <stdio.h> #include <string.h> typedef struct _nodo { char *palabra; struct _nodo *siguiente; } Nodo; Nodo *crear_nodo(char *texto) { Nodo *nodo = NULL; nodo = (Nodo *)malloc(sizeof(Nodo)); nodo->palabra = texto; nodo->siguiente = NULL; return nodo; } void imprimir_lista(Nodo *lista) { Nodo *temporal = NULL; temporal = lista; while (temporal) { printf(elemento: %s \n, temporal->palabra); temporal = temporal->siguiente; } } void insertar_elemento(Nodo **lista, Nodo *nuevo) { Nodo **rastreador = lista; while ((*rastreador != NULL) && strcmp((*rastreador)->palabra, nuevo->palabra) < 1) { rastreador = &(*rastreador)->siguiente; } nuevo->siguiente = *rastreador; *rastreador = nuevo; } int main(void) { Nodo *cabeza = NULL; cabeza = crear_nodo(nariz); insertar_elemento(&cabeza, crear_nodo(papel)); insertar_elemento(&cabeza, crear_nodo(zapato)); insertar_elemento(&cabeza, crear_nodo(elefante)); insertar_elemento(&cabeza, crear_nodo(pie)); imprimir_lista(cabeza); return 0; } Referencias adicionales Adem√°s del video referido al inicio existe un segundo video en el que el Profesor Brailsford explica punteros dobles. Y un video adicional en el que muestra la implementaci√≥n. Entrada de Vladimiro Camaleo Clasificado como: compus Etiquetas: programaci√≥n, c, estructuras"
      },
      {
        "id": 60,
        "autor": "Cristina",
        "pagina": "Resolviendo Ejercicios de programacion",
        "fecha": "12/03/2014",
        "titulo": "Aprendiendo a programar entre todos",
        "link": "https://resolviendoejerciciosdeprogramacion.blogspot.com/2014/03/listas-enlazadas-en-c.html",
        "contenido": "Listas enlazadas en C. En esta entrada vemos como implementar listas enlazadas en C. Para ello es importante conocer algo de punteros para lo que recomiendo echar un vistazo a esta entrada a aquellos que no manejen nada el tema. Adem√°s este ejercicio es muy parecido a la pr√°ctica de Gesti√≥n de Memoria, incluso m√°s f√°cil. Aqu√≠ os dejo tanto el archivo .h (header) como el .c -> LinkedList.h LinkedList.c Cada nodo de la lista est√° formado por : Un elemento del tipo deseado, en nuestro caso unsigned. Un puntero al pr√≥ximo nodo, o null si es el √∫ltimo. Por tanto cada nodo estar√° definido as√≠. typedef struct TNodo * TLista; // defino el tipo TLista, que es un puntero a un registro struct TNodo { unsigned valor; TLista sig; }; Como vemos, hay dos elementos en el registro: Un elemento llamado valor de tipo natural. Un puntero al pr√≥ximo nodo, pues TLista es un puntero a un nodo. El ejercicio nos pide crear los siguientes m√©todos: void crear (TLista * lista); // Crear lista vacia void rellenar(TLista * lista); // Incluir elementos en la lista (pedir numeros hasta que se inserte un negativo) y que los elementos se inserten por el principio void destruir(TLista* lista); // Destruir todos los elementos de la lista void mostrar (TLista lista); // Mostrar los elementos de la lista Pasamos a ver cada uno de los m√©todos: Crear: Simplemente hacemos que el puntero apunte a NULL. void crear (TLista * lista){ // Crear lista vacia *lista = NULL; } Rellenar: Mientras los n√∫meros que introduzcamos sean positivos, creamos un auxiliar con el valor del n√∫mero introducido cuyo siguiente sea el resto de la lista y posteriormente hacemos que la lista apunte a dicho auxiliar. void rellenar(TLista * lista){ int insertado; TLista auxiliar; printf(Introduce los n√∫meros de la lista (introducir un n√∫mero negativo para finalizar): \n); fflush(stdout); scanf(%d, &insertado); while (insertado >= 0) { auxiliar = malloc(sizeof(struct TNodo)); auxiliar->valor=insertado; auxiliar->sig=*lista; *lista=auxiliar; scanf(%d, &insertado); } } Destruir: A√±ado dos formas distintas de hacerlo. En ambas se necesita un auxiliar para recorres dicha lista e ir eliminando los nodos, liberando memoria mediante el m√©todo free. void destruir(TLista* lista){// Destruir todos los elementos de la lista TLista auxiliar; while (*lista != NULL) { auxiliar=(*lista)->sig; free(*lista); *lista=auxiliar; } /* TLista ptr = *lista; while(ptr != NULL){ *lista = ptr-> sig; free( ptr); ptr = *lista; } */ } Mostrar:  Simplemente recorremos la lista mostrando los valores de los nodos. void mostrar (TLista lista){// Mostrar los elementos de la lista TLista ptr = lista; printf([); while (ptr != NULL) { printf(%u, ptr->valor); ptr = ptr->sig; if (ptr != NULL) { printf(, ); } } printf(]\n); } Posteriormente en otra entrada completar√© el ejercicio agregando otros m√©todos como: int is_empty(Linked_List l); // Devuelve verdadero si la lista est√° vac√≠a int contains(Linked_List l, unsigned v); // Devuelve verdadero si la lista contiene el elemento v int length(Linked_List l); // Devuelve el n√∫mero de elementos de la lista int insert(Linked_List * ptrL, int pos, unsigned v); // Inserta v en la posici√≥n pos de la lista (*prtL). Si ok, devuelve verdadero; si pos no est√° entre 1 y length +1, entonces devuelve falso int remove(Linked_List * ptrL, int pos); // Borra el elemento pos de la lista, devolviendo verdadero o falso seg√∫n la operaci√≥n se pueda realizar. int getElement(Linked_List l, int pos); // Devuelve el elemento de la posici√≥n pos. Si esa posici√≥n no existe, el comportamiento de la funci√≥n no est√° definido. Linked_List readFromFile(char * filename); // Asumiendo que filename contiene N l√≠neas, donde cada l√≠nea es un entero, lee el fichero y almacena su contenido una lista que es devuelta como resultado. En caso de alguna situaci√≥n de error, la funci√≥n devolver√° NULL. int writeToFile(Linked_list list, char * filename); // Escribe el contenido de la lista list en el fichero denominado filaneme, almacenando cada elemento de la lista una l√≠nea del fichero. La funci√≥n devuelve verdadero o falso seg√∫n se haya realizado con √©xito o no Un saludo ;)"
      },
      {
        "id": 61,
        "autor": "Oscar Blancarte",
        "pagina": "oscarblancarteblog",
        "fecha": "25/06/2018",
        "titulo": "Creando un API REST en Java (parte 1)",
        "link": "https://www.oscarblancarteblog.com/2018/06/25/creando-un-api-rest-en-java-parte-1/",
        "contenido": "Sin lugar a duda, los servicios REST ya se han convertido en la principal tecnolog√≠a para construir servicios, superando con creces a los servicios SOAP o com√∫nmente conocidos como Web Services. A pesar de que REST ya es visiblemente la tendencia en el desarrollo de servicios, sigue existiendo una gran discusi√≥n acerca de si SOAP es mejor que REST o al rev√©s, sin embargo, no quiera tocar este tema ahora, pues no es el tema central de este art√≠culo, para eso he creado el art√≠culo ‚ÄúSOA vs REST‚Äù donde discutimos sobre estas dos tecnolog√≠as y sus ventajas y desventajas. NOTA: Este art√≠culo es parte de un tutorial completo para crear API REST con JAX-RS, si quieres ver el √≠ndice completo entra aqu√≠. Antes de comenzar, te cuento que puedes descargar el c√≥digo completo en https://github.com/oscarjb1/blog-tutorial-jaxrs/tree/master/M%C3%A9todos%20HTTP/api Configurando el proyecto Dicho este, pasemos ahora si a implementar un API REST con Java, para esto, ser√° indispensable crear un proyecto de tipo WEB en tu IDE favorito, en este caso, vamos a crear un ‚ÄúDynamic web project‚Äù en Eclipse, para esto nos dirigimos a file -> new -> Other en el men√∫ superior: Seleccionamos la opci√≥n Dynamic web Project y presionamos Next para iniciar con la configuraci√≥n de la aplicaci√≥n: Una vez aqu√≠, escribimos ‚Äúapi‚Äù como nombre del proyecto y seleccionamos nuestro servidor de aplicaciones de preferencia, en nuestro caso, utilizamos Wildfly 11 pero podr√≠as utilizar cualquier otro que tengas disponible. Finalmente, presionamos ‚ÄúFinish‚Äù para concluir con la creaci√≥n del proyecto. El siguiente paso ser√° convertir nuestro proyecto a un proyecto Maven, con la finalidad de administrar m√°s f√°cilmente nuestras librer√≠as. Para ello, nos posicionaremos sobre el proyecto creado y presionaremos ‚Äúclick derecho‚Äú para abrir las opciones del proyecto, estando all√≠, nos dirigimos a configure -> convert to Maven Project, tras presionar esto, saldr√° una ventana para configurar el proyecto, a lo que simplemente daremos finalizar. Tras realizar los pasos anteriores deber√°s ver el proyecto tal y como se ve en la imagen anterior. Podr√°s observar una peque√±a ‚ÄúM‚Äù en el √≠cono del proyecto, se√±al de que se trata de un proyecto Maven. El siguiente paso es configurar las librer√≠as de JavaEE y Wildfly con la finalidad de que est√©n disponibles en nuestro proyecto, por lo que tendremos que ir al archivo pom.xml y agregar las siguientes dos librer√≠as: <dependency> <groupId>javax</groupId> <artifactId>javaee-api</artifactId> <version>7.0</version> <scope>provided</scope> <type>jar</type> </dependency> <dependency> <groupId>org.wildfly.core</groupId> <artifactId>wildfly-server</artifactId> <version>2.2.0.Final</version> <scope>provided</scope> </dependency> Guardamos los cambios y tendremos que esperar un momento hasta que Eclipse descarga todas las dependencias necesarias, para esto, ver√°s un indicador de progreso en la parte inferior derecha de Eclipse. Una vez que ha finalizado, estamos listos para empezar a desarrollar. Iniciando el desarrollo Lo primero que debemos de hacer para iniciar nuestra API REST es indicarle el Path base desde el cual estar√° respondiendo nuestra API. Este path corresponde a la URL a partir de la cual se expondr√° nuestros servicios. Para lograr esto, ser√° necesario crear una clase que extienda de ‚ÄúApplication‚Äù, esta clase puede llamarse como sea y puede colocarse en cualquier paquete, lo √∫nico importante es que extienda de Application y defina la anotaci√≥n @ApplicationPath. En nuestro caso crearemos la clase RestApplication en el package api. package api; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( / ) public class RestApplication extends Application { } Como podemos ver, hemos definido ‚Äú/‚Äù como URL base, es decir que los servicios responder√°n a partir de la ra√≠z del proyecto, pero tu podr√≠as remplazarla por la URL base que m√°s te guste, como por ejemplo ‚Äú/api‚Äù o ‚Äú/services‚Äù. El siguiente paso ser√° crear nuestro primer servicio, para lo cual deberemos crear una nueva clase, en este caso, crearemos la clase HelloWorldRest en el mismo paquete: package api; import javax.ws.rs.Consumes; import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.Produces; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; @Path( /helloworld ) @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class HelloWorldRest { @GET public Response sayHello() { return Response.ok( Hello World desde el API REST ,MediaType.APPLICATION_JSON).build(); } } Como podr√°s observar, esta es una clase com√∫n y corriente pero que tiene algunas anotaciones, las cuales ser√°n reconocidas por el servidor de aplicaciones para finalmente exponer el servicio, analicemos para que esta cada una de ellas. La anotaci√≥n @Path indica la URL en la cual responder√° este servicio, cabe mencionar que esta anotaci√≥n se puede poner a nivel de clase y m√©todo, en este caso, al estar a nivel de clase, afecta a todos los servicios que definamos, pero eso lo vamos a analizar m√°s adelante. Las siguientes dos anotaciones son para indicar que tipo de mensaje esperamos como entrada (consumes) y que tipo de mensaje vamos a responder (produces). En este caso, estamos indicando que esperamos JSON como entrada y que vamos a responder igualmente con JSON. Finalmente, siguen los m√©todos, una clase puede tener m√°s de un m√©todo, y cada m√©todo se puede exponer como un servicio independiente, sin embargo, en esta primera introducci√≥n empezaremos con uno. La anotaci√≥n @GET le indica al servidor de aplicaciones que el m√©todo responde por el m√©todo GET √∫nicamente. Adicional tenemos anotaciones para los dem√°s m√©todos, como @POST, @PUT, @DELETE, etc. pero estos los estaremos analizando m√°s adelante. Podr√°s observar que el m√©todo responde con un tipo llamado Response, esta es una clase de utilidad que nos proporciona el API de JAX-RS para convertir f√°cilmente un objeto en un JSON en nuestro caso. Esta clase nos proporciona el m√©todo ok, el cual nos crea una respuesta con status 200, es decir, respuesta exitosa, la cual recibe el mensaje que queremos responder y el tipo de datos del mensaje, en nuestro caso JSON. Probando nuestro Hello World En este punto hemos terminado nuestro primer servicio, por lo que solo resta desplegarlo y probarlo. Para desplegarlo, basta con presionar el click derecho sobre el proyecto y presionar Run As -> Run on Server, presionar siguiente y finalizar. Si la aplicaci√≥n desplego correctamente, podremos probar el servicio en la URL http://localhost:8080/api-0.0.1-SNAPSHOT/helloworld, esta URL la podr√°s ejecutar directamente sobre el navegador: En este punto te estar√°s preguntando como es que se gener√≥ esta URL, por lo que explico a continuaci√≥n: La URL se forma con la siguiente formula: <server_path>:<port>/<app_context>/<app_path>/<service_path> La secci√≥n <server_path> y <port> corresponde al host del servidor y el puerto en el cual responde, esto corresponde a Wildfly. La secci√≥n <app_context> corresponde a la URL base que nos asigna el servidor de aplicaciones cuando desplegamos. La secci√≥n <app_path> fue la que definimos en la anotaci√≥n @ApplicationPath. En nuestro caso, al definirla como ‚Äú/‚Äù quiere decir que responder√° a partir de la ra√≠z del proyecto. Finalmente, <service_path> corresponde a la URL definida en la anotaci√≥n @Path, la cual se defini√≥ como ‚Äúhelloworld‚Äù. Te invito a que veas mi curso Mastering API REST con Spring Boot Conclusiones Hasta este punto hemos aprendido a crear un proyecto web y configurarlo para que responda a nuestras solicitudes como un API REST, por lo que en la siguiente secci√≥n de esta gu√≠a aprenderemos a utilizar los dem√°s m√©todos (POST, DELETE, PUT) y aprenderemos a configurar nuestras URL para responder a URL m√°s complejas, por lo que te invito a que te suscribas a mi blog para hacerte llegar las actualizaciones."
    },

    {
        "id": 62,
        "autor": "Rosa",
        "pagina": "developrogramming",
        "fecha": "12/05/2020",
        "titulo": "Crear API REST JAVA",
        "link": "https://developrogramming.com/crear-api-rest-java/",
        "contenido": "A continuaci√≥n, explicar√© c√≥mo crear servicios web desarrollando una API REST JAVA con la librer√≠a JAX-RS y Jersey. ¬øQu√© es REST? Sus siglas significan Transferencia de Estado Representacional. No es un protocolo de comunicaci√≥n, sino una definici√≥n de arquitectura donde la comunicaci√≥n se realiza v√≠a HTTP utilizando los m√©todos GET, POST, PUT, DELETE y PATCH. La respuesta de esos m√©todos admiten formatos como JSON (Notaci√≥n de Objeto de JavaScript), XML, HTML o TEXTO PLANO, entre otros. As√≠, cuando se habla de aplicaci√≥n RESTful quiere decir que implementa este tipo de arquitectura. ¬øQu√© es JAX-RS? Java API for RESTful Web Services. Es una especificaci√≥n para crear Servicios Web REST que se basa en anotaciones para simplificar el desarrollo y despliegue de los clientes. ¬øQu√© es Jersey? Es un cliente RESTful e implementa JAX-RS. Facilita a los desarrolladores crear servicios web RESTful con Java. api rest Operaciones REST Las principales operaciones de un sistema REST y la especificaci√≥n HTTP son las siguientes: GET (leer) POST (crear) PUT (editar) DELETE (eliminar) PATCH (actualizar) Crear proyecto Lo primero que hay que hacer es crear un proyecto web din√°mico Java y configurarlo para poder trabajar con Maven. Como entorno de desarrollo he utilizado Eclipse. Modificar fichero pom.xml A continuaci√≥n, introducimos las dependencias en el fichero de configuraci√≥n de Maven. pom.xml <project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>API_REST_WS-RS</groupId> <artifactId>API_REST_WS-RS</artifactId> <version>0.0.1-SNAPSHOT</version> <packaging>war</packaging> <build> <sourceDirectory>src</sourceDirectory> <plugins> <plugin> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.0</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <plugin> <artifactId>maven-war-plugin</artifactId> <version>3.2.1</version> <configuration> <warSourceDirectory>WebContent</warSourceDirectory> </configuration> </plugin> </plugins> </build> <dependencies> <dependency> <groupId>javax.ws.rs</groupId> <artifactId>javax.ws.rs-api</artifactId> <version>2.1.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-servlet</artifactId> <version>2.25.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.25.1</version> </dependency> </dependencies> </project> Crear clases A continuaci√≥n, vamos a crear las clases User.java, ServicioUsers.java y Configuration.java. User.java package es.rosamarfil.modelo; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } ServicioUsers.java package es.rosamarfil.services; import java.util.ArrayList; import java.util.List; import javax.ws.rs.BeanParam; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.GET; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.client.Entity; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; import javax.ws.rs.core.Response.Status; import es.rosamarfil.modelo.User; @Path( /users ) public class ServicioUsers { private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; /** * URL: http://localhost:8080/API_REST_WS-RS/api/users * @return Response list Users */ @GET @Produces(MediaType.APPLICATION_JSON) public Response getUsers() { return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/Rosa * * @param name String * @return Response */ @GET @Path( /{name} ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response getUserById(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/createUser Parameters in * Postman: { name : Rosa3333 , username : Marfi3333l } * * @param User * @return Response list NOTA: Si no existe el constructor vac√≠o de User, da un *         error y el userRequest viene null. */ @POST @Path( /createUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response createUser(User userRequest) { this.listaUsuarios.add(userRequest); //return Response.status(Status.CREATED).build(); return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/updateUser Parameters in * Postman: { name : Rosa , username : Marfil3333 } * * @param User * @return user modified NOTA: Si no existe el constructor vac√≠o de User, da un *         error y el userRequest viene null. */ @PUT @Path( /updateUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateUser(User userUpdate) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(userUpdate.getName())) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { found.setUsername(userUpdate.getUsername()); return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa * * @param User * @return Response */ @DELETE @Path( /deleteUser/{name} ) @Produces(MediaType.APPLICATION_JSON) public Response deleteUser(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); listaUsuarios.remove(found); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(listaUsuarios).build(); } } } Configuration.java package es.rosamarfil.services; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( api ) public class Configuration extends Application { } Probar nuestra API REST Para poder acceder a los servicios creados, lo primero que hay que hacer es publicarlos a trav√©s de un servidor. Para ello, desde Eclipse arrancaremos nuestro proyecto. Previamente necesitaremos tener un servidor configurado, como por ejemplo Apache. Una vez hecho esto, nos situaremos sobre nuestro proyecto, desplegaremos el men√∫ contexual y seleccionaremos Run As -> Run on Server. Crear API REST JAVA - JAX-RS y Jersey Una vez arrancado el servidor con nuestra aplicaci√≥n, podemos probar los servicios o bien desde la barra de direcciones de un navegador o desde alg√∫n programa cliente como Postman. La direcci√≥n base de nuestra aplicaci√≥n es: http://localhost:8080/API_REST_WS-RS Vamos a ver los par√°metros a introducir: GET (leer) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users GET (leer) a partir de un par√°metro. En este caso buscaremos un usuario por nombre. En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/Rosa POST (crear) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/createUser y en la secci√≥n Body, introduce un usuario en formato json, como se muestra en la imagen: Crear API REST JAVA - JAX-RS y Jersey - Postman PUT (editar) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/updateUser y en la secci√≥n Body de Postman introduce: {¬´name¬ª:¬ªRosa¬ª,¬ªusername¬ª:¬ªMarfil3333‚Ä≥} DELETE (eliminar) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa Y hasta aqu√≠ la creaci√≥n de tu primera API REST. Como ves, con unos simples pasos es posible crear servicios web basados en REST. Espero que te haya sido de utilidad. Comparte si te ha gustado!!"
    },

    {
        "id": 63,
        "autor": "Emmanuel Guzm√°n",
        "pagina": "oracle-max",
        "fecha": "21/03/2020",
        "titulo": "Creando un API REST con Java y Netbeans, que devuelva un json en su request",
        "link": "https://oracle-max.com/creando-un-api-rest-con-java-y-netbeans-que-devuelva-un-json-en-su-request/",
        "contenido": "En este laboratorio aprender√°s paso a paso, como crear un API Rest con Java en Netbeans, este a su vez devolver√° un json como respuesta a su request. Primero debemos crear un proyecto Maven Web Application: Luego en el source package crearemos un paquete al cual le llamar√© API, daremos click derecho en el paquete y buscaremos la siguiente opci√≥n: Seleccionamos Simple Root Resource En la siguiente pantalla debemos llenar lo siguientes campos seg√∫n corresponda: Path: nombre por el cual realizaremos la consulta a nuestro API. Class Name: nombre de la clase donde programaremos nuestra funci√≥n GET. MIME Type: Tipo de contenido que dar√° como respuesta nuestro API. Lo dem√°s quedar√° igual y presionamos Finish. Se nos crear√°n dos clases como las siguientes: Tenemos un m√©todo llamado getJson dentro de la clase ApipruebaResource, a este le cambiaremos el nombre a consultaPersona y le env√≠aremos 4 par√°metros usando la anotaci√≥n @QueryParam: Ahora crearemos un nuevo paquete llamado com.api.bean y dentro crearemos dos clases, una llamada Persona y otra llamada Telefono, las cuales tendr√°n lo siguiente: Clase Persona Clase Telefono Por √∫ltimo crearemos una clase m√°s llamada Json la cu√°l solamente le enviaremos el objeto persona. Clase Json Ahora nos devolvemos a la clase ApipruebaResource y crearemos nuestro objeto persona el cual convertiremos a json: Antes de continuar, debemos colocar la librer√≠a de gson en nuestro archivo pom.xml para poder usar la conversi√≥n a json: Luego regresamos a la clase ApipruebaResource y colocaremos el siguiente c√≥digo: De esta forma nuestro API Rest quedar√≠a terminada, por lo que debemos compilar y probar nuestra API Rest. Para probar nuestro API Rest lo podemos hacer de 2 maneras: Damos click derecho en la carpeta RESTful Web Services y seleccionamos Test RESTful Web Services: Se nos abrir√° la siguiente pantalla donde lo probaremos: 2. La segunda forma de probarlo es por medio de un url en un navegador, para ello deberemos enviar el siguiente url, el puerto puede variar seg√∫n la configuraci√≥n de su servidor web: http://localhost:8080/APIrestJava/webresources/apiprueba?cedula=12345&nombre=Emmanuel+Guzman&telefono=88888888&operador=Movistar De esta manera hemos logrado crear un API Restful que nos devuelva un json como respuesta, si lo vemos formateado en json queda as√≠: { persona : { cedula :  12345 , nombre :  Emmanuel Guzman , telefono : { telefono :  88888888 , operador :  Movistar } } } Luego de esto ya queda a nuestra creatividad la cantidad de contenedores que queramos crear en el json, sus respectivos atributos y la l√≥gica detr√°s a implementar para responder el request."
    },

    {
        "id": 64,
        "autor": "nigmacode",
        "pagina": "nigmacode",
        "fecha": "01/01/2020",
        "titulo": "Crear API REST con Spring",
        "link": "https://www.nigmacode.com/java/crear-api-rest-con-spring/",
        "contenido": "En este art√≠culo, crearemos una API REST con el framework Spring, el framework m√°s utilizado para la plataforma Java. Para ello, utilizaremos Spring boot que nos facilitar√° su configuraci√≥n (uso de dependencias, conexi√≥n con la base de datos, despliegue de servidor, etc). Debemos tener instalado Java, Maven en nuestro PC y como entorno de desarrollo utilizaremos Eclipse. Creando proyecto con SpringBoot Como hemos comentado, utilizaremos Springboot, que es una de las tecnolog√≠as dentro del mundo de spring, que nos facilita el desarrollo de aplicaciones con este framework, ya que nos facilita el trabajo con de las dependencias (Maven/Grandle), del despliegue del servidor, ya que nos provee de uno (a parte de mucha otra configuraci√≥n). Para comenzar, nos dirigimos a la p√°gina https://start.spring.io/ d√≥nde descargaremos nuestro proyecto: Project: En la primera opci√≥n, elegimos si queremos trabajar con maven o gradle, en este ejemplo, utilizaremos Maven. Language: En la segunda opci√≥n, elegimos con que lenguaje trabajar, Java. Springboot: En esta opci√≥n, elegimos la versi√≥n que queremos utilizar, en este caso 2.1.5 Project Metadata: El nombre de nuestro proyecto. Dependencies: En el buscador de dependecias, buscaremos y a√±adiremos WEB para crear nuestra API REST. Daremos click sobre el bot√≥n Generate the project, comenzar√° la descarga y una vez descargado lo descomprimiremos. Incluyendo proyecto Spring boot en Eclipse Ahora importaremos nuestro proyecto spring boot en Eclipse, para ello, iremos a la barra de eclipse e iremos a file/import/Maven/Existing Maven Porjects y daremos a browse, d√≥nde buscaremos el proyecto que acabamos de descargar, nos fijamos en que este el check que nos aparecer√° del pom.xml marcado y daremos a next. Nuestro proyecto ya aparecer√° en eclipse y comenzar√° a descargar las dependencias de su archivo pom.xml. Configurando spring boot Dependencias Para aprender a a√±adir nuevas dependencias en nuestro proyecto, vamos a dirigirnos a pom.xml, que se encuentra en la raiz de nuestro proyecto, ah√≠ nos aparecer√°n las dependencias que se han agregado al a√±adirle en spring init la dependencia WEB. En este archivo, en el apartado de dependencias, vamos a a√±adir debajo de las que ya tenemos, tres m√°s, una ser√° para trabajar con JPA, otra para conectarnos a nuestra base mysql y otra para que refresque el servidor cada vez que haya alg√∫n cambio: <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.1.5.RELEASE</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.jlguisado.webjob</groupId> <artifactId>api</artifactId> <version>0.0.1-SNAPSHOT</version> <name>api</name> <description>Demo project for Spring Boot</description> <properties> <java.version>1.8</java.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> </project> Una vez hecho esto, actualizaremos nuestro proyecto con estas nuevas dependencias, haciendo click derecho sobre su carpeta, maven/update project. Base de datos En este ejemplo, estoy utilizando xampp para trabajar con la base de datos que he llamado api y una tabla llamada user que tiene la siguiente estructura: Una vez creada nuestra base de datos y su tabla user, vamos a volver a nuestro proyecto spring y nos dirigimos al archivo application.properties, que se encuentra en src/main/resources e indicaremos la ruta de la base de datos, su usuario y contrase√±a: # # JDBC Properties # spring.datasource.url = jdbc:mysql://localhost:3306/api?useUnicode=true&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=UTC #direccion de la base de datos, puede variar el puerto y nombre de la bd spring.datasource.username=root #usuario que utilizas en la bd spring.datasource.password=root #contrase√±a que utilizas en la bd Una vez hecho esto, ya estar√≠amos listo para crear nuestra API REST. Creando API REST con Spring boot Para comenzar, os mostrar√© el carpetado que va a tener nuestro API REST, tendr√©is que crear estos paquetes con estas clases: ApiApplication.java Es la clase que arranca nuestra aplicaci√≥n springboot, dando click derecho sobre la clase y run as application: package com.nigmacode.apirest; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } Paquete entity En este paquete tenemos nuestro clase User.java y utilizaremos las @anotaciones JPA para relacionarla con nuestra tabla user, quedar√≠a de la siguiente forma: package com.nigmacode.apirest.entity; import java.util.Date; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.UpdateTimestamp; @Entity @Table(name= user ) public class User { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name= id ) private int id; @Column(name= email ) private String email; @Column(name= password ) private String password; @Column(name= created_at ) @CreationTimestamp private Date createdAt; @Column(name= updated_at ) @UpdateTimestamp private Date updatedAt; public User() {} public User(int id, String email, String password) { this.id = id; this.email = email; this.password = password; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Date getCreatedAt() { return createdAt; } public void setCreatedAt(Date createdAt) { this.createdAt = createdAt; } public Date getUpdatedAt() { return updatedAt; } public void setUpdatedAt(Date updatedAt) { this.updatedAt = updatedAt; } @Override public String toString() { return  User [id=  + id +  , email=  + email +  , password=  + password +  , createdAt=  + createdAt +  , updatedAt=  + updatedAt +  ] ; } } Paquete DAO En UserDAO, crearemos los m√©todos que utilizar√° la clase UserDAOimpl, para conectarse con nuestra base de datos. Interfaz userDAO: package com.nigmacode.apirest.dao; import java.util.List; import com.nigmacode.apirest.entity.User; public interface UserDAO { public List<User> findAll(); public User findById(int id); public void save(User user); public void deleteById(int id); } En nuestra clase UserDAOImpl, implementamos la interfaz, le a√±adiremos la anotaci√≥n @Repository que indica que es un DAO,y mediante la anotaci√≥n @Autowired inyectaremos EntityManager, que lo utilizaremos para crear una sessi√≥n y poder enviar las peticiones a la base de datos en cada m√©todo: package com.nigmacode.apirest.dao; import java.util.List; import javax.persistence.EntityManager; import org.hibernate.Session; import org.hibernate.query.Query; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Repository; import com.nigmacode.apirest.entity.User; @Repository public class UserDAOImpl implements UserDAO{ @Autowired private EntityManager entityManager; @Override public List<User> findAll() { Session currentSession = entityManager.unwrap(Session.class); Query<User> theQuery = currentSession.createQuery( from User , User.class); List<User> users = theQuery.getResultList(); return users; } @Override public User findById(int id) { Session currentSession = entityManager.unwrap(Session.class); User user = currentSession.get(User.class, id); return user; } @Override public void save(User user) { Session currentSession = entityManager.unwrap(Session.class); currentSession.saveOrUpdate(user); } @Override public void deleteById(int id) { Session currentSession = entityManager.unwrap(Session.class); Query<User> theQuery = currentSession.createQuery( delete from User where id=:idUser ); theQuery.setParameter( idUser , id); theQuery.executeUpdate(); } } Paquete Service Como en el paquete anterior tendremos una clase y una interface. El servicio ser√° el que har√° de interemediario entre el DAO y el controlador(La clase que gestionar√° las peticiones de la API que veremos m√°s adelante). La interfaz de service tendr√≠a esta estructura UserService.java: package com.nigmacode.apirest.service; import java.util.List; import com.nigmacode.apirest.entity.User; public interface UserService { public List<User> findAll(); public User findById(int id); public void save(User user); public void deleteById(int id); } Y la clase UserServiceImpl.java, ser√° implementada por la interfaz anterior. Le a√±adiremos la anotaci√≥n @Service, para indicar que es un servicio y tambi√©n de @Autowired para inyectar nuestro DAO y hacer uso de √©l: package com.nigmacode.apirest.service; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.nigmacode.apirest.dao.UserDAO; import com.nigmacode.apirest.entity.User; @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Override public List<User> findAll() { List<User> listUsers= userDAO.findAll(); return listUsers; } @Override public User findById(int id) { User user = userDAO.findById(id); return user; } @Override public void save(User user) { userDAO.save(user); } @Override public void deleteById(int id) { userDAO.deleteById(id); } } Paquete controller Por √∫ltimo, en el paquete controller tendremos la clase UserRestController.java que ser√° la encargada de gestionar las peticiones que se hagan a nuestra API, esta clase en m√°s extensa y ser√° explicada mediante comentarios en el siguiente c√≥digo: package com.nigmacode.apirest.controller; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.PutMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import com.nigmacode.apirest.entity.User; import com.nigmacode.apirest.service.UserService; //Indiciamos que es un controlador rest @RestController @RequestMapping( /api ) //esta sera la raiz de la url, es decir http://127.0.0.1:8080/api/ public class UserRestController { //Inyectamos el servicio para poder hacer uso de el @Autowired private UserService userService; /*Este m√©todo se har√° cuando por una petici√≥n GET (como indica la anotaci√≥n) se llame a la url http://127.0.0.1:8080/api/users*/ @GetMapping( /users ) public List<User> findAll(){ //retornar√° todos los usuarios return userService.findAll(); } /*Este m√©todo se har√° cuando por una petici√≥n GET (como indica la anotaci√≥n) se llame a la url + el id de un usuario http://127.0.0.1:8080/api/users/1*/ @GetMapping( /users/{userId} ) public User getUser(@PathVariable int userId){ User user = userService.findById(userId); if(user == null) { throw new RuntimeException( User id not found - +userId); } //retornar√° al usuario con id pasado en la url return user; } /*Este m√©todo se har√° cuando por una petici√≥n POST (como indica la anotaci√≥n) se llame a la url http://127.0.0.1:8080/api/users/  */ @PostMapping( /users ) public User addUser(@RequestBody User user) { user.setId(0); //Este metodo guardar√° al usuario enviado userService.save(user); return user; } /*Este m√©todo se har√° cuando por una petici√≥n PUT (como indica la anotaci√≥n) se llame a la url http://127.0.0.1:8080/api/users/  */ @PutMapping( /users ) public User updateUser(@RequestBody User user) { userService.save(user); //este metodo actualizar√° al usuario enviado return user; } /*Este m√©todo se har√° cuando por una petici√≥n DELETE (como indica la anotaci√≥n) se llame a la url + id del usuario http://127.0.0.1:8080/api/users/1  */ @DeleteMapping( users/{userId} ) public String deteteUser(@PathVariable int userId) { User user = userService.findById(userId); if(user == null) { throw new RuntimeException( User id not found - +userId); } userService.deleteById(userId); //Esto m√©todo, recibira el id de un usuario por URL y se borrar√° de la bd. return  Deleted user id -  +userId; } } Solucionar problema CORS en nuestra API Para que nuestra aplicaci√≥n no nos de problemas a la hora de utilizarla desde otra direcci√≥n, debemos configurarla para que no de error de CORS, para ello debemos seguir las intrucciones de nuestro art√≠culo üëâhttps://www.nigmacode.com/java/Solucionar-CORS-en-Spring De est√° forma, ya tendr√≠amos nuestra API REST con Spring boot lista, ya solo quedar√≠a levantar el servidor, como hemos dicho anteriormente, dando click derecho sobre ApiApplication.java y run as application"
    },

    {
        "id": 65,
        "autor": "Rosa",
        "pagina": "rosamarfil",
        "fecha": "05/05/2020",
        "titulo": "Crear una API REST Java con JAX-RS y Jersey",
        "link": "https://rosamarfil.es/tutoriales/programacion/crear-api-rest-java-jax-rs-jersey/",
        "contenido": "A continuaci√≥n, explicar√© c√≥mo crear una API REST Java con JAX-RS y Jersey. Usaremos los m√©todos comunes para publicar los servicios en nuestra m√°quina local. ¬øQu√© es JAX-RS? Java API for RESTful Web Services. Es una especificaci√≥n para crear Servicios Web REST que se basa en anotaciones para simplificar el desarrollo y despliegue de los clientes. ¬øQu√© es Jersey? Es un cliente RESTful e implementa JAX-RS. Facilita a los desarrolladores crear servicios web RESTful con Java. Las operaciones de un sistema REST y la especificaci√≥n HTTP son cuatro: GET (leer) POST (crear) PUT (editar) DELETE (eliminar) Lo primero que hay que hacer es crear un proyecto web din√°mico Java (mejor la √∫ltima versi√≥n Java JDK 1.8) y configurarlo para poder trabajar con Maven. Yo he utilizado Eclipse como entorno de desarrollo. Si tienes dudas en c√≥mo hacerlo, puedes consultar el tutorial Crear un proyecto web din√°mico. Modificar fichero pom.xml Introduciremos las dependencias en el fichero de configuraci√≥n de Maven. pom.xml <project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>API_REST_WS-RS</groupId> <artifactId>API_REST_WS-RS</artifactId> <version>0.0.1-SNAPSHOT</version> <packaging>war</packaging> <build> <sourceDirectory>src</sourceDirectory> <plugins> <plugin> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.0</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <plugin> <artifactId>maven-war-plugin</artifactId> <version>3.2.1</version> <configuration> <warSourceDirectory>WebContent</warSourceDirectory> </configuration> </plugin> </plugins> </build> <dependencies> <dependency> <groupId>javax.ws.rs</groupId> <artifactId>javax.ws.rs-api</artifactId> <version>2.1.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-<a href= https://rosamarfil.es/tutoriales/diccionario/servlet/  data-cmtooltip= Es una clase java que(...)  class= glossaryLink  >servlet</a></artifactId> <version>2.25.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.25.1</version> </dependency> </dependencies> </project> Crear el resto de clases User.java package es.rosamarfil.modelo; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } ServicioUsers.java package es.rosamarfil.services; import java.util.ArrayList; import java.util.List; import javax.ws.rs.BeanParam; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.GET; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.client.Entity; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; import javax.ws.rs.core.Response.Status; import es.rosamarfil.modelo.User; @Path( /users ) public class ServicioUsers { private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; /** * URL: http://localhost:8080/API_REST_WS-RS/api/users * @return Response list Users */ @GET @Produces(MediaType.APPLICATION_JSON) public Response getUsers() { return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/Rosa * * @param name String * @return Response */ @GET @Path( /{name} ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response getUserById(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/createUser Parameters in * Postman: { name : Rosa3333 , username : Marfi3333l } * * @param User * @return Response list NOTA: Si no existe el constructor vac√≠o de User, da un *         error y el userRequest viene null. */ @POST @Path( /createUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response createUser(User userRequest) { this.listaUsuarios.add(userRequest); //return Response.status(Status.CREATED).build(); return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/updateUser Parameters in * Postman: { name : Rosa , username : Marfil3333 } * * @param User * @return user modified NOTA: Si no existe el constructor vac√≠o de User, da un *         error y el userRequest viene null. */ @PUT @Path( /updateUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateUser(User userUpdate) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(userUpdate.getName())) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { found.setUsername(userUpdate.getUsername()); return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa * * @param User * @return Response */ @DELETE @Path( /deleteUser/{name} ) @Produces(MediaType.APPLICATION_JSON) public Response deleteUser(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); listaUsuarios.remove(found); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(listaUsuarios).build(); } } } Configuration.java package es.rosamarfil.services; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( api ) public class Configuration extends Application { } Probar nuestros Servicios Lo primero es levantar la aplicaci√≥n. Para ello, selecciona el proyecto y ejec√∫talo sobre un servidor Apache previamente configurado. Si no sabes como configurarlo, puedes ver el tutorial Configurar Proyecto web y ver la secci√≥n A√±adir Servidor Apache Tomcat a Eclipse. Crear una API REST Java con JAX-RS y Jersey Una vez arrancado el servidor con nuestra aplicaci√≥n, podemos probar los servicios o bien desde la barra de direcciones de un navegador o desde alg√∫n programa cliente como Postman. La direcci√≥n base de nuestra aplicaci√≥n es: http://localhost:8080/API_REST_WS-RS Vamos a ver los par√°metros a introducir: GET (leer) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users GET (leer) a partir de un par√°metro. En este caso buscaremos un usuario por nombre. En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/Rosa POST (crear) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/createUser y en la secci√≥n Body, introduce un usuario en formato json, como se muestra en la imagen: Crear una API REST Java con JAX-RS y Jersey PUT (editar) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/updateUser y en la secci√≥n Body de Postman introduce: {¬´name¬ª:¬ªRosa¬ª,¬ªusername¬ª:¬ªMarfil3333‚Ä≥} DELETE (eliminar) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa Y esto es todo!! Esta es una forma sencilla para empezar a crear servicios REST JAVA y crear una API REST Java con JAX-RS y Jersey."
    },

    {
        "id": 66,
        "autor": "AWS",
        "pagina": "amazon",
        "fecha": "01/01/2021",
        "titulo": "Tutorial: Crear una API de REST importando un ejemplo",
        "link": "https://docs.aws.amazon.com/es_es/apigateway/latest/developerguide/api-gateway-create-api-from-example.html",
        "contenido": "Puede utilizar la consola de Amazon API Gateway para crear y probar una API REST sencilla con integraci√≥n HTTP para un sitio web PetStore. La definici√≥n de la API est√° preconfigurada como un archivo de OpenAPI 2.0. Despu√©s de cargar la definici√≥n de API en API Gateway, puede utilizar la consola de API Gateway para examinar la estructura b√°sica de API o simplemente implementar y probar la API. La API de ejemplo de PetStore admite los siguientes m√©todos para que un cliente obtenga acceso al sitio web de backend HTTP de http://petstore-demo-endpoint.execute-api.com/petstore/pets. GET /: para leer el acceso del recurso ra√≠z de la API que no se integra con ning√∫n punto de enlace de backend. API Gateway responde con informaci√≥n general del sitio web PetStore. Este es un ejemplo del tipo de integraci√≥n MOCK. GET /pets: para obtener acceso de lectura al recurso /pets de la API que se integra con el recurso /pets de backend asignado. El backend devuelve una p√°gina de mascotas disponibles en PetStore. Este es un ejemplo del tipo de integraci√≥n HTTP. La URL del punto de enlace de integraci√≥n es http://petstore-demo-endpoint.execute-api.com/petstore/pets. POST /pets: para obtener acceso de escritura al recurso /pets de la API que se integra con el recurso /petstore/pets de backend. Tras recibir una solicitud correcta, el backend agrega la mascota especificada a PetStore y devuelve el resultado al autor de la llamada. La integraci√≥n tambi√©n es HTTP. GET /pets/{petId}: para obtener acceso de lectura a una mascota identificada por un valor petId tal como se especifica en una ruta variable de la URL de solicitud de entrada. Este m√©todo tambi√©n tiene el tipo de integraci√≥n HTTP. El backend devuelve la mascota especificada que se encuentra en PetStore. La URL del punto de enlace HTTP del backend es http://petstore-demo-endpoint.execute-api.com/petstore/pets/n, donde n es un entero como identificador de la mascota consultada. La API admite el acceso a CORS a trav√©s de los m√©todos OPTIONS del tipo de integraci√≥n MOCK. API Gateway devuelve los encabezados solicitados que admiten el acceso a CORS. El siguiente procedimiento le guiar√° por los pasos para crear y probar una API a partir de un ejemplo mediante la consola de API Gateway. Para importar, desarrollar y probar la API de ejemplo Si a√∫n no lo ha hecho, realice los pasos de Requisitos previos para comenzar con API Gateway. Inicie sesi√≥n en la consola de API Gateway en https://console.aws.amazon.com/apigateway. Si es la primera vez que utiliza API Gateway, ver√° una p√°gina en la que aparecen las caracter√≠sticas del servicio. En REST API, elija Build (Compilaci√≥n). Cuando aparezca el men√∫ emergente Create Example API (Crear API de ejemplo), elija OK (Aceptar). Si esta no es la primera vez que utiliza API Gateway, elija Create API (Crear API). En REST API, elija Build (Compilaci√≥n). En Create new API (Crear nueva API), elija Example API (API de ejemplo) y, a continuaci√≥n, elija Import (Importar) para crear la API de ejemplo. Para la primera API, la consola de API Gateway comienza con esta opci√≥n de forma predeterminada. Puede desplazarse por la definici√≥n de OpenAPI para obtener informaci√≥n detallada sobre esta API de ejemplo antes de elegir Import (Importar). La API reci√©n creada se muestra de la siguiente forma: El panel Resources (Recursos) muestra la estructura de la API creada como un √°rbol de nodos. Los m√©todos de API definidos en cada recurso son los extremos del √°rbol. Cuando se selecciona un recurso, todos sus m√©todos se muestran en el panel Methods (M√©todos) situado a la derecha. Debajo de cada m√©todo hay un breve resumen del m√©todo, incluidos sus requisitos de URL de punto de enlace, tipo de autorizaci√≥n y clave de API. Para ver los detalles de un m√©todo, para modificar su configuraci√≥n o para probar la invocaci√≥n del m√©todo, elija el nombre del m√©todo en la lista de m√©todos o en el √°rbol de recursos. A continuaci√≥n, elegimos el POST /pets m√©todo como ejemplo: El panel resultante Method Execution (Ejecuci√≥n del m√©todo) presenta una vista l√≥gica de la estructura del m√©todo (POST /pets) elegida y los comportamientos: Method Request (Solicitud de m√©todo) y Method Response (Respuesta de m√©todo) son la interfaz de la API con el frontend de la API (un cliente), mientras que Integration Request (Solicitud de integraci√≥n) e Integration Response (Respuesta de integraci√≥n) son la interfaz de la API con el backend (http://petstore-demo-endpoint.execute-api.com/petstore/pets). Un cliente utiliza la API para obtener acceso a una caracter√≠stica del backend a trav√©s de Method Request (Solicitud de m√©todo). API Gateway traduce la solicitud del cliente, si fuera necesario, a un formato aceptable por el backend en Integration Request (Solicitud de integraci√≥n) antes de reenviar la solicitud entrante al backend. La solicitud transformada se conoce como la solicitud de integraci√≥n. Del mismo modo, el backend devuelve la respuesta a API Gateway en Integration Response (Respuesta de integraci√≥n). A continuaci√≥n, API Gateway la dirige a Method Response (Respuesta de m√©todo) antes de enviarla al cliente. De nuevo, si fuera necesario, API Gateway puede asignar los datos de la respuesta del backend a un formulario previsto por el cliente. En el caso del m√©todo POST de recurso de API, la carga de la solicitud del m√©todo puede transmitirse a trav√©s de la solicitud de integraci√≥n sin modificaci√≥n si la carga de la solicitud de m√©todo est√° en el mismo formato que la carga de la solicitud de integraci√≥n. La solicitud del m√©todo GET / usa el tipo de integraci√≥n MOCK y no est√° vinculada a ning√∫n punto de enlace de backend real. La Integration Response (Respuesta de integraci√≥n) correspondiente est√° configurada para devolver una p√°gina HTML est√°tica. Cuando se llama al m√©todo, API Gateway simplemente acepta la solicitud e inmediatamente devuelve la respuesta a la integraci√≥n configurada al cliente a trav√©s de Method Response (M√©todo de respuesta). Puede utilizar la integraci√≥n simulada para probar una API sin requerir un punto de enlace del backend. Tambi√©n puede utilizarla para servir una respuesta local generada partir de una plantilla de asignaci√≥n de cuerpo de respuesta. Como desarrollador de la API, puede controlar los comportamientos de las interacciones del frontend de la API mediante la configuraci√≥n de la solicitud de m√©todo y una respuesta de m√©todo. Puede controlar los comportamientos de las interacciones del backend de la API mediante la configuraci√≥n de la solicitud de integraci√≥n y la respuesta de integraci√≥n. Estos comportamientos implican asignaciones de datos entre un m√©todo y su integraci√≥n correspondiente. Explicaremos c√≥mo configurar un m√©todo en Tutorial: Desarrollo de una API de REST con integraci√≥n HTTP no de proxy. Por el momento, nos centraremos en probar la API para proporcionar una experiencia de usuario completa. Elija Test (Probar) en Client (Cliente) (tal y como se muestra en la imagen anterior) para comenzar la prueba. Por ejemplo, para probar el m√©todo POST /pets, escriba la siguiente carga { type :  dog , price : 249.99} en Request Body (Cuerpo de la solicitud) antes de elegir el bot√≥n Test (Probar). La entrada especifica los atributos de la mascota que deseamos a√±adir a la lista de mascotas en el sitio web PetStore. El resultado es el siguiente: La entrada Logs (Registros) de la salida muestra los cambios de estado de la solicitud del m√©todo a la solicitud de integraci√≥n y de la respuesta de integraci√≥n a la respuesta del m√©todo. Esto puede resultar √∫til para la resoluci√≥n de errores de asignaci√≥n que impidan que la solicitud se realice correctamente. En este ejemplo, la asignaci√≥n no se aplica: la carga de la solicitud de m√©todo se transfiere a trav√©s de la solicitud integraci√≥n al backend y, de forma parecida, la respuesta del backend se transfiere a trav√©s de la respuesta de integraci√≥n al m√©todo de respuesta. Para probar la API con un cliente distinto de la caracter√≠stica test-invoke-request de API Gateway, primero debe implementar la API en una etapa. Para implementar la API de ejemplo, seleccione la API PetStore y, a continuaci√≥n, elija Deploy API (Implementar API) en el men√∫ desplegable Actions (Acciones). En Deploy API (Implementar API), para Deployment stage (Etapa de implementaci√≥n), elija [New Stage] (Nueva etapa) porque esta es la primera implementaci√≥n de la API. Escriba un nombre (por ejemplo, test) en Stage name (Nombre de etapa) y, si lo desea, escriba las descripciones en Stage description (Descripci√≥n de etapa) y Deployment description (Descripci√≥n de implementaci√≥n). Elija Deploy (Implementar). En el panel Stage Editor (Editor de etapas) resultante, Invoke URL (URL de invocaci√≥n) muestra la direcci√≥n URL para invocar la solicitud del m√©todo GET / de la API. En Stage Editor (Editor de etapas), siga el enlace Invoke URL (URL de invocaci√≥n) para enviar la solicitud del m√©todo GET / en un navegador. Una respuesta correcta devuelve el resultado, generado a partir de la plantilla de asignaci√≥n de la respuesta de integraci√≥n. En el panel de navegaci√≥n Stages (Etapas), expanda la etapa test (prueba), seleccione GET en /pets/{petId} y, a continuaci√≥n, copie el valor Invoke URL (URL de invocaci√≥n) de https://api-id.execute-api.region.amazonaws.com/test/pets/{petId}. {petId} hace referencia a una variable de ruta. Pegue el valor de Invoke URL (URL de invocaci√≥n) (obtenido en el paso anterior) en la barra de direcciones de un navegador, sustituyendo {petId} por, por ejemplo, 1 y, a continuaci√≥n, pulse Intro para enviar la solicitud. Deber√≠a devolverse una respuesta 200 OK con la siguiente carga JSON: { id : 1, type :  dog , price : 249.99 } La invocaci√≥n del m√©todo de la API tal como se muestra es posible porque su tipo Authorization (Autorizaci√≥n) est√° establecido en NONE. Si se ha utilizado la autorizaci√≥n de AWS_IAM, firmar√≠a la solicitud con los protocolos Signature Version 4 (SigV4). Para ver un ejemplo de una solicitud de este tipo, consulte Tutorial: Desarrollo de una API de REST con integraci√≥n HTTP no de proxy."
    },

    {
        "id": 67,
        "autor": "Adrian Francisco Becerra Arias",
        "pagina": "soloenbinario",
        "fecha": "30/07/2019",
        "titulo": "Creando servicios REST con JAVA",
        "link": "https://soloenbinario.wordpress.com/2019/07/30/creando-servicios-rest-java/",
        "contenido": "Actualmente la gran mayor√≠a de aplicaciones cuentan con, por lo menos, un servicio WEB. En los √∫ltimos tiempos se ha popularizado una nueva forma de crear y consumir servicios llamado RESTful. Este tipo de servicios ha tenido una gran acogida por su f√°cil uso y tambi√©n por los tiempos de respuesta cuando se consumen estos. Dada esta peque√±a introducci√≥n vamos al grueso del asunto y para ello vamos a utilizar las siguientes herramientas: Eclipse 2018-09 o superior. Maven 3.5.4 Jersey 2.27 JAXB 2.3.1 Creando el servicio WEB Vamos a crear una aplicaci√≥n WEB y para ello escoge la opci√≥n haciendo clic derecho, New -> Other‚Ä¶ -> WEB -> Dynamic WEB Project. Selecciona la opci√≥n Next. Ahora dale un nombre a tu aplicaci√≥n WEB y selecciona la opci√≥n Next. En la siguiente pantalla no es necesario configurar nada por lo que puedes seleccionar la opci√≥n Next. En esta pantalla selecciona la opci√≥n Gen√©rate web.xml deployment descriptor. Es importante que lo selecciones porque en este archivo de configuraci√≥n vamos definir el API REST y tambi√©n cuales son las clases que se encargan de publicar los servicios que vamos a definir. Seleccionadas las opciones importantes, ahora selecciona la opci√≥n Finish. Configurando Maven Has clic derecho sobre tu aplicaci√≥n WEB recientemente creada y selecciona la opci√≥n Configure -> Convert to Maven Project‚Ä¶ En la ventana que aparece puedes configurar los datos que aparecen all√≠, te recomiendo que el packaging no lo modifiques. Luego, selecciona la opci√≥n Finish. Configuraci√≥n del POM Ahora vamos a realizar lo siguiente: Vamos a importar las dependencias necesarias para que los servicios WEB funcionen sin problemas, y vamos a configurar el nombre del servicio WEB. Las dependencias que te recomiendo para la configuraci√≥n de un servicio WEB RESTful son: Glassfish Jersey Core Server. Glassfish Jersey Containers Servlet. Glassfish Jersey Inject HK2. Glassfish Jersey Media JSON Jackson. JAXB. Estas dependencias las puedes encontrar en la pagina MVNRepository, sin embargo aqu√≠ te los dejo (Recuerda que el siguiente bloque debe ir despu√©s de la etiqueta <build></build>): <dependencies> <dependency> <groupId>org.glassfish.jersey.core</groupId> <artifactId>jersey-server</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-servlet</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.inject</groupId> <artifactId>jersey-hk2</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> </dependencies> Creaci√≥n del servicio WEB Vamos ahora con la creaci√≥n de la clase y los m√©todos de consumo. Lo primero que vas a hacer es crear el package y luego vas a crear la clase que ser√° el servicio WEB como tal. Luego vamos a agregar algunas anotaciones para que nuestro API REST funcione. Para este ejercicio vamos a crear m√©todos de consumo de tipo GET y tipo POST que retornaran los siguiente: Datos de tipo String. Datos de tipo XML. Datos de tipo JSON. Objetos Objetos de tipo Response. Empecemos. Creada la clase vamos a agregarle encima del nombre de la misma la anotaci√≥n @Path. M√©todo que retorna un objeto de tipo String Dentro de la clase crea una m√©todo que retorne datos de tipo String. Cuando lo hayas creado, agr√©gale las anotaciones @GET, @Path y @Produces quedando de la siguiente manera: M√©todo que retorna informaci√≥n en formato XML Crea un m√©todo que retorne datos de tipo XML. Lo que vas a realizar a continuaci√≥n es crear un objeto que va a ser retornado por el m√©todo en cuesti√≥n. Este objeto debe tener lo siguiente para que el API REST lo transforme a XML: Anotaciones JAXB. Un constructor vac√≠o. En ese orden de ideas, crea tu clase la cual deber√° quedar como el siguiente ejemplo: Cuando hayas creado el objeto, crea tu m√©todo y agrega las anotaciones @GET, @Path, @Produces y dentro de esta √∫ltima anotaci√≥n agrega el MediaType APPLICATION_XML quedando de la siguiente manera: M√©todo que retorna informaci√≥n en formato JSON Crea un m√©todo que retorne datos en formato JSON. La creaci√≥n es bastante similar al m√©todo que retorna datos en formato XML, lo √∫nico que cambia es el tipo de MediaType que es APPLICATION_JSON. Entonces, el resultado deber√° ser el siguiente: M√©todo con paso de par√°metros mediante PathParam Crea un m√©todo que va a recibir un par√°metro por la URL. En este caso ser√° un par√°metro que reciba uno o varios argumentos y por cada argumento tienes que anteceder la anotaci√≥n @PathParam([nombre_parametro]) donde nombre_parametro ser√° el alias del par√°metro que debe ser parte de la URI, as√≠: Como te coment√©, en la anotaci√≥n @PathParam colocamos el alias p. Si te das cuenta este alias aparece como parte de la URI dentro de la anotaci√≥n @Path. Entonces, cuando realices el consumo del servicio WEB lo que debe ir en {p} es el dato que vas a pasar al m√©todo del servicio REST. M√©todo con paso de par√°metros mediante QueryParam Un m√©todo con paso de par√°metros mediante QueryParam ser√≠a, por ejemplo, http://localhost:8080/SampleREST/rest/WebServiceRest/bienvenida/json_qp?p=dato. De este modo, crea un m√©todo que retorne un objeto y que este sea retornado en formato JSON y luego agr√©gale la cantidad de argumentos que necesites pasarle. A cada uno de ellos debes anteponerle la anotaci√≥n @QueryParam que entre par√©ntesis debe ir el nombre del par√°metro que ser√° enviado por Query String. Es decir, que en la URL que mencion√© anteriormente estamos enviando un dato a la variable p, en la anotaci√≥n @QueryParam debe ir el dato llamado p, quedando de la siguiente manera: M√©todo POST En la creaci√≥n de m√©todos POST las variaciones con respecto a un m√©todo de tipo GET son que, debemos decirle qu√© tipo de informaci√≥n va a consumir, el tipo de informaci√≥n que va a producir y el retorno ser√° un dato de tipo Response. En este orden de ideas cr√©ate un m√©todo con la anotaci√≥n @POST y la anotaci√≥n @Consumes la cual va a aceptar datos en formato JSON. Como par√°metros al m√©todo puedes pasarle un objeto y el dato de retorno un objeto de tipo Response. De resto las anotaciones @Path y @Produces siempre van a ser las m√°s comunes en todos los m√©todos de un servicio REST. El m√©todo deber√≠a quedar como este: Creando un cliente para el consumo de los servicios Con pocas l√≠neas de c√≥digo se pueden crear clientes de consumo de servicios WEB REST en JAVA. Vamos a crear un cliente en JAVA SE para que veas el funcionamiento. Creando el proyecto En Eclipse, haz clic derecho y selecciona la opci√≥n New -> Other‚Ä¶ Selecciona la opci√≥n Java Project. Ahora selecciona un nombre para tu nuevo cliente REST y luego selecciona la opci√≥n Finish. Una vez se haya terminado la creaci√≥n del cliente, has clic derecho en √©l y selecciona la opci√≥n Configure -> Convert to Maven Project. En la nueva ventana que aparece, lo puedes dejar como lo sugiere el asistente y presionas la opci√≥n Finish. Las dependencias que puede usar para la creaci√≥n de los m√©todos cliente son: <dependencies> <dependency> <groupId>org.glassfish.jersey.core</groupId> <artifactId>jersey-client</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.inject</groupId> <artifactId>jersey-hk2</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> <dependency> <groupId>com.googlecode.json-simple</groupId> <artifactId>json-simple</artifactId> <version>1.1.1</version> </dependency> </dependencies> Creaci√≥n de la clase cliente En la carpeta src has clic derecho y selecciona la opci√≥n New -> Class. En la nueva ventana que aparece selecciona un paquete y luego Escribe el nombre de la clase. Si el paquete que escribiste no existe, no hay problema. El asistente lo crea autom√°ticamente. Ahora Selecciona la opci√≥n Finish. Ahora vamos a crear los siguientes m√©todos que van a consumir cada uno de las funciones que creamos para el servicio REST. Haciendo recuento, los m√©todos son: M√©todo para retornar datos de tipo String. M√©todo para retornar datos de tipo XML. M√©todo para retornar datos de tipo JSON. M√©todo para retornar objetos de tipo Response. Y los tipos de consumo son: Get Post QueryParam PathParam Declarando las instancias para el consumo del servicio Empieza con crear una instancia de tipo Client. como aparece a continuaci√≥n: Como puedes observar en la imagen anterior, puedes crear una instancia para toda la clase o bien puedes crear la instancia en cada m√©todo donde la vayas a utilizar. La elecci√≥n es tuya. Consumiendo datos de tipo XML, JSON y String ¬øPor qu√© este apartado abarca tres tipos de datos diferentes? Resulta que lo que vas a ver a continuaci√≥n es el consumo de servicios de datos de tipo String, JSON y XML con las mismas l√≠neas de c√≥digo. Es decir que lo √∫nico que cambia son los tipos de retorno y las URIs de los servicios WEB. As√≠ pues esta son las l√≠neas de c√≥digo que deber√≠as usar para consumir los servicios retornando datos String, XML y JSON: En esta instancias lo que debes cambiar para este ejemplo es el target, el request, el accept y el get. En conclusi√≥n los m√©todos quedar√≠an construidos de la siguiente manera: Consumiendo m√©todos Path Param El consumo de este tipo de servicios es muy similar al que vimos para consumir datos de tipo String, JSON y XML. Lo √∫nico que debemos agregar es el m√©todo path() despu√©s del m√©todo target() donde va la URI a consumir, quedando de la siguiente manera: Consumiendo m√©todos Query Param Exactamente igual que consumir m√©todos de tipo Path Param, as√≠ son los que se pasan datos por Query String. Despu√©s del m√©todo target() agrega el m√©todo queryParam() en el cual el primer argumento es el nombre de la variable Query String y en el segundo argumento colocas el valor para la variable. Recuerda que el nombre de la variable debe ser exactamente igual al que definiste en el m√©todo del servicio WEB. As√≠ quedar√≠a: Consumiendo m√©todos POST Quiz√° este puede ser el m√©todo al cual toca agregarla un poco mas de l√≠neas de c√≥digo. Pero a la final es un c√≥digo bastante sencillo de digerir. Como te puedes dar cuenta se necesita crear lo siguiente: Crear una nueva instancia del objeto que vas a enviar. Luego creamos una instancia de tipo Client. Crear una instancia de tipo WebTarget la cual va a recibir la URI del m√©todo del servicio a consumir. Crear una instancia de tipo Builder en la cual vamos a solicitar que el servicio nos retorne la informaci√≥n en formato JSON. Crear una instancia de tipo Response en donde vamos a pasar como par√°metro el objeto que instanciaste en el punto No . 1. Como pudiste observar, entender y practicar a lo largo de este POST, la creaci√≥n de servicios WEB REST es bastante sencilla por lo cual a futuro no tendr√°s tanto problema cuando empieces a crearlos en forma. Espero que este contenido haya sido de gran ayuda para ti. El c√≥digo fuente de estos ejercicios los puedes encontrar en los siguientes enlaces: Servicio REST: https://github.com/elle184/ScriptsJAVA/tree/master/SampleREST Cliente del servicio REST: https://github.com/elle184/ScriptsJAVA/tree/master/SampleRestClient"
    },

    {
        "id": 68,
        "autor": "Csacanam",
        "pagina": "platzi",
        "fecha": "01/02/2015",
        "titulo": "C√≥mo crear un API con Spark Java",
        "link": "https://platzi.com/blog/api-spark-java/",
        "contenido": "No es un secreto que el enfoque de Java hacia las aplicaciones web empresariales ha generado opiniones encontradas. Por una parte, Java EE es una arquitectura ideal para hacer aplicaciones de ese tipo, pues el servidor provee caracter√≠sticas importantes como la seguridad; sin que el desarrollador deba preocuparse por eso. Sin embargo, esto tambi√©n provoca que sea m√°s complicado desarrollar proyectos m√°s livianos;  pues se requiere de varias configuraciones para lograr hacerlo funcionar. Por esta raz√≥n, han surgido varias iniciativas para evitar que la popularidad de Java en la web disminuya. Actualmente, ocupa el tercer lugar en popularidad de lenguajes del lado del servidor. Por debajo de PHP y ASP .NET y por encima de lenguajes como Python y Ruby. Esas iniciativas no apuntan a que se deje de lado a Java EE; sino que buscan solucionar las necesidades de los nichos de las aplicaciones web empresariales. Por otro lado, tambi√©n surgieron otras que buscan solucionar necesidades menos exigentes de una forma m√°s √°gil; y ese es el caso del framework Spark Java. Se trata de un framework web liviano inspirado en Sinatra (framework basado en Ruby), que permite crear aplicaciones web con Java 8 con el m√≠nimo esfuerzo. El objetivo principal de este art√≠culo es introducir el framework y crear una soluci√≥n sencilla que te permita entender c√≥mo podr√≠as hacer uso del mismo. Para poder seguir el tutorial es necesario que tengas instalado el Java Development Kit 8 (JDK 8). Se puede instalar en Windows, Mac o Linux y descargar en la p√°gina oficial de Oracle. Adicionalmente, requerir√°s de un entorno de desarrollo (IDE) para Java que te permita crear un proyecto de Maven. Puedes hacer uso de Eclipse, IntelliJ o NetBeans. En mi caso, voy a hacer uso de la versi√≥n 8.0.2 de NetBeans para Java EE. Y si est√°s iniciando en el desarrollo de aplicaciones con este lenguaje, no te puedes perder el curso gratuito de Java B√°sico en Platzi. Aprender√°s todo lo que necesitas saber para crear proyectos desde cero. ¬øQu√© es Spark? Es un micro framework web de Java basado en Sinatra, cuyo tama√±o total no excede 1 MB. Para poder mantener un c√≥digo limpio, los desarrolladores decidieron dejar de soportar Java 7 y aprovechar la simplicidad que ofrece Java 8. Por esta raz√≥n, en Spark 2 s√≥lo se puede desarrollar con esta versi√≥n del lenguaje. En las im√°genes abajo puedes observar el cambio que hubo en el Hello World de Spark 1 a Spark 2. Hello World en Spark 1 API Spark Java Hello World en Spark 2 API Spark Java ¬øPara qu√© se usa Spark? Aunque Spark est√° basado en Sinatra, no se presenta como una competencia. Su finalidad es que haya una alternativa para los desarrolladores Java, que les permita desarrollar r√°pidamente aplicaciones web con el lenguaje que ya conocen. Seg√∫n una encuesta que realiz√≥ el equipo de Spark este a√±o, se dio a conocer que alrededor del 50% de los usuarios de Spark lo usan para crear APIs REST y un 25% lo usa para crear p√°ginas web. Tambi√©n mencionan que el 15% de las aplicaciones Spark desplegadas sirven a m√°s de 10.000 usuarios a diario. Con estos datos podemos concluir que es un framework adecuado si la finalidad es construir un API con Java de forma √°gil. Creando un Hello World Despu√©s de haber instalado el JDK 8 y Netbeans para Java EE, abriremos el √∫ltimo y crearemos un nuevo proyecto File > New project. En el di√°logo seleccionamos la carpeta Maven y elegimos Java Application. A continuaci√≥n seleccionamos la opci√≥n Next. API Spark Java En el siguiente di√°logo ingresamos el nombre del proyecto y damos clic en Finish. API Spark Java De esta manera, NetBeans crear√° un proyecto con la estructura de un proyecto Maven. Los elementos sobre los que trabajaremos ser√°n el paquete ubicado en Source Packages y el archivo pom.xml  ubicado en Project Files. API Spark Java Si abrimos el archivo pom.xml encontraremos un contenido parecido al siguiente: [java] <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>com.peewah</groupId> <artifactId>holaplatzi</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <maven.compiler.source>1.7</maven.compiler.source> <maven.compiler.target>1.7</maven.compiler.target> </properties> </project> [/java] Lo que debemos hacer a continuaci√≥n es agregar la dependencia de Spark al archivo para que Maven lo instale en el proyecto. Nuestro archivo pom.xml quedar√≠a as√≠: [java] <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>com.peewah</groupId> <artifactId>holaplatzi</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <maven.compiler.source>1.7</maven.compiler.source> <maven.compiler.target>1.7</maven.compiler.target> </properties> <!-- Dependencias de Maven --> <dependencies> <!-- Dependencia Spark Java --> <dependency> <groupId>com.sparkjava</groupId> <artifactId>spark-core</artifactId> <version>2.3</version> </dependency> </dependencies> </project> [/java] Para que Maven instale la librer√≠a, debemos dar clic derecho sobre el proyecto y seleccionar la opci√≥n Build. Al terminar la compilaci√≥n, nuestro proyecto tendr√° instalado Spark Java. Ahora que ya configuramos lo necesario para agregar Spark Java al proyecto, vamos a escribir el c√≥digo necesario. Para lograrlo damos clic derecho sobre el paquete en Source Packages, seleccionamos New y luego Other. API Spark Java En el di√°logo seleccionamos la carpeta Java; elegimos Java Class y damos click en Next. API Spark Java En el siguiente di√°logo escribimos el nombre de nuestra clase, HolaPlatzi en este caso, y seleccionamos Finish. API Spark Java NetBeans nos crea nuestra clase y la coloca dentro del paquete que hemos creado previamente. El c√≥digo inicial debe ser algo as√≠: [java] package com.peewah.holaplatzi; /** * * @author csacanam */ public class HolaPlatzi { } [/java] A continuaci√≥n, agregaremos el c√≥digo necesario para crear un servicio web de tipo GET que retorne un mensaje que podremos observar en el navegador. Para lograrlo debemos crear el m√©todo main, que es el punto de entrada en una aplicaci√≥n Java. Dentro de main se agrega el servicio web de tipo GET. En la l√≠nea de c√≥digo donde lo definimos, es necesario especificar el tipo, la ruta (/hello), los par√°metros req (request) y response (res) y por √∫ltimo, el mensaje que se va a mostrar en el navegador. As√≠, la clase que creamos anteriormente debe quedar as√≠: [java] package com.peewah.holaplatzi; import static spark.Spark.*; /** * * @author csacanam */ public class HolaPlatzi { public static void main(String[] args) { get( /hello , (req, res) ->  Hola Platzi. Saludos desde Peewah. ); } } [/java] Si NetBeans indica que hay un error por las expresiones lambda, debemos dar clic derecho sobre el proyecto y seleccionar Properties. En la categor√≠a Sources debemos cambiar la opci√≥n Source/Binary Format a 1.8. Esto s√≥lo estar√° disponible si hemos instalado previamente el JDK 8. Para ejecutar el proyecto, elegimos la opci√≥n correr proyecto en el bot√≥n verde en la parte superior o presionamos F6. Al hacer esto, se abrir√° un di√°logo donde se indicar√° que seleccionemos la clase principal (hasta el momento solamente tenemos creada una). Despu√©s de esto, presionamos la opci√≥n Select Main Class. API Spark Java Despu√©s de unos cuantos segundos la consola nos muestra un mensaje similar al mostrado a continuaci√≥n, indicando que el servidor est√° corriendo por el puerto 4567. Este es el puerto por defecto de Spark Java. Sin embargo, podemos modificarlo si as√≠ lo deseamos. API Spark Java Para probar que nuestro servicio web est√° funcionando, abrimos nuestro navegador de preferencia y ponemos la direcci√≥n http://localhost:4567/hello. El resultado del navegador deber√° mostrar algo as√≠: API Spark Java Y as√≠ es como logramos crear de forma sencilla y r√°pida un servicio web con Spark Java que retorna un mensaje de saludo. Si te interesa saber m√°s y conocer el potencial de este framework web y, adem√°s, aprender a escribir y leer c√≥digo en Java, buenas pr√°cticas de programaci√≥n, paradigma de orientaci√≥n a objetos y todos los elementos que necesitas para programar desde cero;"
    },

    {
        "id": 69,
        "autor": "Javi Moreno",
        "pagina": "programar",
        "fecha": "18/12/2016",
        "titulo": "C√≥mo Crear Una API REST",
        "link": "https://programar.cloud/post/como-crear-un-api-rest/",
        "contenido": "Vamos a ponernos el gorrito de un miembro del equipo, en concreto la persona que se haya asignado la tarea de implementar la historia de usuario PROGRESO_CURSOS. ¬øLa recuerdas del post anterior ? Dec√≠a algo as√≠: Como administrador de cursos deseo poder obtener una visualizaci√≥n global de la utilizaci√≥n de cada curso y unidad did√°ctica para conocer su popularidad y actuar en consecuencia.* Bien, manos a la obra: tendremos que detectar los recursos a manipular, definir unas rutas HTTP claras para invocar operaciones sobre ellos y generar la respuesta deseada. No problem. O s√≠. ¬°Ojo! Para que no haya confusiones entre el rol √°gil de product owner y el cargo que ostenta el cliente para el que desarrollamos la aplicaci√≥n (descrito tambi√©n como propietaro del producto originalmente pero que no siempre tiene por qu√© coincidir) he cambido el nombre de este √∫ltimo a un mucho m√°s l√≥gico administrador de cursos. Mil perdones, esta noche me pego unos latigazos. Umh‚Ä¶ Vale, ya podemos seguir. Fundada en 1880source: imgur.com Los Recursos En la Wikipedia tienes una buena descripci√≥n sobre REST, no voy a repetirte lo que hay all√≠: mi plan es ir cont√°ndote los detalles que hagan falta en el momento en el que los necesites, no adelantarlos todos para despu√©s aplicarlos. Es como a m√≠ me gusta aprender. Pero si prefieres hacerte una idea de lo que vamos a hablar antes de seguir no te cortes y visita el link antes de continuar leyendo. Tampoco te preocupes si tu programaci√≥n est√° un poco oxidada, ver√°s que no hago mucho hincapi√© en ese aspecto en este post. Lo primero que tenemos que tener claro es que REST se estructura alrededor de recursos, las entidades que permites manipular. Esas entidades deben quedar representadas en la URL (la ruta) que se utiliza para ejecutar operaciones sobre ellas. As√≠ que el primer paso es definir la lista de recursos y para ello vamos a echar un vistazo a la historia de usuario. El administrador de cursos, claramente, es un actor involucrado que en el fondo corresponder√° a un tipo de usuario. No va a tener un papel relevante m√°s all√° de la autorizaci√≥n: qu√© operaciones puede invocar y a qu√© informaci√≥n tiene acceso. As√≠ que de momento aparcamos su implementaci√≥n. Esto generar√° una nueva tarea que consistir√° en integrar el sistema de permisos en la funcionalidad que implementemos ahora mismo pero ya la llevaremos a cabo m√°s tarde. Lo comentamos con el resto del equipo, apuntan la nueva tarea y pasamos al siguiente paso. F√≠jate en algo importante: hemos pedido una aclaraci√≥n. Qu√© loco. Durante el desarrollo. Seguimos revisando la historia de usuario. ¬°Encontramos otro sustantivo: curso! Claramente aqu√≠ tenemos nuestro primer recurso. Preguntamos al product owner y nos comenta que un curso b√°sicamente ahora mismo est√° definido por un c√≥digo alfanum√©rico √∫nico e inmutable, un t√≠tulo en espa√±ol, una descripci√≥n de unas 100 palabras y una serie de unidades did√°cticas. F√≠jate en algo importante: hemos pedido una aclaraci√≥n. Qu√© loco. Durante el desarrollo. M√°s te vale que sea posible llevar a cabo esta acci√≥n de la manera m√°s eficiente posible si no quieres acabar como yo en ese horrible proyecto . De la historias de usuario y de la √∫ltima conversaci√≥n detectamos que existe otro recurso llamado unidad did√°ctica. De nuevo el product owner nos explica que cada una de ellas tiene un n√∫mero de orden (no consecutivo e inmutable) y un t√≠tulo. Usando el c√≥digo es posible generar el link al post que en el fondo la implementa. El product owner nos dice que simplemente quiere saber cu√°nta gente ha participado activamente en cada uno de los cursos y en cada una de las unidades did√°cticas y que ello puede saberse contando cu√°ntas personas han cambiado el estado de una unidad a ‚Äúcompletado‚Äù. As√≠ que ya tenemos nuestra lista inicial de recursos: curso y unidad-didactica. Adem√°s hay una relaci√≥n jer√°rquica clar√≠sima entre ellos: un curso est√° compuesto de unidades did√°cticas. Compartimos esta informaci√≥n con el resto del equipo que no ha estado presente en la conversaci√≥n porque est√° claro que les har√° falta y no queremos que nuestro product owner nos odie m√°s de lo imprescindible por preguntarle diez veces lo mismo. Las Operaciones ¬°Son consultas, est√° bastante claro! En concreto confirmamos con el product owner que est√° interesado en poder visualizar datos del n√∫mero de estudiantes que han participado en cada curso y tambi√©n quiere ver el n√∫mero de estudiantes que han participado en cada lecci√≥n de un curso concreto entre un rango de fechas determinado. La aclaraci√≥n no es muy diferente de lo que nos hab√≠a comentado en la reuni√≥n de planificaci√≥n as√≠ que decidimos que podemos implementarlo. Pero no tiene por qu√© ser as√≠: si el trabajo de planificaci√≥n fue pobre y fallamos en describir correctamente la tarea resulta imposible estimar su duraci√≥n correctamente. En ese caso la mejor opci√≥n es siempre crear nuevas tareas con los detalles extra que no se puedan asumir en este sprint y dejarlos pendientes para el siguiente. Si implementar el filtro hubiese supuesto mucho trabajo eso es exactamente lo que habr√≠amos hecho. Y ¬øsabes una cosa que a m√≠ me sigue costando pero que poco a poco voy aprendiendo? S√≠, exacto: a decir NO. Y es cr√≠tico hacerlo cuando est√°s en este tipo de desarrollo y se propone un cambio de funcionalides importante porque te has comprometido a muy corto plazo para completar una serie de tareas. Si tienes problemas enfrent√°ndote a las peticiones del product owner, avisa al scrum master: sus responsabilidades incluyen adem√°s de hacer caf√©s el mantener la din√°mica del sprint y (si es necesario) controlar las peticiones del product owner. grumpy cat dice NO.source: imgur.com Bien, volvamos a las operaciones. Vamos a definir rutas que tengan cierta sem√°ntica y utilizaremos el plural para representar el recurso (en serio, hazlo, todo queda m√°s natural). Recuerda (por lo que has le√≠do en la Wikipedia) que en REST nos vamos a esforzar en utilizar la sem√°ntica original del protocolo HTTP para describir qu√© queremos hacer sobre esos recursos. Si repasas la RFC de HTTP (no, en serio, hazlo, que es s√∫per legible y sencilla) ver√°s que para obtener un documento debe usarse el m√©todo GET. Tambi√©n vamos a tomar la convenci√≥n de que si una parte de la ruta es variable (para especificar un subconjunto del total de recursos) colocaremos su identificador entre llaves. Digamos que definimos estas operaciones: GET /cursos GET /cursos/{codigo}/unidades-didacticas La primera nos retornar√° la informaci√≥n de todos los cursos y la segunda informaci√≥n sobre las unidades did√°cticas de un curso concreto. Un ejemplo de la segunda URL en la que se ha aplicado un valor a la parte variable ser√≠a: /cursos/introduccion/unidades-didacticas indicando que quieres conocer los datos de las unidades did√°cticas del curso con el c√≥digo introduccion. As√≠ que ¬øqu√© te parece esta primera aproximaci√≥n? Exacto: posiblemente nos hemos venido arriba. La primera ruta representa todos los cursos con lo que sem√°nticamente ser√≠a perfectamente aceptable devolver todos los datos asociados a los mismos. Esto incluir√≠a el n√∫mero de alumnos inscritos pero tambi√©n la descripci√≥n. Y este √∫ltimo atributo nos supone una sobrecarga de unos 500 bytes por cada uno de los cursos que no vamos a utilizar para solucionar este caso de negocio. Este es el criterio importante: c√≥mo se adapta nuestra operaci√≥n a la query que necesitamos responder por lo que decidimos que este dise√±o supone demasiado sobrepeso en el documento de respuesta y tenemos que buscar una soluci√≥n alternativa. Este es el criterio importante (c√≥mo se adapta nuestra operaci√≥n a la query que necesitamos responder). Hay dos opciones. La primera ser√≠a a√±adir un mecanismo por el cual podamos especificar en la URL una proyecci√≥n, que es una forma elegante de decir que solo quieres parte de la informaci√≥n disponible en cada momento. Esta opci√≥n la implementar√≠amos con par√°metros en la querystring de la URL. O bien tambi√©n puedes crear un nuevo recurso dependiente del anterior que solo incluya la informaci√≥n que necesitamos. Calma, ahora te ense√±o dos ejemplos: GET /cursos?proyeccion=titulo,actividad GET /cursos/actividad ¬øQu√© te parece mejor? Pues √©sa es la decisi√≥n correcta. En mi caso creo que la segunda opci√≥n se entiende mejor, es m√°s legible sobre todo si m√°s adelante tenemos que utilizar la querystring para alguna otra cosa. Y seguramente tambi√©n tiene una sem√°ntica m√°s fuerte. As√≠ que optamos por ella. Pero no deja de ser una decisi√≥n de dise√±o, defi√©ndela como tal. Por coherencia seguimos la misma t√°ctica con las unidades did√°cticas. Y nuestra API queda as√≠: GET /cursos/actividad GET /cursos/{codigo}/unidades-didacticas/actividad Bien, perfecto. Funcionar√°. Ahora tenemos que solucionar el extra del que hemos hablado antes: el poder filtrar entre un rango de fechas. Y aqu√≠ s√≠ es muy c√≥modo y natural ampliar la informaci√≥n que proporcionamos en forma de querystring, como par√°metros opcionales. Por ejemplo: GET /cursos/actividad?desde={fechaInicial}&hasta={fechaFinal} El formato para especificar fechas m√°s popular es el de ISO-8601. Y vigila, porque ya sabes que en inform√°tica las fechas tienen siempre m√°s peligro que una pira√±a en un bid√©: almacena el dato siempre en UTC y solo cuando dibujes pantallas pres√©ntalo en el formato local del usuario. O tendr√°s poblemas. Serios. B√°sicamente la UTC (Coordinated Universal Time acronimizado por alguien que llevaba dos cervezas de m√°s) se determina a partir de las oscilaciones de m√°s de 70 relojes at√≥micos y es en el fondo el valor reconocido internacionalmente como fecha actual independientemente de la zona horaria en la que te encuentres. Bien, filtro solucionado. Un inciso ¬øtendr√≠a sentido una ruta de este estilo? /cursos/{codigo-curso}/unidades-didacticas/{numero-ul}/actividad Probablemente no: el resultado ser√≠a simplemente un n√∫mero con el n√∫mero de unidades did√°cticas completadas y estar√≠as pagando toda la latencia de una petici√≥n/respuesta para conseguir una informaci√≥n demasiado precisa. Tardar√≠as lo mismo (o casi) en retornar todos los datos de la unidad didactica que seleccionases (c√≥digo, t√≠tulo, actividad, etc) y adem√°s con toda seguridad ese ser√≠a el caso de uso real de la operaci√≥n: manipular la ficha entera de una unidad did√°ctica, no solo conocer los estudiantes que la han completado. La ruta quedar√≠a sin el recurso final: /cursos/{codigo-curso}/unidades-didacticas/{numero-ul} Si te parece complicado, piensa en pantallas para humanos: posiblemente crear√≠as una para visualizar la ficha de una unidad did√°ctica pero no para presentar tan solo la actividad que ha recibido. La mejor manera de incrementar tu productividad es no hacer lo que nadie ha pedido. Pero recuerda que nadie nos ha pedido esta funcionalidad y que la mejor manera de incrementar tu productividad es no hacer lo que nadie ha pedido. Las Respuestas Una vez solucionado el c√≥mo invocamos la operaci√≥n tenemos que decidir el formato en el que responderemos. Y s√© lo que esperas: esperas que te diga que XML es muerte y hay que usar JSON. Y lo cierto es que XML es muerte pero si tu usuario (¬°el consumidor del API!) trabaja con XML es tu responsabilidad darle esa opci√≥n: que sea √©l quien con por ejemplo la cabecera Accept de HTTP te indique qu√© prefiere. La enorme mayor√≠a de frameworks del mundo permiten generar los dos formatos autom√°ticamente as√≠ que ante todo mucha calma. Por cierto, una cabecera HTTP es‚Ä¶ no, espera, mejor √©chale un vistazo a este v√≠deo que describe HTTP para entender los detalles de este protocolo. Lo que te ense√±o ahora es un ejemplo del posible resultado para ambas APIs para la petici√≥n /cursos/actividad?desde=2016-11-01T00:00:00-00:00&hasta=2000-10-31T23:59:59-00:00 [ { codigo :  cultura , titulo :  Cultura DevOps , unidadesDidacticasCompletadas : 2580, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z }, { codigo :  apirest , titulo :  Dise√±o de APIs , unidadesDidacticasCompletadas : 2200, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z }, { codigo :  spoiler , titulo :  No way , unidadesDidacticasCompletadas : 0, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z } ] El hecho de repetir el rango de fechas para cada curso es una decisi√≥n de dise√±o, de nuevo. El objetivo es facilitar la vida al desarrollador que utilice la API al devolverle objetos muy simples como respuestas en lugar de obligarle a crear una composici√≥n en la que un objeto Curso contenga instancias de tipo Actividad. Una vez hayamos publicado esta versi√≥n de la API estamos firmando un contrato: no vamos a poder cambiar el nombre y el tipo de ninguno de sus atributos. Y sobre todo recuerda que una vez hayamos publicado esta versi√≥n de la API estamos firmando un contrato: no vamos a poder cambiar el nombre y el tipo de ninguno de sus atributos. A√±adir nueva informaci√≥n puede ser aceptable pero a menos que quieras mantener varios proyectos que implementen distintas versiones del web service (ya te contar√© c√≥mo hacerlo si resulta inevitable) los nombres y tipos que hayas decidido aqu√≠ est√°n para quedarse. Y si no me crees echa un vistazo a la cantidad de atributos repetidos (con distinto formato) en un tuit cualquiera. Por ejemplo, la propiedad geo est√° duplicada en place (en distintos formatos) y deber√≠a ir asociada a location. Pero los chiquitos que crearon el contrato se han portado bien y han resistido el impulso de refactorizarlo. anatom√≠a de un tuit, por raffi krikoriansource: imgur.com Pero ¬øse te ocurre otro par de formatos que podr√≠an ser √∫tiles en nuestro caso? Venga, para un momento y piensa un poco en ello. Luego sigue leyendo. Yeeeeees. Estamos hablando de n√∫meros, estad√≠sticas. Y el product owner nos ha dicho que quiere dibujarlos, representarlos. As√≠ que ¬øpor qu√© no ofreces la posibilidad de pedir un dibujo? Ya sabes, image/png, image/jpg‚Ä¶ lo que sea. No es tan dif√≠cil, de nuevo tienes una lista enorme de librer√≠as que te ayudan. De esta manera le est√°s facilitando enormente el trabajo de hacer una primera integraci√≥n entre su producto y tu API. Y por otro lado si hay n√∫mero de por medio una forma muy potente de a√±adir todo tipo de funcionalidades a tu aplicaci√≥n es dejando que el usuario final (el profesor, en este caso) la implemente. En forma de hoja de c√°lculo, por ejemplo. Hagamos que nuestro web service sea tambi√©n capaz de retornar ficheros tipo text/csv y que los magos de las rejillas monten sus historias sin tener que pedirnos ayuda. excel magicsource: imgur.com Como ahora mismo t√∫ eres mi usuario y quiero que puedas jugar r√°pidamente con el microservicio he a√±adido tambi√©n el c√≥digo necesario para que te responda si invocas la url desde el navegador. En el fondo se trata simplemente de aceptar tambi√©n text/html como un posible formato de respuesta. T√©cnica y est√©ticamente impecable, que no te vengan con historias de que un web service solo debe retornar JSON. El mismo razonamiento puedes hacer a la hora de recibir informaci√≥n en la petici√≥n. En nuestro caso no ha hecho falta pero mientras m√°s flexibilidad aportes, mejor. Aunque reconozco que muchas veces es m√°s costosa de implementar esta parte as√≠ que si t√∫ tambi√©n terminas llegando a un compromiso no te sientas demasiado mal. La Implementaci√≥n En este post no voy a dar muchos detalles sobre ella, no es el objetivo que tengo aqu√≠. En cuanto pueda montar√© una serie de entradas especiales centradas espec√≠ficamente en el desarrollo y como ya escuchaste en el cap√≠tulo anterior se basar√° en Spring Boot: este framework me tiene el coraz√≥n robado, brib√≥n. Aqu√≠ tienes el repositorio de c√≥digo fuente y en este otro link encontrar√°s el ejecutable ya compilado. Elige el camino con el que est√©s m√°s c√≥modo para probarlo pero seguramente este √∫ltimo te ser√° m√°s sencillo si no has programado antes en java: solo tienes que instalar el kit de desarollo y desde l√≠nea de comando: cd <carpeta_en_la_que_tienes_el_jar> java -jar controlactividad-0.0.1-SNAPSHOT.jar Aparecer√°n unos bonitos mensajes (incluyendo el aviso de que el servidor de aplicaciones est√° listo para recibir peticiones) y dado que son consultas y por lo tanto utilizan el m√©todo GET de HTTP puedes probarlas desde tu navegador: http://localhost:8080/cursos/actividad?desde=2016-11-01T00:00:00-00:00&hasta=2000-10-31T23:59:59-00:00 http://localhost:8080/cursos/introduccion/actividad Ver√°s tambi√©n que si cambias los par√°metros ¬°obtienes exactamente el mismo resultado! Eso es porque solo est√° implementada la capa del Controlador, es decir, la que permite interaccionar con el exterior de la aplicaci√≥n y que es la que define la API. Las reglas de negocio, la base de datos y el resto de componentes est√°n simulados y nos dedicaremos a ellas m√°s adelante. Es m√°s, si pruebas la segunda direcci√≥n a fecha de hoy no te funcionar√° porque no la he implementado todav√≠a: no aporta mucho a lo que ya hemos explicado. Querr√°s comprobar tambi√©n si los otros formatos de respuesta funcionan y para eso tienes que ser capaz de enviar cabeceras HTTP. Desde el navegador puedes hacerlo con extensiones como el s√∫per conocido Postman para Chrome o el Rest-easy para Firefox. En el v√≠deo en el que te hablar√© de HTTP te ense√±o a usarlos. Si (como yo) eres un rom√°ntico o una rom√°ntica en realidad terminar√°s usando the good old cUrl. En El Siguiente Cap√≠tulo Recuerda: tengo un plan. Y el plan incluye empezar a hablar sobre tests tan r√°pido como sea posible porque son la √∫nica manera de asegurar la calidad de tu c√≥digo. Nos dedicaremos a ello semana que viene mientras gestionamos los posibles errores de la API y alguna operaci√≥n adicional. Tambi√©n hablaremos de documentaci√≥n autom√°tica, algo cr√≠tico a la hora de facilitar la vida a tus usuarios. Y de HATEOAS y paginaci√≥n. No, eso no va a caber. Lo dejaremos para la siguiente entrega. Pero ¬°seguiremos implementando nuestro microservicio! ¬°Ah! Y si no tienes clara alguna de las ideas que han ido saliendo (por ejemplo qu√© es JSON), d√≠melo. Tengo un plan, pero si no te gusta aqu√≠ tengo otros ;-) jv pd: ¬øAdivinas de qui√©n es la m√∫sica de la entradilla? Yes, de Marcus. No me digas que no sonr√≠es cuando la oyes. ppd: La imagen del post ilustra perfectamente lo que quiero hacer una vez pase la pr√≥xima semana y es de Ben GAllager. pppd: Como casi siempre te dejo una tira de Dilbert. Por cierto, la de esta semana es espectacular. ppppd: Simon Fodden escribi√≥ hace tiempo una interesante art√≠culo sobre la anatom√≠a de un tuit utilizando para ello el gr√°fico que has visto antes de Raffi Krikorian."
    },

    {
        "id": 70,
        "autor": "Roberto Canales Mora",
        "pagina": "adictosaltrabajo",
        "fecha": "23/09/2015",
        "titulo": "Creando servicios RESTful con NetBeans 8",
        "link": "https://www.adictosaltrabajo.com/2015/09/23/creando-servicios-restful-con-netbeans-8/",
        "contenido": "En este tutorial vamos a ver c√≥mo utilizar el asistente de NetBeans 8 para crear servicios RESTful f√°cilmente Hace tiempo que no tocaba c√≥digo y como tengo que impartir unos cursos para directivos de Gobierno SOA me he puesto a mirar como crear ejemplos sencillos y r√°pidos de servicios. Aunque en mi contexto utilizamos m√°s Eclipse, a mi siempre me ha gustado lo intuitivo de NetBeans. En este caso voy a ense√±ar como crear servicios RESTful usando los asistentes de NetBeans 8, bueno, hasta donde se puede. Equipo iMac (Retina 5K, 27 pulgadas, finales de 2014) 4 GHz Intel Core i7 16 GB 1600 MHz DDR3 AMD Radeon R9 M295X 4096 MB Antes de empezar voy a ver la versi√≥n que tengo en mi Mac de Java. Shell java -version 1 java -version Nos descargamos NetBeans, en Bundle para JEE: Arrancamos Creamos un nuevo proyecto Elegimos el tipo aplicaci√≥n Web Voy a hacer un ejemplo de Pizza por lo que creo el proyecto con ese nombre Elegimos en servidor de aplicaciones que viene por defecto No elegimos ning√∫n framework Y damos a ¬´Play¬ª para probar que la aplicaci√≥n funciona. De momento solo tiene una p√°gina con un literal. Ahora vamos a a√±adir un fichero Elegimos RESTful WebService from patterns. Es lo m√°s sencillo y luego ya tocaremos. Elegimos el nombre del recurso a gestionar y de la clase contenedora El proyecto por defecto no trae un Web.xml por lo que lo creamos a partir del mismo asistente. Le metemos el servlet mapping de jersey. Curiosamente hay un peque√±o problema, que el c√≥digo generado es de la versi√≥n 1 y no 2, por lo que hay que buscar las librer√≠a de la versi√≥n 1 (por internet), descargarlas y a√±adirlas a mano (dar al bot√≥n derecho en el proyecto para que aparezcan las propiedades) No es dif√≠cil de encontrar Lo descargamos, descomprimimos y a√±adimos. Ahora ya tenemos un proyecto con este aspecto. Si lo ejecutamos saldr√° la pagina de antes. Para ver algo debemos meter en el navegador la URL http://localhost:8080/PizzasAutentia/ (en mi caso) Inicialmente fallar√° porque no hay un c√≥digo m√≠nimo y se lanza una excepci√≥n por defecto Java throw new UnsupportedOperationException(); 1 throw new UnsupportedOperationException(); A√±adimos una linea solo para ver que funciona. Java public Pizza getXml() { return ‚Äúlo que sea‚Äù; } 1 2 3 public Pizza getXml() { return ‚Äúlo que sea‚Äù; } Yo he metido una respuesta en un pseudo xml Como uso Firefox, instalo el pluggin RESTClient. https://addons.mozilla.org/es/firefox/addon/restclient/ Ahora puedo controlar mejor que es lo que mando y llega Vemos ejemplo de respuesta 200 Voy a hacer un poco de limpia, y solo dejo la clase PizzaRecursos, que nos sobra para hacer mapping y juguetear un poco con Jersey. Java @GET @Produces( application/xml ) public String getXml() { //TODO return proper representation object return  <datos>Ejemplo Colecci√≥n</datos> ; // throw new UnsupportedOperationException(); } /** * POST method for creating an instance of PizzaRecurso * @param content representation for the new resource * @return an HTTP response with content of the created resource */ @POST public Response postXml(String content) { System.out.println( por aqui ); return Response.ok().build(); // return Response.created(context.getAbsolutePath()).build(); } /** * Sub-resource locator method for {id} */ @Path( {id} ) public String getPizzaRecurso(@PathParam( id ) String id) { System.out.println( reclamamos elemento ); return  Complicando los mappings ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @GET @Produces( application/xml ) public String getXml() { //TODO return proper representation object return  <datos>Ejemplo Colecci√≥n</datos> ; // throw new UnsupportedOperationException(); } /** * POST method for creating an instance of PizzaRecurso * @param content representation for the new resource * @return an HTTP response with content of the created resource */ @POST public Response postXml(String content) { System.out.println( por aqui ); return Response.ok().build(); // return Response.created(context.getAbsolutePath()).build(); } /** * Sub-resource locator method for {id} */ @Path( {id} ) public String getPizzaRecurso(@PathParam( id ) String id) { System.out.println( reclamamos elemento ); return  Complicando los mappings ; } Este es el aspecto Ahora que funciona, vamos a crear una clase y hacer el mapping directo a XML. Creamos la clase Pizza A manita (ya por no andar capturando m√°s pantallas) creamos atributos, constructor por defecto, constructor deseado y lo anotamos como @XmlRootElement No olvidar: import javax.xml.bind.annotation.*; Java /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package PizzaAutentiaPkg; import javax.xml.bind.annotation.*; /** * * @author rcanales */ @XmlRootElement public class Pizza { private int     id; private String  nombre; private String  desc; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public Pizza() { // costructor por defecto id      = 0; nombre  =  defecto ; desc    =  defecto ; } public Pizza(int pid, String pnombre, String pdesc) { this.id      = pid; this.nombre  = pnombre; this.desc    = pdesc; } @Override public String toString() { return new StringBuffer(  id:  ). append(id). append(  nombre:  ). append(nombre). append(  desc:  ). append(desc).toString(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package PizzaAutentiaPkg; import javax.xml.bind.annotation.*; /** * * @author rcanales */ @XmlRootElement public class Pizza { private int     id; private String  nombre; private String  desc; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public Pizza() { // costructor por defecto id      = 0; nombre  =  defecto ; desc    =  defecto ; } public Pizza(int pid, String pnombre, String pdesc) { this.id      = pid; this.nombre  = pnombre; this.desc    = pdesc; } @Override public String toString() { return new StringBuffer(  id:  ). append(id). append(  nombre:  ). append(nombre). append(  desc:  ). append(desc).toString(); } } Aqu√≠ un poco m√°s bonito Modificamos el m√©todo get para decir que produce XML y que retorna un objeto de tipo Pizza. Java @GET @Produces( application/xml ) public Pizza getXml() { //TODO return proper representation object return new Pizza(1,  Carbonara ,  Nuestra m√°s afamada ); // throw new UnsupportedOperationException(); } 1 2 3 4 5 6 7 8 @GET @Produces( application/xml ) public Pizza getXml() { //TODO return proper representation object return new Pizza(1,  Carbonara ,  Nuestra m√°s afamada ); // throw new UnsupportedOperationException(); } Y la magia est√° hecha."
    },

    {
        "id": 71,
        "autor": "Cecilio √Ålvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "14/06/2013",
        "titulo": "Introducci√≥n a Servicios REST",
        "link": "https://www.arquitecturajava.com/servicios-rest/",
        "contenido": "Cada d√≠a necesitamos mas usar servicios web REST . Estos servicios se diferencian de una forma importante de los servicios web SOAP con los que hemos trabajado . REST (Representational State Transfer) es un estilo de arquitectura para desarrollar servicios. Los servicios web que siguen este estilo deben cumplir con las siguientes premisas. Cliente/Servidor : Como servicios web son cliente servidor y definen un interface de comunicaci√≥n entre ambos separando completamente las responsabilidades entre ambas partes. Sin estado : Son servicios web que no mantienen  estado asociado al cliente .Cada petici√≥n que se realiza a ellos es completamente independiente de la siguiente . Todas las llamadas al mismo servicio ser√°n id√©nticas. Cache : El contenido de los servicios web REST ha se puede cachear de tal forma que una vez realizada la primera petici√≥n al servicio el resto puedan apoyarse en la cache si fuera necesario. Servicios Uniformes :Todos lo servicios REST compartir√°n una forma de invocaci√≥n y m√©todos uniforme utilizando los metodos GET,POST,PUT ,DELETE Arquitectura en Capas: Todos los servicios REST estan orientados hacia la escalabilidad y un cliente REST no ser√° capaz de distinguir entre si esta realizando una petici√≥n directamente al servidor , o se lo esta devolviendo un sistema de caches intermedio o por ejemplo existe un balanceador que se encarga de redirigirlo a otro servidor. Una  vez vista una introducci√≥n al concepto de servicio REST en los siguientes POST nos encargaremos de construir uno usando los standards de la plataforma JEE."
    },

    {
        "id": 72,
        "autor": "Arteco",
        "pagina": "arteco-consulting",
        "fecha": "01/02/2020",
        "titulo": "C√≥mo crear una aplicaci√≥n con SpringBoot Initializr",
        "link": "https://www.arteco-consulting.com/tu-primera-aplicacion-con-spring-boot/",
        "contenido": "Por parte de los desarrolladores de Spring, se tiene a disposici√≥n una herramienta web online denominada Spring Initializr donde por medio de unos par√°metros de configuraci√≥n genera autom√°ticamente un proyecto Maven o Gradle, seg√∫n se elija, en un archivo comprimido Zip conteniendo la carpeta con la estructura de la aplicaci√≥n para ser importada directamente desde el editor de programaci√≥n como Eclipse IDE, Netbeans IDE o Intellij. Se puede acceder mediante el enlace a la direcci√≥n: https://start.spring.io/ El asistente web solicita una serie de datos necesarios para poder ejecutar la plantilla que construye los primeros archivos del programa. Para todos ellos aporta una configuraci√≥n por defecto que conviene cambiar, como el nombre de la aplicaci√≥n, o el package que se usar√° en las clases generadas. A continuaci√≥n se explica qu√© par√°metros hay y para qu√© sirven: Project: Permite elegir la herramienta de construcci√≥n de la aplicaci√≥n. En Java las dos herramientas m√°s usadas son Maven y Gradle. Recomendamos Maven al ser la m√°s expendida. Language: Lenguaje de programaci√≥n que se va a utilizar en la aplicaci√≥n. Los tres tipos est√°n soportados por la m√°quina virtual JVM. Java es la opci√≥n m√°s extendida y tiene mejor soporte de los editores de programaci√≥n. Spring Boot: Versi√≥n del Spring Boot a usar. Siempre que se pueda se optar√° por la √∫ltima estable, compuesta √∫nicamente por n√∫meros. Project Metadata, Group: Se refiere al descriptor de Maven groupId, utilizado para clasificar el proyecto en los repositorios de binarios. Normalmente se suele usar una referencia similar a la de los packages de las clases. Por ejemplo, com.arteco.web para disponer todas las aplicaciones web en el mismo directorio. Project Metadata, Artifact: Se refiere al otro descriptor de Maven artifactId, y por tanto para indicar el nombre del proyecto y del binario resultante. La combinaci√≥n de groupId y artifactId (m√°s la versi√≥n) identifican inequ√≠vocamente a un binario dentro de cualquier organizaci√≥n. Packaging: Indica qu√© tipo de binario se debe construir. Si la aplicaci√≥n se ejecutar√° por s√≠ sola se seleccionar√° JAR, √©ste contiene todas las dependencias dentro de √©l y se podr√° ejecutar con java -jar binario-<version>.jar. Si por el contrario, la aplicaci√≥n se ejecutar√° en un servidor J2EE existente o en un Tomcat ya desplegado se deber√° escoger WAR. Java: Se selecciona la versi√≥n de Java a usar. En este caso, se recomienda usar la versi√≥n de Java m√°s antigua para garantizar la compatibilidad con otras librer√≠as o proyectos que se quieran incluir, as√≠ ser√° m√°s probable encontrar documentaci√≥n existente que siga siendo v√°lida. Reduce el riesgo de toparse con funcionalidades no muy maduras. Dependencies: Buscador de dependencias con los starters de Spring boot disponibles. Las dependencias m√°s habituales son: Spring Web se deber√° escoger cuando se desee hacer una aplicaci√≥n web o microservicios, siempre que se requiera una comunicaci√≥n http y por tanto el uso de Spring MVC. Thymeleaf Incorpora el motor de plantillas para HTML din√°mico, sucesor de los anteriores JSP (Java Server Page). Spring Data JPA necesario para utilizar la capa est√°ndar de acceso a base de datos SQL denominada Java Persistence Api. Spring Security Permite incorporar controles de acceso en base a usuarios y roles sobre URLs de la aplicaci√≥n. Tambi√©n habilita el control de ejecuci√≥n de m√©todos de servicio en base a roles seg√∫n los est√°ndares J2EE. Lombok Aporta utilidades que facilitan la programaci√≥n como la creaci√≥n de @Getters y @Setters autom√°ticamente para las clases que forman parte del conjunto de mensajes. Flyway Librer√≠a que permite aplicar scripts de cambios de base de datos de manera controlada cuando arranca la aplicaci√≥n. Estos scripts se denominan migraciones y est√°n sujetos a un control de versiones para garantizar que se aplican en el orden correcto. Mysql/Postgresql Incluye el JAR que contiene el driver JDBC necesario para configurar la capa de JPA seg√∫n la base de datos a usar. Otras‚Ä¶ El asistente permite seleccionar entre m√°s de 50 dependencias e integraciones de herramientas open source dentro de los proyectos realizados con Spring. Una vez seleccionados los par√°metros que se quieren, haciendo click en el bot√≥n ¬´Generate-Ctrl+¬ª se descargar√° un archivo zip con el nombre del Artifact que contendr√° la carpeta con la estructura de la aplicaci√≥n lista para importar desde el IDE. Recursos generados por SpringBoot Initializr Para realizar la importaci√≥n, bastar√° con importar o abrir el fichero pom.xml que viene dentro del comprimido. Los editores crear√°n y configurar√°n el classpath y las librer√≠as que se indican en √©l para que est√©n disponibles para el programador. El contenido del fichero tendr√° la siguiente forma: . ‚îú‚îÄ‚îÄ HELP.md ‚îú‚îÄ‚îÄ mvnw ‚îú‚îÄ‚îÄ mvnw.cmd ‚îú‚îÄ‚îÄ pom.xml ‚îî‚îÄ‚îÄ src ‚îú‚îÄ‚îÄ main ‚îÇ   ‚îú‚îÄ‚îÄ java ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ org ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ eadp ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ spring ‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ SpringAppApplication.java ‚îÇ   ‚îî‚îÄ‚îÄ resources ‚îÇ       ‚îú‚îÄ‚îÄ application.properties ‚îÇ       ‚îú‚îÄ‚îÄ static ‚îÇ       ‚îî‚îÄ‚îÄ templates ‚îî‚îÄ‚îÄ test ‚îî‚îÄ‚îÄ java ‚îî‚îÄ‚îÄ org ‚îî‚îÄ‚îÄ eadp ‚îî‚îÄ‚îÄ spring ‚îî‚îÄ‚îÄ SpringAppApplicationTests.java De los ficheros incluidos, el m√°s importante es MyWebAppApplication.java que corresponde con el punto de entrada a la ejecuci√≥n del programa. Aqu√≠ es donde se aloja el m√©todo public static void main(String[] arg) que es el que inicializa toda la aplicaci√≥n de Spring Boot. Durante el arranque del framework, Spring revista el resto de directorios o paquetes que cuelgan de m√©todo main en b√∫squeda de clases marcadas con alguna anotaci√≥n que permite el registro de componentes como: @Service, @Component, @Repository y dem√°s anotaciones de Spring y de Spring MVC como @Controller o @RestController. F√≠jese que el paquete utilizado es el com.eadp.web, esta opci√≥n puede especificarse en el asistente Spring Initializr. El siguiente fichero m√°s importante es application.properties que es donde se aloja toda la configuraci√≥n de los componentes de Spring Boot, c√≥mo que encoding usar (utf-8), si debe usar cach√© en las plantillas, qu√© nombre y clave de acceso son los de por defecto, etc‚Ä¶ En el enlace de configuraciones y propiedades comunes de spring boot hay una referencia de todas las existentes y sus valores iniciales. El siguiente fichero es MyWebAppApplicationTests.java donde se aloja el primer test de ejemplo que genera Initializr por nosotros. Ah√≠, el usuario debe a√±adir los test que considere oportunos para aplicar en la medida de lo posible desarrollo orientado a test o TDD. Los otros directorios son static que es donde se alojan los recursos est√°ticos que la aplicaci√≥n debe servir sin procesar. Por ejemplo en esta carpeta se incluyen los ficheros CSS, Javascript, im√°genes o fuentes que se referencian desde el HTML. Si el fichero alojado en este directorio est√° en una sub-carpeta de static, como puede ser static/css/main.css. Spring Boot lo publicar√° autom√°ticamente en la url http://localhost:8080/css/main.css. As√≠ que no debe haber informaci√≥n sensible que cuelgue del directorio static porque entonces ser√° accesible abiertamente. Y por √∫ltimo la carpeta templates almacena los ficheros que permiten generar HTML din√°micamente con alg√∫n motor de plantillas soportado por Spring como Thymeleaf o Freemarker. C√≥mo a√±adir funcionalidad al proyecto El proyecto creado es muy simple, si tratamos de arrancar el m√©todo main de la clase MyWebAppApplication, veremos c√≥mo Spring inicializa toda la aplicaci√≥n y se pone a la escucha del puerto 8080, pero si dirigimos el navegador a esa URL no aparecer√° ning√∫n contenido. As√≠ que veamos c√≥mo podemos hacer para imprimir algunos datos mediante html din√°mico. Para que las siguientes l√≠neas sirvan debemos asegurarnos de haber escogido al menos las dependencias de Spring Web y Thymeleaf, dejando el resto de opciones como se indican en las l√≠neas superiores. Generamos el proyecto de nuevo, de no ser as√≠ y crearemos el primer controlador que permitir√° a√±adir c√≥digo Java y una plantilla Thymeleaf que generar√° los primeros documentos HTML din√°micos. Con el proyecto ya importado en el editor vamos a crear un primer controlador que ser√° el encargado de ejecutar c√≥digo Java dada una URL. En √©ste crearemos una variable que podr√° ser impresa en la plantilla mediante el traspaso del dato v√≠a el modelo. // contenido del fichero: src/main/java/org/eadp/spring/controller/MyController.java package org.eadp.spring; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import java.time.LocalDateTime; @Controller public class MyController { @GetMapping( / ) public String index(Model model) { model.addAttribute( tstamp , LocalDateTime.now()); return  index ; } } El controlador registra un m√©todo en ¬´/¬ª, la ra√≠z del sitio, de tal manera que cuando la aplicaci√≥n est√© arrancada y lista para escuchar peticiones http, normalmente por el puerto 8080, el m√©todo index ser√° ejecutado cuando se solicite la URL de inicio http://localhost:8080/. En ese momento, el m√©todo ser√° ejecutado a√±adiendo la hora actual a una variable con nombre tstamp que se guarda en model, objeto que se pasa a la vista, para que pueda construir el html din√°micamente. En este caso, mostrando la hora en la que se invoc√≥ ese m√©todo. Por otro lado, nada m√°s ejecutarse el m√©todo del controlador, Spring pasar√° el control a la vista con nombre index correspondiente al fichero index.html de la carpeta de templates, tal y como indica el return ¬´index¬ª, en el que no hace falta indicar la extensi√≥n .html. Para completar el c√≠rculo y ver los resultado necesitamos crear la vista index.html con el siguiente contenido: // contenido del fichero: src/main/resources/templates/index.html <!doctype html> <html lang= es  xmlns:th= http://www.thymeleaf.org > <head> <title>My First Spring Boot App</title> <style> html { font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif; color: #404040; background-color: #d3d3d3; } body{ padding: 5em; } </style> </head> <body> <h1>Hello from Spring Boot!</h1> <p> This page is served at <span th:text= __$_{__tstamp} ></span> </p> </body> </html> Y listos! Ahora ya podemos arrancar de nuevo la aplicaci√≥n y hacer la petici√≥n a http://localhost:8080/. Dando como resultado la impresi√≥n de la hora en la que se ejecut√≥ el controlador."
    },

    {
        "id": 73,
        "autor": "Natalia Roales Gonz√°lez",
        "pagina": "adictosaltrabajo",
        "fecha": "21/12/2016",
        "titulo": "Aplicaciones web con Spring Boot capa a capa",
        "link": "https://www.adictosaltrabajo.com/2016/12/22/aplicaciones-web-con-spring-boot-capa-a-capa/",
        "contenido": "En este tutorial vamos a aprender a desarrollar una aplicaci√≥n web con los recursos que nos brinda Spring Web. √çndice de contenidos 1. Introducci√≥n 2. Entorno 3. Creando el proyecto 4. Definiendo la clase principal 5. Empaquetando el proyecto y arrancando el servidor 6. Desarrollando la capa controlador 7. Desarrollando la capa de servicio 8. Desarrollando la capa de repositorio 9. Desarrollando la capa de acceso a datos 10. Todo listo, ¬°invoquemos al servicio! 11. Conclusiones 12. Referencias 1. Introducci√≥n Muchos de vosotros habr√©is o√≠do hablar de Spring Boot. Para los m√°s despitadillos, os dir√© que se trata de un proyecto creado a partir de Spring, el cual nos permite desarrollar y arrancar de forma muy r√°pida aplicaciones basadas en Spring. Hoy os voy a demostrar que realmente esto es as√≠, y para ello vamos a desarrollar una aplicaci√≥n web muy sencillita, paso a paso. La aplicaci√≥n consistir√° en un peque√±o servicio que nos muestra un mensaje de bienvenida al ser invocado. Bueno, ¬°pues comencemos a programar! üòÄ 2. Entorno Este tutorial ha sido realizado en un entorno con las siguientes caracter√≠sticas: Hardware: MacBook Pro Retina 15‚Äô (2,5 GHz Intel Core i7, 16 GB DDR3) Sistema Operativo: OS X El Capitan 10.11.5 Entorno de desarrollo: IntelliJ IDEA Ultimate 2016.1 Java 1.8 3. Creando el proyecto En primer lugar, creamos un proyecto maven. Para indicar que queremos utilizar Spring Web con Spring Boot, a√±adimos lo siguiente al fichero pom.xml: XHTML <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.4.1.RELEASE</version> </parent> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> 1 2 3 4 5 6 7 8 9 10 11 12 <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.4.1.RELEASE</version> </parent> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> De este modo, el proyecto que acabamos de crear extiende del proyecto padre spring-boot-starter-parent, e incluye las dependencias agrupadas en el starter spring-boot-starter-web. Un starter es un conjunto de dependencias que nos ayudan a cubrir las necesidades de un tipo de proyecto concreto. Por ejemplo, el starter que estamos utilizando sirve para cubrir las necesidades de un proyecto web. M√°s adelante utilizaremos otros starters, entre ellos el que nos ayuda a integrar MyBatis en la aplicaci√≥n. Podemos definir en qu√© versi√≥n de Java desarrollaremos nuestra aplicaci√≥n, a√±adiendo lo siguiente al fichero pom.xml: XHTML <properties> <java.version>1.8</java.version> </properties> 1 2 3 <properties> <java.version>1.8</java.version> </properties> En este caso, la versi√≥n que vamos a emplear ser√° la 1.8. Otra cosa importante es la definici√≥n de una buena estructura de paquetes. Un buen ejemplo puede ser el siguiente: paqueteria Esta estructura de paquetes agrupa las clases en cuatro paquetes principales: mapper para la capa de acceso a datos, repository para la capa de repositorio, service para la capa de servicio, y web para la capa controlador. No hay que seguir este ejemplo al pie de la letra ni mucho menos, es m√°s, puede que la estructura de paquetes de otros proyectos sea muy distinta pero totalmente v√°lida. Lo que pretendo mostraros es que debe existir una estructura de paquetes ordenada para que la aplicaci√≥n sea mantenible y para que la responsabilidad de las clases quede bien clara. 4. Definiendo la clase principal Toda aplicaci√≥n en java debe contener una clase principal con un m√©todo main. Dicho m√©todo, en caso de implementar una aplicaci√≥n con Spring, deber√° llamar al m√©todo run de la clase SpringApplication. A continuaci√≥n, definimos de una forma muy f√°cil la clase principal de nuestra aplicaci√≥n. Java @Configuration @EnableAutoConfiguration @ComponentScan public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 1 2 3 4 5 6 7 8 9 @Configuration @EnableAutoConfiguration @ComponentScan public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } La etiqueta @Configuration, indica que la clase en la que se encuentra contiene la configuraci√≥n principal del proyecto. La anotaci√≥n @EnableAutoConfiguration indica que se aplicar√° la configuraci√≥n autom√°tica del starter que hemos utilizado. Solo debe a√±adirse en un sitio, y es muy frecuente situarla en la clase main. En tercer lugar, la etiqueta @ComponentScan, ayuda a localizar elementos etiquetados con otras anotaciones cuando sean necesarios. Para no llenar nuestra clase de anotaciones, podemos sustituir las etiquetas @Configuration, @EnableAutoConfiguration y @ComponentScan por @SpringBootApplication, que engloba al resto. Java @SpringBootApplication public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 1 2 3 4 5 6 7 @SpringBootApplication public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 5. Empaquetando el proyecto y arrancando el servidor Tras haber definido la clase principal del proyecto, podemos proceder a empaquetarlo y arrancar el servidor con nuestra aplicaci√≥n. Si hemos a√±adido correctamente las dependencias al fichero pom.xml no deber√≠a haber ning√∫n problema de empaquetado, y maven no nos devolver√≠a ning√∫n error en tiempo de compilaci√≥n. Para salir de dudas, vamos a ejecutar el siguiente comando en el directorio ra√≠z del proyecto: Shell $ mvn clean package 1 $ mvn clean package Si todo va bien, tras ejecutar esta instrucci√≥n, se generar√°n los ficheros .class a partir de las clases .java y se empaquetar√° el proyecto en un fichero .jar. Podemos ver tambi√©n qu√© dependencias han sido incluidas en el proyecto, es decir, qu√© dependencias engloban tanto los starters a√±adidos como el proyecto padre. Esto es posible con el siguiente comando: Shell $ mvn dependency:tree 1 $ mvn dependency:tree Por otro lado, los proyectos de tipo Spring Boot integran un servidor de aplicaciones, por lo que arrancar una aplicaci√≥n Spring Boot es muy f√°cil. En el directorio ra√≠z del proyecto ejecutamos el siguiente comando: Shell $ mvn spring-boot:run 1 $ mvn spring-boot:run Si no se produce ning√∫n error en tiempo de ejecuci√≥n, el servidor estar√≠a levantado y listo para recibir peticiones. 6. Desarrollando la capa controlador Definamos ahora el comportamiento de la aplicaci√≥n implementando el resto de clases. Vamos a comenzar por la capa de m√°s alto nivel, la de los controladores, donde expondremos los servicios de la aplicaci√≥n. El servicio que vamos a crear tendr√° un comportamiento muy simple. Recuperar√° de base de datos un mensaje de bienvenida cuyo contenido variar√° en funci√≥n del idioma del usuario, recibiendo como par√°metro el mismo nombre de usuario. El comportamiento del controlador ser√° a√∫n m√°s sencillo, ya que lo √∫nico que har√° ser√° llamar a la capa de servicio y devolver lo que √©sta nos retorne. Comenzaremos por el desarrollo del test que valide el controlador. Nuestro controlador se llamar√° SampleController, as√≠ que el test del controlador se llamar√° SampleControllerTest y estar√° en el mismo paquete que SampleController pero en el directorio test. Necesitaremos incluir una serie de dependencias englobadas en el starter spring-boot-starter-test: XHTML <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> 1 2 3 4 5 <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> El contenido de la clase de test ser√° el siguiente: Java public class SampleControllerTest { private SampleController sampleController; private SampleService sampleService; @Before public void init(){ sampleService = mock(SampleService.class); sampleController = new SampleController(sampleService); } @Test public void sampleControllerShouldCallService() { String userName =  nroales ; String expectedMessage =  message ; when(sampleService.welcome(userName)).thenReturn(expectedMessage); String message = sampleController.welcome(userName); verify(sampleService).welcome(userName); assertTrue(message.equals(expectedMessage)); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class SampleControllerTest { private SampleController sampleController; private SampleService sampleService; @Before public void init(){ sampleService = mock(SampleService.class); sampleController = new SampleController(sampleService); } @Test public void sampleControllerShouldCallService() { String userName =  nroales ; String expectedMessage =  message ; when(sampleService.welcome(userName)).thenReturn(expectedMessage); String message = sampleController.welcome(userName); verify(sampleService).welcome(userName); assertTrue(message.equals(expectedMessage)); } } Hemos declarado un atributo de la clase SampleService, ya que lo que vamos a probar es que el controlador invoque a la capa de servicio y que devuelva lo mismo, as√≠ que debemos crear SampleService para que el test compile. Adem√°s, lo mockeamos para simular su comportamiento, pues el objetivo de este test no es probar la capa de servicio. Vamos a hacer que el test pase de rojo a verde con la siguiente implementaci√≥n de SampleController: Java @Controller public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) @ResponseBody public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Controller public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) @ResponseBody public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } En el fragmento de c√≥digo anterior aparecen algunas anotaciones. Vamos a ver qu√© significa cada una de ellas: @Controller: Con esta anotaci√≥n Spring podr√° detectar la clase SampleController cuando realice el escaneo de componentes. @Autowired: A trav√©s de esta anotaci√≥n Spring ser√° capaz de llevar a cabo la inyecci√≥n de dependencias sobre el atributo marcado. En este caso, estamos inyectando la capa de servicio, y por eso no tenemos que instanciarla. @RequestMapping: Con esta anotaci√≥n especificamos la ruta desde la que escuchar√° el servicio, y qu√© m√©todo le corresponde. @ResponseBody: Con ella definimos lo que ser√° el cuerpo de la respuesta del servicio. @PathVariable: Sirve para indicar con qu√© variable de la url se relaciona el par√°metro sobre el que se est√© usando la anotaci√≥n. Podemos tambi√©n utilizar la etiqueta @RestController en lugar de @Controller, que sustituye al uso de @Controller + @ResponseBody, quedando el controlador de la siguiente forma: Java @RestController public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 7. Desarrollando la capa de servicio Aunque a partir de este punto no aparezcan las clases de test, no quiere decir que no sean necesarias para completar el desarrollo que estamos realizando. Sin embargo, he decidido omitirlas para que el tutorial no se extienda demasiado, pero siempre es recomendable respaldar nuestra aplicaci√≥n con una bater√≠a de pruebas (y m√°s a√∫n hacer TDD). Vamos implementar la capa de servicio. Un m√©todo de servicio definir√° una operaci√≥n a nivel de negocio, por ejemplo, dar un mensaje de bienvenida. Los m√©todos de servicio estar√°n formados por otras operaciones m√°s peque√±as, las cuales estar√°n definidas en la capa de repositorio. El mapper, por √∫ltimo, contendr√° las operaciones de acceso a datos que ser√°n invocadas por el repositorio. En este caso, el servicio realizar√° una sola llamada al repositorio, pas√°ndole como par√°metro el nombre de usuario. Lo llamaremos SampleService. Java @Service public class SampleService { @Autowired private SampleRepository sampleRepository; public SampleService(SampleRepository sampleRepository) { this.sampleRepository = sampleRepository; } public String welcome(String userName) { return sampleRepository.getMessageByUser(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service public class SampleService { @Autowired private SampleRepository sampleRepository; public SampleService(SampleRepository sampleRepository) { this.sampleRepository = sampleRepository; } public String welcome(String userName) { return sampleRepository.getMessageByUser(userName); } } La anotaci√≥n @Service funciona de forma parecida a la anotaci√≥n @Controller, ya que permite que Spring reconozca a SampleService como servicio al escanear los componentes de la aplicaci√≥n. 8. Desarrollando la capa de repositorio Ahora tenemos que desarrollar el repositorio al que ha invocado el servidor. Por tanto, crearemos la clase SampleRepository e implementaremos el m√©todo getMessageByUser. Java @Repository public class SampleRepository { @Autowired private SampleMapper sampleMapper; public SampleRepository(SampleMapper sampleMapper) { this.sampleMapper = sampleMapper; } public String getMessageByUser(String userName) { String language = sampleMapper.getLanguageByUser(userName); return sampleMapper.getMessageByLanguage(language); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Repository public class SampleRepository { @Autowired private SampleMapper sampleMapper; public SampleRepository(SampleMapper sampleMapper) { this.sampleMapper = sampleMapper; } public String getMessageByUser(String userName) { String language = sampleMapper.getLanguageByUser(userName); return sampleMapper.getMessageByLanguage(language); } } Para recuperar el mensaje de bienvenida dado el nombre de usuario tendremos dos m√©todos en la capa de acceso a datos, siendo uno para recuperar el idioma dado el usuario, y otro para recuperar el mensaje dado el idioma. Desde el repositorio llamamos a los dos. 9. Desarrollando la capa de acceso a datos Ya solo nos queda implementar la capa de acceso a datos. En esta capa es en donde se definen las consultas a base de datos, a trav√©s de interfaces denominadas mappers. Vamos a crear el mapper con los dos m√©todos invocados en el repositorio, que son getLanguageByUser y getMessageByLanguage. Java @Mapper public interface SampleMapper { String getLanguageByUser(@Param( userName ) String userName); String getMessageByLanguage(@Param( language ) String language); } 1 2 3 4 5 6 7 @Mapper public interface SampleMapper { String getLanguageByUser(@Param( userName ) String userName); String getMessageByLanguage(@Param( language ) String language); } Utilizamos la etiqueta @Mapper para indicar que una interfaz es un mapper, y as√≠ Spring pueda localizarla. Tambi√©n utilizamos la etiqueta @Param para que MyBatis identifique los campos a la hora de procesar las consultas. Para poder trabajar con MyBatis debemos incluir algunas dependencias, agrupadas dentro del starter mybatis-spring-boot-starter: XHTML <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.1.1</version> </dependency> 1 2 3 4 5 <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.1.1</version> </dependency> Tambi√©n debemos a√±adir el conector correspondiente a la base de datos que vayamos a utilizar. Podemos hacerlo incluyendo su dependencia maven en el pom.xml. En caso de utilizar una base de datos MySQL a√±adimos la siguiente dependencia: XHTML <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.6</version> </dependency> 1 2 3 4 5 <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.6</version> </dependency> Y en el fichero application.properties, localizado en el directorio resources, a√±adiremos la informaci√≥n de nuestra base de datos, siendo testdb el nombre de la base: Shell spring.datasource.url=jdbc:mysql://localhost:3306/testdb spring.datasource.username=user spring.datasource.password=pass spring.datasource.driver-class-name=com.mysql.jdbc.Driver 1 2 3 4 spring.datasource.url=jdbc:mysql://localhost:3306/testdb spring.datasource.username=user spring.datasource.password=pass spring.datasource.driver-class-name=com.mysql.jdbc.Driver Una vez tenemos todo lo necesario para trabajar con MyBatis, definimos cada uno de los dos m√©todos del mapper. Dentro de la carpeta resources, creamos una estructura de directorios id√©ntica a la estructura de paquetes donde se encuentra SampleMapper.java, y creamos el fichero SampleMapper.xml. Tendr√° el siguiente contenido: XHTML <mapper namespace= com.autentia.demo.mapper.SampleMapper > <select id= getLanguageByUser  resultType= String > SELECT USL_LANGUAGE FROM USER_LANGUAGE WHERE USL_USER = #{userName} </select> <select id= getMessageByLanguage  resultType= String > SELECT MSG_DESCRIPTION FROM MESSAGES WHERE MSG_MESSAGE =  welcome  AND MSG_LANGUAGE = #{language} </select> </mapper> 1 2 3 4 5 6 7 8 9 10 11 <mapper namespace= com.autentia.demo.mapper.SampleMapper > <select id= getLanguageByUser  resultType= String > SELECT USL_LANGUAGE FROM USER_LANGUAGE WHERE USL_USER = #{userName} </select> <select id= getMessageByLanguage  resultType= String > SELECT MSG_DESCRIPTION FROM MESSAGES WHERE MSG_MESSAGE =  welcome  AND MSG_LANGUAGE = #{language} </select> </mapper> La primera query recupera de la tabla USER_LANGUAGE el campo USL_LANGUAGE dado el valor del campo USL_USER, obteni√©ndose el idioma asociado al usuario userName. La segunda query, recupera el campo MSG_DESCRIPTION de la tabla MESSAGES dado el valor del campo MSG_LANGUAGE para MSG_MESSAGE igual a ‚Äúwelcome‚Äù, obteni√©ndose el mensaje de bienvenida en el idioma del usuario. Aunque parezca obvio, vuestras consultas deber√°n concordar con el dise√±o de la base de datos. Lo que aparece dentro de #{userName} y #{language} son los identificadores que hemos designado a los par√°metros de entrada con las anotaciones @Param. 10. Todo listo, ¬°invoquemos al servicio! Es el momento de la verdad‚Ä¶ ¬°Vamos a invocar a nuestro servicio! Ya sab√©is, para ello levantamos el servidor con el siguiente comando: Shell $ mvn spring-boot:run 1 $ mvn spring-boot:run Una vez haya arrancado el servidor procedemos a invocar al servicio, y para ello accedemos a la url http://localhost:8080/welcome/userName. Tenemos que sustituir userName por el nombre de usuario que hayamos guardado en nuestra base de datos. Como respuesta, veremos en el navegador el mensaje de bienvenida que hayamos definido. 11. Conclusiones Gracias a Spring Boot nos acabamos de marcar en un momento una aplicaci√≥n totalmente funcional. Hemos comenzado creando un proyecto maven e indicando en el pom.xml que el proyecto es de tipo Spring Boot, heredando de spring-boot-starter-parent el proyecto creado. Despu√©s hemos elegido el starter que m√°s se ajusta a las necesidades de nuestro tipo de proyecto, en este caso spring-boot-starter-web, y lo hemos a√±adido como dependencia. Luego hemos creado la clase principal de la aplicaci√≥n, implementando posteriormente las clases e interfaces que definen su comportamiento, y por √∫ltimo hemos arrancado el servidor. El tiempo que hemos perdido en la configuraci√≥n del proyecto es m√≠nimo, y solo nos hemos tenido que preocupar de implementar los m√©todos que definan el comportamiento de los servicios. Tampoco hemos perdido tiempo en montar el servidor de aplicaciones, ya que Spring Boot cuenta con un Tomcat embebido. Ya no ten√©is excusa para no desarrollar proyectos web en Java. ¬øHab√©is visto qu√© f√°cil y r√°pido es tener una aplicaci√≥n Java web funcional desde cero? Os animo a que lo prob√©is"
    },

    {
        "id": 74,
        "autor": "Rosa",
        "pagina": "rosamarfil",
        "fecha": "16/08/2019",
        "titulo": "Crear una aplicaci√≥n web con Spring Boot",
        "link": "https://rosamarfil.es/tutoriales/programacion/spring-boot-api-rest-2-crear-una-aplicacion-web-con-spring-boot/",
        "contenido": "En este tutorial aprender√°s a instalar Spring Boot y crear una aplicaci√≥n web con Spring Boot desde cero. El proyecto estar√° basado en servicios web REST (o com√∫nmente microservicios). ¬øQu√© es Spring Boot? Es un framework o herramienta que ayuda a construir aplicaciones basadas principalmente en microservicios de una forma m√°s √°gil. Instalar Spring Boot Existen dos maneras: Instalado Spring Boot Starter (que es un Eclipse con Spring Boot integrado). Se puede descargar desde su p√°gina oficial: https://spring.io/tools. Accediendo a la p√°gina https://start.spring.io y generando el proyecto para descargarlo en tu PC. Instalando Spring Tools Suite en Eclipse (Se instala desde Eclipse, como un plugin). Yo, en este caso optar√© por la tercera opci√≥n e instalar√© Spring Tools Suite en Eclipse, con java JDK 8. Para ello: Abre Eclipse, dir√≠gete a Help -> Eclipse Marketplace‚Ä¶ Introduce ¬´sts¬ª en el cuadro de texto para realizar la b√∫squeda y presiona Enter. Visualiza la opci√≥n Spring Tools 4 ‚Äì for Spring Boot (aka Spring Tool Suite 4). Pulsa sobre el bot√≥n Install. install-spring-boot Instalar Spring Boot en Eclipse La instalaci√≥n tardar√° unos minutos y Eclipse te pedir√° que lo reinicies. Un vez reiniciado Eclipse observa que aparece un nuevo bot√≥n  (Boot Dashboard) en la barra de men√∫ superior. Crear proyecto Dir√≠gete a File -> New -> Project y elige Spring Boot -> Spring Boot Starter. Presiona Next. A continuaci√≥n, completa los datos para el proyecto y presiona Next: new-spring-boot-project Crear un proyecto Spring Boot A continuaci√≥n, activa las casillas Spring Web Services y Spring Web Starter. Pulsa Finish: spring-boot-dependencies-Crear aplicaci√≥n web con Spring Boot Seg√∫n las casillas que activemos, se crear√°n sus dependencias en el fichero pom.xml. Observa que no hay ning√∫n error a la hora de la creaci√≥n del proyecto. Prueba una ejecuci√≥n de la aplicaci√≥n (ejecutando el proyecto como Spring Boot App) y observando una salida por consola como la siguiente: Crear aplicaci√≥n web con Spring Boot Picar los servicios En mi caso he creado un servicio que devuelve una lista de usuarios. UserServiceRest.java En esta clase lo importante son las anotaciones que hemos a√±adido y de forma sencilla para que entend√°is que significa cada una os explico: @RestController -> Indica que ser√° una clase que va a publicar servicios REST. @RequestMapping(value= /users , method=RequestMethod.GET) -> se indica el nombre del m√©todo accesible desde el navegador. En este caso users. Y tambi√©n se indica el tipo de m√©todo, en este caso de tipo GET. C√≥digo de la clase UserServiceRest.java: package es.springboot.rosamarfil.services; import java.util.ArrayList; import java.util.List; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import es.springboot.rosamarfil.model.User; @RestController public class UserServiceRest { /** * Lista de ejemplo de usuarios */ private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; @RequestMapping(value= /users , method=RequestMethod.GET) public List<User>  getUsers(){ return listaUsuarios; } } User.java package es.springboot.rosamarfil.model; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } Probar servicio REST Despu√©s de picar el escueto c√≥digo, arranca tu aplicaci√≥n Spring Boot y muestra el resultado en el navegador introduciendo en la barra de direcciones: http://localhost:8080/users El resultado ser√°: Crear aplicaci√≥n web con Spring Boot Como ves, con este peque√±o tutorial has aprendido a crear una aplicaci√≥n web con Spring Boot y publicar en local un servicio REST. Evidentemente, un proyecto real tendr√≠a muchas m√°s capas y ser√≠a m√°s complejo, pero el concepto de Web Services REST con Spring Boot es el que te he explicado. Espero que te haya sido de utilidad. Gracias por leerme y comparte si te ha gustado. Nos vemos en el pr√≥ximo tutorial."
    },

    {
        "id": 75,
        "autor": "Iv√°n Salas",
        "pagina": "programandoointentandolo",
        "fecha": "25/10/2018",
        "titulo": "TUTORIAL SPRING BOOT ‚Äì CREANDO NUESTRA PRIMERA APLICACI√ìN",
        "link": "https://programandoointentandolo.com/2018/10/tutorial-spring-boot-creando-nuestra-primera-aplicacion.html",
        "contenido": "HomeJavaSpringSpring BootTutorial Spring Boot ‚Äì Creando nuestra primera aplicaci√≥n TUTORIAL SPRING BOOT ‚Äì CREANDO NUESTRA PRIMERA APLICACI√ìNSpring Boot  25 octubre, 2018  0  Iv√°n Salas reset css En este tutorial vamos a ver lo r√°pido y sencillo que es crear un proyecto utilizando Spring Boot, ya que no nos vamos a tener que preocupar de gestionar las dependencias que necesitaremos (al menos las m√°s comunes), ni hacer las t√≠picas configuraciones iniciales que hacemos al empezar un proyecto de Spring y ni tan siquiera nos vamos a tener que preocupar de configurar un servidor para correr nuestra aplicaci√≥n. Vamos que nos permite centrarnos en el desarrollo gracias a todas las cosas que Spring Boot hace por nosotros y que nos van a permitir crear y desplegar nuestras aplicaciones de una forma muy sencilla. El proyecto que vamos a crear en este tutorial lo voy a usar de base para ir entrando m√°s en profundidad en posteriores post tanto en Spring Boot como en otros temas relacionados de forma que la idea es tener al final una aplicaci√≥n sencilla pero que nos permita tener una visi√≥n completa de Spring, por eso en este post nos vamos a centrar en c√≥mo crear nuestra primera aplicaci√≥n con Spring Boot, analizar su estructura, explicar los puntos b√°sicos y arrancarla, ni m√°s ni menos. 1. CREAR UN PROYECTO CON SPRING BOOT Vamos a ver c√≥mo crear un proyecto con Spring Boot desde 0 usando el String Tool Suite que es un entorno de desarrollo basado en eclipse con todo lo que necesitamos para hacer desarrollos con Spring o bien podemos usar un eclipse ¬´normal¬ª y instalarle el Spring Tools desde el Eclipse Marketplace, podr√≠amos usar el IDE que m√°s nos guste pero alguno hab√≠a que elegir para hacer el tutorial‚Ä¶ Para crear un proyecto nuevo proyecto de Spring nos vamos a File/New/Spring Starter Proyect, si no aparece elegimos Proyect‚Ä¶ y lo buscamos dentro de Spring Boot y siguiente. Crear nuevo proyecto con Spring Boot En esta primera pantalla podemos decidir si queremos usar maven o gradle, la versi√≥n de java que queremos usar, la forma en la que queremos que se empaquete el proyecto, el lenguaje de programaci√≥n que vamos a usar y los t√≠picos datos del proyecto, nombre, package, ‚Ä¶ Ponemos los datos del proyecto y nos quedamos con maven, con la √∫ltima versi√≥n de la jdk, nos vamos a quedar tambi√©n con el jar porque no necesitamos otra cosa y como lenguaje pues elegimos Java aunque quiz√°s alg√∫n d√≠a me anime a hacerlo tambi√©n con Kotlin. Pulsamos en Next > para que nos aparezca la pantalla para seleccionar las dependencias que sabemos que va a utilizar nuestro proyecto. Seleccionar dependencias nuevo proyecto Spring Boot Las buscamos y las seleccionamos y cuando tengamos todas las que necesitamos le damos a Finish, si se nos olvida alguna no pasa nada, siempre podremos incluirlas a mano en el pom.xml pero desde aqu√≠ es m√°s simple porque con unos clics ya tenemos configuradas todas las dependencias sin necesidad de estar copi√°ndolas de otros proyectos que tengamos o peor de estar busc√°ndolas una a una. Y as√≠ de f√°cil tenemos nuestro proyecto listo para empezar. 2. ESTRUCTURA DEL PROYECTO La estructura del proyecto va a depender de las elecciones que hici√©semos a la hora de crear el proyecto, por ejemplo, si hubi√©semos elegido empaquetarlo como .war tendr√≠amos la carpeta webapp y si adem√°s quit√°semos Thymeleaf y lo seguimos dejando como un proyecto web tendr√≠amos una clase adicional (ServletInitializer), pero b√°sicamente podemos decir que la estructura del proyecto ser√° la t√≠pica de un proyecto de Spring. Estructura de proyecto Spring Boot Dentro de nuestro package principal tenemos una clase con el nombre del proyecto + Application que es la que nos proporciona Spring Boot para arrancar nuestra aplicaci√≥n. package com.programandoointentandolo.tsb; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class TutorialSpringBootApplication { public static void main(String[] args) { SpringApplication.run(TutorialSpringBootApplication.class, args); } } Como vemos esta clase es muy sencilla ya que solo contiene el m√©todo main dentro del que se llama a SpringApplication.run() y una anotaci√≥n @SpringBootApplication que es equivalente a usar las anotaciones @Configuration, @EnableAutoConfiguration y @ComponentScan con sus configuraciones por defecto. @Configuration: Esta anotaci√≥n se utiliza para indicar que la clase puede contener beans que ser√°n registrados al iniciar la aplicaci√≥n. @EnableAutoConfiguration: Con esta anotaci√≥n se le indica a Spring que se encargue de configurar todas las dependencias que tengamos en el proyecto. @ComponentScan: Permite que se escaneen todos los @Component que se encuentre dentro del paquete en el que se define, se puede configurar para que busque en los paquetes que queramos. El siguiente archivo que vemos en el proyecto es el application.properties que es el archivo que utilizaremos para configurar nuestra aplicaci√≥n, por lo tanto aqu√≠ es donde vamos a configurar nuestra conexi√≥n de base de datos y el resto de configuraciones que necesitemos, porque aunque Spring Boot nos evita tener que indicar todas las t√≠picas configuraciones en las que solo nos limitar√≠amos a dejar los valores por defecto siempre existe la posibilidad de que necesitemos cambiarlas, o simplemente como en el caso de las referentes a la base de datos que no tengamos m√°s remedio que indicarlas manualmente. En este enlace de la documentaci√≥n pues revisar las propiedades m√°s comunes. Para nuestro ejemplo vamos a usar una base de datos MySql y como durante el tutorial es muy probable que nuestras clases cambien y nos obliguen a cambiar nuestro modelo de BD vamos a dejar que Spring Boot nos cree las tablas a partir de nuestras clases cuando arranquemos la aplicaci√≥n y que las borre cuando la paremos para poder centrarnos en lo que estamos haciendo y no tener que preocuparnos por dejar datos inconsistentes. Por lo que nuestro application.properties ser√° el siguiente ya que la BD se va a llamar pruebas, va a estar en localhost:8889 y tanto el usuario como la password van a ser root. aplicacion.nombre=Tutorial Spring Boot server.port=9876 spring.datasource.url=jdbc:mysql://localhost:8889/pruebas?useSSL=false spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect spring.jpa.hibernate.ddl-auto=create-drop logging.level.org.hibernate.SQL=debug Esas 3 propiedades son las que es posible que tengas que cambiar para poder usar tu BD, en cuanto al resto he puesto una propiedad inventada aplicacion.nombre para que se vea que tambi√©n es posible indicar nuestras propias variables de configuraci√≥n, con server.port podemos indicar el puerto en el que se arrancar√° la aplicaci√≥n por si no nos gusta el puerto por defecto, luego tenemos las propiedades referentes a la conexi√≥n de BD y la que hace nuestra base de datos se limpie con cada ejecuci√≥n spring.jpa.hibernate.ddl-auto=create-drop. Los archivos .properties son sencillos sobre todo cuando son peque√±os pero si crecen un poco y se van metiendo las propiedades desordenadas pueden ser dificiles de leer, por eso vamos a sustituir el application.properties que Spring Boot nos ha creado por un application.yml porque Spring Boot soporta tambi√©n el formato YAML perfectamente y el resultado es m√°s legible. A continuaci√≥n tenemos el .yml correspondiente al application.properties anterior. aplicacion: nombre: Tutorial Spring Boot server: port: 9876 spring: datasource: url: jdbc:mysql://localhost:8889/pruebas?useSSL=false username: root password: root driver-class-name: com.mysql.jdbc.Driver jpa: database-platform: org.hibernate.dialect.MySQL57Dialect hibernate: ddl-auto: create-drop logging: level: org: hibernate: SQL: debug Comparando uno y otro vemos que las propiedades son las mismas y lo que cambia es su representaci√≥n, mientras que en el .yml se sigue una estructura de √°rbol en el .properties cada propiedad contiene toda su ruta completa, y si nos fijamos vemos que el .yml lo que hace es que sustituye el ¬´.¬ª de separaci√≥n del .properties por ¬´:¬ª y comienza una nueva rama y as√≠ sucesivamente hasta que llega al nombre de la propiedad donde ya si que indica su valor. A Spring Boot le da igual que usemos uno u otro formato y no vamos a tener que hacer ning√∫n tipo de configuraci√≥n adicional para que use el application.yml, en cualquier caso lo que har√° cuando vaya a arrancar la aplicaci√≥n ser√° leer nuestro application.yml o application.properties para inyectar los valores de las propiedades que definamos en las clases de configuraci√≥n correspondientes para que se arranque correctamente configurada. El √∫ltimo archivo que nos queda por ver es el test que nos crea que como es natural esta vac√≠o‚Ä¶ pero ya vemos que tiene 2 anotaciones, @RunWith(SpringRunner.class) para que el tets use el runner de Spring y @SpringBootTest que lo que hace es buscar la clase anotada con @SpringBootApplication y usarla para cargar el contexto completo de la aplicaci√≥n para hacer el test por lo que por lo general no vamos a usarla ya que normalmente no vamos a necesitar cargar toda la aplicaci√≥n a no ser que queramos hacer una prueba completa de todas las capas de muestra aplicaci√≥n. package com.programandoointentandolo.tsb; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class TutorialSpringBootApplicationTests { @Test public void contextLoads() { } } Pero como no todo puede ser perfecto si estamos usando en nuestro proyecto una jdk posterior a la 8 como en nuestro caso que estamos usando la 10 e intentamos ejecutar el test nos va a saltar una excepci√≥n, para solucionarlo solo tenemos que a√±adir una demencia al pom.xml, porque esta librer√≠a ya no est√° incluida dentro de la jdk, bueno en realidad si lo sigue estando hasta la pr√≥xima versi√≥n pero para que nos funcione tendr√≠amos que a√±adir el comando ‚Äìadd-modules java.xml.bind pero no es una soluci√≥n muy limpia y menos sabiendo que con la siguiente versi√≥n ya no nos va a funcionar. <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency> 3. ARRANCANDO NUESTRO EJEMPLO CON SPRING BOOT Una vez que ya tenemos el proyecto creado y hemos echado un vistazo a lo que nos vamos a encontrar los proyectos de Spring Boot ya estamos listos para crear un proyecto sencillo y probar nuestra primera aplicaci√≥n usando Spring Boot. Para no alargar esto innecesariamente no voy a incluir aqu√≠ el c√≥digo de los controllers, services, ‚Ä¶ ya que no es el prop√≥sito de este post y ya lo iremos viendo y desarrollando m√°s en profundidad de forma separada para que sea m√°s f√°cil de seguir. Bueno, pues vamos a ver como probar nuestra aplicaci√≥n, para arrancarla desde nuestro IDE podemos hacer click derecho sobre nuestro proyecto y despu√©s elegimos Run As y Spring Boot App. Arrancar aplicacion Spring Boot Tambi√©n podemos hacerlo desde el Boot Dashboard, que es una vista muy similar a Servers pero en este caso para las aplicaciones de Spring Boot Vista Boot Dashboard Abrimos la url en nuestro navegador y voila, ya tenemos nuestra aplicaci√≥n funcionando. Aplicacion Spring Boot + Thymeleaf + Bootstrap Desplegar nuestra aplicaci√≥n desde el STS es f√°cil, pero ¬øy desplegarla sin √©l? pues la verdad es que es incre√≠blemente f√°cil, solo tenemos que coger el jar que se habr√° generado en la carpeta target del proyecto y ejecutarlo con java -jar tutorial-spring-boot-0.0.1-SNAPSHOT.jar y aplicaci√≥n desplegada. Arrancando aplicacion Spring Boot desde la consola El c√≥digo completo del de este ejemplo esta en mi repositorio de github tutorial-spring-boot pero como el proyecto va a ir evolucionando a medida que vayamos viendo m√°s cosas puede que el c√≥digo no sea exactamente el mismo, pero para eso con cada nuevo post creare una release para que se pueda consultar como se encontraba el proyecto en ese momento y sea sencillo encontrar el estado correspondiente o para descargar directamente el c√≥digo correspondiente al post, el enlace correspondiente a esta release esta aqu√≠."
    },

    {
        "id": 76,
        "autor": "Acodigo",
        "pagina": "acodigo",
        "fecha": "01/04/2017",
        "titulo": "Spring Boot : Crear una Aplicaci√≥n Web",
        "link": "http://acodigo.blogspot.com/2017/04/spring-boot-crear-una-aplicacion-web.html",
        "contenido": "Spring Boot es un sub-proyecto Spring que simplifica y agiliza el proceso de creaci√≥n y desarrollo de aplicaciones web o de escritorio que utilicen el Framework Spring, la configuraci√≥n requerida para iniciar una aplicaci√≥n, de cualquier tipo, es m√≠nima y autom√°tica, Spring Boot se auto-configura analizando el classpath, adem√°s se elimina por completo la necesidad de tener archivos de configuraci√≥n XML, a pesar de ello el mecanismo de configuraci√≥n se mantiene bastante flexible, permiti√©ndonos personalizar la configuraci√≥n siempre que lo necesitemos. Nos es necesario tener alguna herramienta especial para crear nuestras aplicaciones, es posible utilizar la mayor√≠a de los IDEs como: NetBeans, Eclipse, IntelliJ, etc., tampoco es un requisito, pero si una buena opci√≥n utilizar una herramienta que nos facilite la administraci√≥n de las dependencias, en este serie de cursos usaremos Maven, debe ser la versi√≥n 3.2 o superior, obviamente tambi√©n requerimos el JDK la versi√≥n 1.6 en adelante. La manera mas sencilla de crear el proyecto inicial es dirigirse a la web: https://start.spring.io aqu√≠ seleccionar√°s el tipo de proyecto y le versi√≥n a utilizar, en la secci√≥n Project Metadata introduces la informaci√≥n correspondiente a tu proyecto, en la secci√≥n Dependencies deber√°s seleccionar las dependencias requeridas por tu proyecto, por ejemplo, para crear una aplicaci√≥n web agregamos Web, para acceso a datos JPA, puedes agregar todos los que sean necesarios, para finalizar presiona Generate Project para descargar el proyecto en un archivo comprimido ZIP. spring boot starter Presionando en el enlace que se encuentra en la parte inferior, que dice: ‚ÄúSwitch to the full version‚Äù, expandir√°s la ventana y se mostrar√° m√°s detalladamente las opciones de configuraci√≥n. Para abrir el proyecto con NetBeans 8 nos vamos al men√∫ File | Open Project... y localizamos la carpeta descomprimida del proyecto que acabamos de generar. Lo primero que debemos ver es el archivo pom.xml, lo abrimos, clic derecho sobre el proyecto y seleccionamos Open POM, veremos: <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.5.1.RELEASE</version> <relativePath/> <!-- lookup parent from repository --> </parent> Con esto heredamos las funcionalidades que nos permitir√°n administrar las dependencias de nuestro proyecto de una manera f√°cil. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-jdbc</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-thymeleaf</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> Para iniciar un proyecto de manera r√°pida contamos con los spring-boot-starter-*, estos nos permiten administrar un grupo de dependencias para un proyecto en especifico, por ejemplo: spring-boot-started-web contiene todas las dependencias necesarias para crear una aplicaci√≥n web MVC, spring-boot-starter-jdbc a√±ade las dependencias requeridas para realizar el acceso a datos con la API JDBC, spring-boot-starter-thymeleaf nos proporciona las dependencias que requiere el motor de plantillas Thymeleaf el cual usaremos para generar nuestras vistas, existen muchos m√°s, para todo tipo de proyectos. <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> Este plugin maven ser√° el encargado de empaquetar la aplicaci√≥n en el correspondiente archivo jar, este contiene todo los necesario para ejecutarse con el comando java -jar. spring boot tutorial Esta es la estructura de nuestro proyecto inicial, si vemos la clase IntroduccionApplication encontraremos el m√©todo main(String[] args) este es el punto de inicio de nuestra aplicaci√≥n, el m√©todo SpringApplication.run() es el encargado de iniciar la aplicaci√≥n, como argumento le indicamos la clase de configuraci√≥n y los argumentos de comandos, la clase de configuraci√≥n es la propia clase IntroduccionApplication la misma usa la anotaci√≥n @SpringBootApplication la cual es equivalente a utilizar las anotaciones: @Configuration, @EnableAutoConfiguration y @ComponentScan, estas anotaciones hacen lo siguiente: @Configuration: Indica que esta es una clase usada para configurar el contenedor Spring. @ComponentScan: Escanea los paquetes de nuestro proyecto en busca de los componentes que hayamos creado, ellos son,  las clases que utilizan las siguientes anotaciones: @Component, @Service, @Controller, @Repository. @EnableAutoConfiguration: Habilita la configuraci√≥n autom√°tica, esta herramienta analiza el classpath y el archivo application.properties para configurar nuestra aplicaci√≥n en base a las librer√≠as y valores de configuraci√≥n encontrados, por ejemplo: al encontrar el motor de bases de datos H2 la aplicaci√≥n se configura para utilizar este motor de datos, al encontrar Thymeleaf se crearan los beans necesarios para utilizar este motor de plantillas para generar las vistas de nuestra aplicaci√≥n web. Si lo deseamos podemos personalizar la aplicaci√≥n, para ello creamos una instancia de la clase SpringApplication y cambiamos el comportamiento deseado, por ejemplo, para deshabilitar el banner usamos Banner.Mode.OFF. import org.springframework.boot.Banner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class IntroduccionApplication { public static void main(String[] args) { SpringApplication app = new SpringApplication(IntroduccionApplication.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); } } En el constructor usamos indicamos la clase de configuraci√≥n, con el m√©todo app.run(args) iniciamos ala ejecuci√≥n de la aplicaci√≥n. Si deseas crea una aplicaci√≥n de escritorio no web debes desactivar los componente web, lo hacen del siguiente modo: app.setWebEnvironment(false); Nuestro primer controlador Crearemos nuestro primer controlador que llamaremos HomeController y lo ubicaremos en el paquete carmelo.spring.web es importante que los controladores se ubiquen en un paquete dentro del paquete que contiene la clase principal para que puedan ser detectados correctamente. package carmelo.springboot.web; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HelloController { @RequestMapping( /hello ) public String showHello(Model model){ model.addAttribute( saludo ,  Mi primera aplicacion web Spring Boot ); return  hello ; } } Este controlador responde a la petici√≥n HTTP localhost:8080/hello, a√±ade un atributo al modelo y retorna el nombre l√≥gico de la vista, hello, para m√°s detalles puedes ver: Spring MVC Controladores. Las vistas ser√° generadas con motor de plantillas Thymeleaf, seg√∫n nuestro controlador requerimos el archivo src/main/resources/templates/hello.html. <!DOCTYPE html> <html xmlns:th= http://www.thymeleaf.org > <head> <meta charset= UTF-8 /> <title>Spring Boot</title> </head> <body> <p th:text= ${saludo}  /> </body> </html> Tambi√©n vamos a a√±adir el archivo src/main/resources/static/index.html esta es la p√°gina que se muestra al agregar a localhost:8080/ de modo que en esta p√°gina solo a√±adiremos un enlace que nos lleve a localhost:8080/hello para ver nuestro controlador funcionando. <!DOCTYPE html> <html> <head> <title>Spring Boot</title> <meta charset= UTF-8 > </head> <body> <a href= /hello >Go Home</a> </body> </html> spring boot web Con esto tenemos nuestra primera aplicaci√≥n web Spring Boot lista. Si deseamos cambiar la ubicaci√≥n y la extensi√≥n de las plantillas editamos el archivo de propiedades application.properties para agregar las siguientes configuraciones: spring.thymeleaf.prefix=classpath:/views/ spring.thymeleaf.suffix=.html La primera indica las carpetas donde se encuentran las plantillas y la segunda la extensi√≥n de las mismas, con este ejemplo nuestra vista ser√° src/main/resources/views/hello.html. Ejecutar una aplicaci√≥n Spring Boot Spring Boot trabaja con servidor integrado, por defecto Apache Tomcat, para ejecutar nuestra aplicaci√≥n, en NetBeans IDE solo presionamos Run, si todo est√° correcto podemos ir al navegar y deberemos ver nuestra aplicaci√≥n. spring boot run Una aplicaci√≥n web Spring Boot puede ejecutarse desde la consola de comandos sin problemas, de la siguiente manera: java -jar target/introduccion-0.0.1-SNAPSHOT.jar image Nuestra aplicaci√≥n en el navegador: image Tambi√©n es posible ejecutar una aplicaci√≥n usando el Spring Boot Maven Plugin con el siguiente comando: mvn spring-boot:run Debemos tener presente que si una instancia de la aplicaci√≥n est√° ejecut√°ndose e intentamos iniciar otra instancia se producir√° un error ya que el puerto estar√° en uso, es posible cambiar el puerto mediante el archivo application.properties a√±adiendo server.port=8178 donde 8178 es el nuevo puerto. En este tutorial hemos visto la simplicidad que nos aporta Spring Boot a la hora de crear aplicaciones web MVC, no requerimos configuraci√≥n XML, el DispatcherServlet, ViewResolver, y todo los requerido para crear una aplicaci√≥n web fue configurado de manera autom√°tica, no fue necesario desplegar la aplicaci√≥n en un servidor externo, estos son algunos de los beneficios obtenidos al utilizar esta herramienta, en pr√≥ximos tutoriales veremos mas caracter√≠sticas interesantes."
    },

    {
        "id": 77,
        "autor": "Javadesde0",
        "pagina": "javadesde0",
        "fecha": "23/06/2019",
        "titulo": "Creando un proyecto de Spring Boot",
        "link": "https://javadesde0.com/creando-un-proyecto-de-spring-boot/",
        "contenido": "Para crear un proyecto de Spring, tenemos varias opciones. Las 2 m√°s populares son: Crear un proyecto desde Spring Boot Initializer la herramienta web que nos proporciona Pivotal. Crear el proyecto desde el IDE mediante al Command Line Tool (CLI), en nuestro caso el IDE elegido ser√° Spring Tool Suite 4. En mi opini√≥n, la m√°s sencilla es desde el propio Spring Tool Suite 4, ya que nos carga el proyecto autom√°ticamente en el explorador de proyectos del IDE. Y as√≠, ya podemos trabajar directamente con √©l. Creando un proyecto de Spring mediante a Spring Boot Initializer Para crear un proyecto desde la web, visitaremos la web https://start.spring.io/ La configuraci√≥n que utilizaremos ser√° mediante a Maven, utilizando Java, y Spring Boot 2.1.6 (quiz√°s esta versi√≥n cambie est√©s realizando este tutorial). Si desplegamos el Options, podemos ver que podemos seleccionar la versi√≥n de Java. Nosotros utilizaremos la 8. Si bajamos un poco m√°s, podemos ver el apartado de dependencias. En nuestro caso, vamos a a√±adir spring Web Started. La podemos buscar desde el buscador, o bien ir al icono de alado, donde nos aparecer√° un listado con dependencias y seleccionarla. Y finalmente, pulsamos en generar proyecto. Finalmente, se nos descargar√° el proyecto en archivo .zip, El cual vamos a descomprimir en el mismo directorio de descargas donde se nos ha descargado el proyecto Cargando un proyecto de Spring Boot Ahora, vamos a cargar un proyecto de maven, esto nos vale para cualquier proyecto, no solamente para los que creamos desde https://start.spring.io/ . Para realizar la carga, vamos a Project Explorer > Bot√≥n derecho > Import‚Ä¶ Seleccionamos la opci√≥n de proyecto de Maven existente: Seleccionamos el directorio donde se encuentra (si hab√©is seguido las indicaciones estar√° en descargas). Y una vez seleccionado, podemos ver como se realiza la importaci√≥n y la descarga de dependencias. Finalmente, y una vez concluida la descarga de dependencias, ya tenemos nuestro proyecto cargado en Spring Tool Suite con nuestro fichero pom.xml Creando un proyecto Maven mediante a Spring Tool Suite 4 Anteriormente si hab√©is seguido el tutorial paso a paso hasta aqu√≠, hemos creado un proyecto, por lo que no podemos repetir el mismo nombre. Ya que nos generar√≠a un error. Llegados a este punto, tenemos dos opciones, eliminar el proyecto o ponerle otro nombre diferente. En mi caso, voy a borrar el proyecto. Eliminando un proyecto de Spring Boot Si no marcamos el delete project contents on disk, realmente estamos √∫nicamente eliminando el proyecto del explorador de proyectos del IDE. Pero a√∫n existir√≠a el directorio. Bien, tras ver como realizamos un proyecto desde la web de https://start.spring.io/ vamos a ver como realizarlo con Spring Tool Suite. Esta manera, para m√≠ es la m√°s r√°pida y sencilla, aunque mejor que decirlo por aqu√≠ es que lo comprobareis vosotros mismos. Abrimos nuestro IDE y vamos a File > New > Project Seleccionamos Spring Starter Project Y a√±adimos la informaci√≥n del proyecto: Y finalmente, a√±adimos las dependencias y pulsamos sobre finalizar. Una vez finalizada la creaci√≥n, como en la creaci√≥n anterior, realizar√° la importaci√≥n y descargar√° dependencias. Y ya tenemos el proyecto listo para trabajar sobre el: Pom resultante de ambos proyectos Si observamos el pom que se nos a creado en el proyecto, destaca principalmente el ver la versi√≥n de Java con al que estamos trabajando, en nuestro caso la 1.8. Tambi√©n podemos apreciar que pese a que hemos marcado una sola dependencia, tenemos dos. Esto es debido a que autom√°ticamente, al incluir la dependencia spring-boot-starter-web , tambi√©n se nos incluye la dependencia de testing (spring-boot-starter-test)."
    },

    {
        "id": 78,
        "autor": "Cecilio √Ålvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "11/05/2020",
        "titulo": "Spring @Autowired y la inyecci√≥n de dependencias",
        "link": "https://www.arquitecturajava.com/spring-autowired-y-la-inyeccion-de-dependencias/",
        "contenido": "Spring @Autowired es una de las anotaciones m√°s habituales cuando trabajamos con Spring Framework ya que se trata de la anotaci√≥n que permite inyectar unas dependencias con otras dentro de Spring . Spring @Autowired y su funcionamiento Normalmente estamos acostumbrados a usar @AutoWired a nivel de la propiedad que deseamos inyectar. Spring funciona como una mega factoria de objetos. Cada clase se registra para instanciar objetos con alguna de las anotaciones @Controller ,@Service ,@repository o @RestController. Spring inyeccion dependencia Una vez que los objetos estan creados la anotaci√≥n Spring @Autowired se encarga de construir las ligazones entre los distintos elementos Spring @Autowired Por ejemplo este caso es habitual cuando tenemos un servicio y un repositorio. Vamos a verlo usando Spring Boot package com.arquitecturajava.wired; import java.util.ArrayList; import java.util.List; import org.springframework.stereotype.Component; import org.springframework.stereotype.Repository; @Repository public class LibroRepository { public List<Libro> buscarTodos() { List<Libro> lista= new ArrayList<Libro>(); lista.add(new Libro ( 1 , java , pedro )); lista.add(new Libro ( 2 , python , gema )); return lista; } } Como podemos ver tenemos el LibroRepository como primer componente y le queremos enlazar desde un Servicio. package com.arquitecturajava.wired; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class LibroRestService { @Autowired LibroRepository repositorio; @RequestMapping( /libros ) public List<Libro> buscarTodos() { return repositorio.buscarTodos(); } } Ahora tenemos los dos elementos enlazados y un ServicioREST publicado por lo tanto si ejecutamos la aplicaci√≥n de Spring Boot dispondremos de una Url con un listado de Libros disponible Spring @Autowrired rest Spring Testing y Wiring Hoy por hoy las metodolog√≠as de TDD cada d√≠a se usan m√°s y aunque este uso de la anotacion @Autowired es el m√°s habitual suele ser m√°s pr√°ctico y c√≥modo para el manejo de test realizar un @Autowired a nivel de constructores por lo tanto el c√≥digo quedar√≠a as√≠: package com.arquitecturajava.wired; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class LibroRestService { LibroRepository repositorio; @Autowired public LibroRestService(LibroRepository repositorio) { this.repositorio=repositorio; } @RequestMapping( /libros ) public List<Libro> buscarTodos() { return repositorio.buscarTodos(); } } De esta manera el c√≥digo queda m√°s limpio , flexible y m√°s sencillo de usar cuando utilicemos Test Driven Development."
    },

    {
        "id": 79,
        "autor": "Iv√°n Salas",
        "pagina": "programandoointentandolo",
        "fecha": "22/05/2013",
        "titulo": "INYECCI√ìN DE DEPENDENCIAS EN SPRING",
        "link": "https://programandoointentandolo.com/2013/05/inyeccion-de-dependencias-en-spring.html",
        "contenido": "La inyecci√≥n de dependencias es quiz√°s la caracter√≠stica m√°s destacable del core de Spring Framework, que consiste que en lugar de que cada clase tenga que instanciar los objetos que necesite, sea Spring el que inyecte esos objetos, lo que quiere decir que es Spring el que creara los objetos y cuando una clase necesite usarlos se le pasaran (como cuando le pasas un par√°metro a un m√©todo). La inyecci√≥n de dependencias es una forma distinta de dise√±ar aplicaciones, si estas empezando con Spring (como yo) ya habr√°s visto que en muchos sitios usan los t√©rminos inyecci√≥n de dependencia (DI) e inversi√≥n de control (IoC) de forma indistinta y aunque no son sin√≥nimos, sino que m√°s bien la inyecci√≥n de dependencia ser√≠a una forma de inversi√≥n de control. Pero probablemente te preguntaras en que consiste la inyecci√≥n de dependencia y que ventajas tiene su uso, pues aqu√≠ voy a intentar explicar lo que yo he entendido con unos ejemplos para verlo de una forma m√°s intuitiva, que para ver definiciones ya hay muchos libros. La DI consiste en que en lugar de que sean las clases las encargadas de crear (instanciar) los objetos que van a usar (sus atributos), los objetos se inyectaran mediante los m√©todos setters o mediante el constructor en el momento en el que se cree la clase y cuando se quiera usar la clase e cuesti√≥n ya estar√° lista, en cambio sin usar DI la clase necesita crear los objetos que necesita cada vez que se use. En Spring hay un Contendor DI que es el encargado de inyectar a cada objeto los objetos que necesita (de los que depende) seg√∫n se le indique ya sea en un archivo de configuraci√≥n XML o mediante anotaciones. Con esta peque√±a explicaci√≥n te puedes hacer una idea de en que consiste la inyecci√≥n de dependencia, vamos ahora a ver cual es el sentido de su uso. La que nos ofrece la inyecci√≥n de dependencias es desacoplamiento y tambi√©n que los objetos son instanciados en el Contenedor DI y se inyectan donde sea necesario de forma que pueden ser reutilizados. Un ejemplo t√≠pico para ver su utilidad es el de una clase que necesita una conexi√≥n a base de datos, sin DI si varios usuarios necesitan usar esta clase se tendr√°n que crear m√∫ltiples conexiones a la base de datos con la consiguiente posible perdida de rendimiento, pero usando la inyecci√≥n de dependencia las dependencias de la clase (sus atributos), son instanciados una √∫nica vez cuando se despliega la aplicaci√≥n y se comparten por todas las instancias de modo que una √∫nica conexi√≥n a base de datos es compartida por m√∫ltiples peticiones. En este caso esta bien que sea una √∫nica instancia pero habr√° casos en los que no nos interesar√° esta opci√≥n que es la que se usa por defecto por lo que Spring nos da la opci√≥n por si queremos que nuestros objetos no usen el patr√≥n singleton. Y en lo referente al desacoplamiento como no es necesario instanciar en una clase los objetos que necesita sino que son inyectados si la clase que necesita cambia no es necesario modificar nada en la clase que hacia uso de ella. Y en lo referente al desacoplamiento al no tener que instanciar las dependencias si alguna cambia no hay que modificar nada pues esa clase no estar√° instanciada en ning√∫n sitio de nuestra clase (Clase c = new clase();). Vamos a ver unos ejemplos de como se hace la DI mediante settters, mediante el constructor y con el uso de anotaciones para no tener que escribir nada en el xml. EJEMPLO DE INYECCI√ìN DE DEPENDENCIA MEDIANTE SETTTERS Para que se vean bien las cosas vamos a crear una aplicaci√≥n de escritorio, en una aplicaci√≥n web la aplicaci√≥n es la misma pero como hay m√°s archivos de configuraci√≥n es m√°s f√°cil equivocarse aunque como digo la inyecci√≥n de dependencia se hace exactamente igual, salvo que para una aplicaci√≥n de escritorio hay que indicarle en el Main donde se encuentra el archivo en el que est√°n declarados los beans y en una aplicaci√≥n web se hace en el web.xml. En este primer ejemplo vamos a usar una clase Libro que entre sus atributos tendr√° uno de la clase Autor y en el Main mostraremos los datos del libro. package com.blogspot.programandoointentandolo; public class Libro { private String titulo; private Autor autor; private String genero; private String editorial; private int edicion; private int paginas; // Getters y Setters } package com.blogspot.programandoointentandolo; public class Autor { private String nombre; private String apellido; // Getters y Setters } La clase Libro es un simple POJO y como vamos a inyectar las dependencias mediante setters pues l√≥gicamente deber√° disponer de ellos (lo mismo para Autor) y en el Main para hacer uso de la ID primero debemos de cargar el xml en el que estar√°n definidos los beans y luego obtenemos el que nos interesa (libro). package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.BeanFactory; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { BeanFactory factory = new ClassPathXmlApplicationContext( META-INF/spring/app-context.xml ); Libro libro = (Libro) factory.getBean( libro ); System.out.println( -   + libro.getTitulo()); System.out.println( -   + libro.getAutor().getNombre() +     + libro.getAutor().getApellido()); System.out.println( -   + libro.getEditorial()); System.out.println( -   + libro.getGenero()); System.out.println( -   + libro.getEdicion()); System.out.println( -   + libro.getPaginas()); } } Vamos con el app-context.xml que ser√° donde definamos los beans para poder inyectarlos donde lo necesitemos: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <bean id= libro  class= com.blogspot.programandoointentandolo.Libro > <property name= titulo  value= Aprendiendo Spring /> <property name= autor  ref= autor /> <property name= genero  value= Aventuras /> <property name= edicion  value= 2 /> <property name= paginas  value= 257 /> </bean> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <property name= nombre  value= Luis  /> <property name= apellido  value= Perez  /> </bean> </beans> Viendo el c√≥digo anterior te puedes hacer una idea bastante buena de que es lo que hace sin ninguna explicaci√≥n pero vamos a explicarlo. En primer lugar las clases se definen con la etiqueta <bean> y se deben de indicar el atributo class que indica donde esta la clase de la que ser√° el bean y si se quiere usar en otro lugar el atributo id que nos servir√° como identificador del bean. Dentro de cada bean se pueden indicar las propiedades que se quieren inyectar con la etiqueta property, el atributo name hace referencia al nombre del atributo que se quiere inyectar, por ejemplo el primero es para inyectar el titulo, y despu√©s puede tener un atributo value si le queremos inyectar un String, int,‚Ä¶ y el atributo ref que lo usaremos cuando queramos inyectar otro bean, es el caso de autor, y en el atributo ref debemos de poner el id del bean que queremos inyectarle, en este caso tambi√©n es autor. Y con esto cuando ejecutemos la aplicaci√≥n veremos como se nos imprimen los valores que hemos introducido en xml sin haber tenido que instanciar en ning√∫n momento ning√∫n objeto ni de la clase Libro ni de la clase Autor. Pues as√≠ de sencilla es la inyecci√≥n de dependencia. EJEMPLO DE INYECCI√ìN DE DEPENDENCIA MEDIANTE EL CONSTRUCTOR Adem√°s de poder inyectar mediante m√©todos setters tambi√©n se puede inyectar mediante constructor aunque es mejor la primera opci√≥n. Vamos a ver en este ejemplo como inyectar las propiedades del Autor mediante constructor para lo cual la clase Autor deber√° de tener un constructor con los par√°metros nombre y apellido y no hace falta que tenga m√©todos setters. No hace falta modificar otra cosa del resto del c√≥digo java. Y el xml para poder inyectar mediante constructor en el bean autor es este: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <bean id= libro  class= com.blogspot.programandoointentandolo.Libro > <property name= titulo  value= Aprendiendo Spring /> <property name= autor  ref= autor /> <property name= genero  value= Aventuras /> <property name= edicion  value= 2 /> <property name= paginas  value= 257 /> </bean> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <constructor-arg value= Luis  /> <constructor-arg value= Perez  /> </bean> </beans> Los par√°metros del libro los seguimos inyectando mediante setters pero para el autor usaremos el constructor para lo que debemos de cambiar property por constructor-arg y solo le indicamos el value o ref si fuese el caso, pero no hay que indicar el name ya que estos atributos se pasaran en orden al constructor por lo que debemos de tener cuidado de ponerlos en el orden correcto. EJEMPLO DE INYECCI√ìN DE DEPENDENCIA CON ANOTACIONES De las dos formas anteriores era necesario indicar en el archivo de configuraci√≥n que beans pod√≠an ser inyectados en otros y sobre los que se quer√≠an inyectar. Mediante las anotaciones podemos hacer ambas cosas o solo una si se quiere, por ejemplo podemos declarar los beans en el xml y usar anotaciones para inyectarlos en lugar de usar <property name=¬ªautor¬ª ref=¬ªautor¬ª>. Antes de empezar voy a poner una lista de las anotaciones que voy a comentar: @Component:Sustituye la declaraci√≥n del bean en el xml. @Autowired:Sustituye la declaraci√≥n de los atributos del bean en el xml. @Qualifier(¬´nombreBean¬ª):Sirve para indicar que clase es la que se debe inyectar. @Required:Indica si el atributo es obligatorio. @Service, @Repository y @Controller:Son estereotipos de @Component y se usan para indicar que la clase sera un servicio (@Service), una clase de acceso a datos (@repository) o un controlador (@Controller). @PostConstruct:Ejecuta el metodo con esta anotaci√≥n despues de crear el objeto. @PreDestroy:Ejecuta el metodo con esta anotaci√≥n antes de destruir el objeto. @Scope:Sirve para indicar el ambito en el que se encontrara el bean. Las anotaciones de la lista anterior son propias de Spring pero tambi√©n se pueden usar anotaciones propias del standar Java EE como las 2 siguientes: @Inject:Se puede usar en lugar de @Autowired. @Resource(¬´nombreBean¬ª):Sustituye el uso de las anotaciones @Autowired y @Qualifier(¬´nombreBean¬ª) de forma que es necesaria una sola anotaci√≥n. @AUTOWIRED Para empezar vamos a ver la anotaci√≥n @Autowired que nos permite no tener que definir la propiedad que se quiere inyectar en el xml dentro del bean. La anotaci√≥n @Autowired se puede poner encima del atributo que se quiere inyectar, encima del m√©todo setter de dicho m√©todo o tambi√©n encima del constructor y dependiendo de donde se ponga la inyecci√≥n se har√≠a por atributo, por setter o por constructor como es l√≥gico. Respecto al c√≥digo que ten√≠amos sin usar anotaciones hay que modificar la clase Libro a√±adiendo la anotaci√≥n @Autowired de cualquiera de las 3 formas que dec√≠a, en este ejemplo anotamos el atributo. import org.springframework.beans.factory.annotation.Autowired; public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired private Autor autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; // Setters y getters } Y en el xml quedar√≠a as√≠: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <!-- Habilita el uso de anotaciones --> <context:annotation-config /> <bean id= libro  class= com.blogspot.programandoointentandolo.Libro /> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <constructor-arg value= Luis  /> <constructor-arg value= Perez  /> </bean> </beans> El bean autor sigue igual ya que no hemos hecho ninguna anotaci√≥n en el, pero en el bean libro ahora no hay ning√∫n atributo ya que ahora hemos usado la anotaci√≥n @Autowired para inyectar el autor, y el resto de campos que son simples strings e ints simplemente est√°n inicializados en la clase aunque en un ejemplo m√°s ¬´serio¬ª pues se le dar√≠an valores con los setters por ejemplo aunque para el caso de ver como funcionan las anotaciones eso no aporta nada. Adem√°s de que en el bean libro ya no est√°n los atributos para poder usar la anotaci√≥n @Autowired es necesario incluir <context:annotation-config /> para indicar que vamos a usar esta anotaci√≥n. @COMPONENT Esta anotaci√≥n nos evita la necesidad de declarar el bean en el xml, vamos a anotar las clases Libro y Autor con @Component y de este modo ya no tendremos ning√∫n bean en el xml, de modo que el xml solo tendr√° que contener la siguiente l√≠nea en la que le indicamos el paquete apartir del que se buscaran las clases anotadas con @Component o cualquiera de sus estereotipos y tambi√©n sustituye a <context:annotation-config /> que usemos por si solo quer√≠amos usar @Autowired. <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <!-- Habilita el uso de anotaciones --> <context:component-scan base-package= com.blogspot.programandoointentandolo  /> </beans> Y en lo referente a las clases Autor y Libro quedarian de la siguiente forma: package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component public class Autor { private String nombre =  Luis ; private String apellido =  Perez ; public Autor(){} // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired private Autor autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } Adem√°s de anotar la clase con @Component tambien hay que a√±adir un constructor sin par√°metros, en el caso de que tuvi√©semos alguno con par√°metros ya que al usar la anotaci√≥n @Component el objeto se crea con este constructor y sino lo tenemos no compilar√°. @QUALIFIER Con esta anotaci√≥n podemos indicar el id del bean que se quiere inyectar, esta anotaci√≥n se usa cuando el atributo que vamos a inyectar es una interfaz de la que hay varias implementaciones y entonces ser√° mediante esta anotaci√≥n con la que le diremos cual es la clase que queremos inyectar. Tambi√©n se puede usar por ejemplo si en el xml declaramos varios beans que aunque sean de la misma clase (tengan el mismo atributo class) tengan un id distinto. Aunque en los ejemplos que he puesto no he puesto ninguna interfaz pues no aporta nada a la explicaci√≥n lo normal ser√° que las clases que se inyectan sean interfaces para hacer el c√≥digo m√°s desacoplado y facilitar las posibles futuras modificaciones. Por ejemplo si en lugar de la clase autor directamente tuvi√©semos una interfaz AutorInterfaz y dos clases AutorDesconocido y AutorConocido package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component( autordesconocido ) public class AutorDesconocido implements AutorInterfaz{ private String nombre =  Luis ; private String apellido =  Perez ; // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component( autorconocido ) public class AutorConocido implements AutorInterfaz{ private String nombre =  Antonio ; private String apellido =  Fernandez ; // Setters y getters } Como en @Qualifier hemos indicado autorconocido se inyectara la clase AutorConocido pero si quisi√©semos cambiar para que se inyectara AutorDesconocido o cualquier otra clase que implementase AutorInterfaz solo tendr√≠amos que indicar en @Qualifier el nombre del bean que queremos inyectar. @REQUIRED Esta anotaci√≥n creo que esta bastante claro para que se usa, si queremos que un campo sea obligatorio lo anotaremos con @Required. Para que el autor fuese obligatoria la clase Libro ser√≠a as√≠: package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } @POSTCONSTRUCT Y @PREDESTROY Estas son anotaciones para m√©todos y las usaremos si queremos que se ejecute un m√©todo justo despu√©s de que se haya creado la clase (objeto de la clase) o antes de que se destruya. import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} @PostConstruct public void saludar(){ System.out.println( Hola ); } @PreDestroy public void despedirse(){ System.out.println( Adios ); } // Setters y getters } @SCOPE Con esta anotaci√≥n indicamos cuando se crearan instancias de la clase con esta anotaci√≥n y en que √°mbito. Si no se usa la anotaci√≥n @Scope (valor por defecto) el scope es singleton. Los posibles valores son: singleton: Se crea una unica instancia del bean para toda la aplicaci√≥n. prototype: Se crea una nueva instacia del bean cada vez. request: Se crea una nueva instacia del bean para cada petici√≥n HTTP request. session: Se crea una nueva instacia del bean por sesi√≥n HTTP. globalSession: Se crea una nueva instacia del para cada sesi√≥n HTTP global. Las 3 ultimas aunque supongo que se ve por el nombre solo son para aplicaciones web mientras que las dos primeras pueden usarse en cualquier tipo de aplicaci√≥n Spring. Y para finalizar si quisi√©semos que se crease una instancia de la clase Libro cada vez usar√≠amos @Scope(¬´prototype¬ª). import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; @Component @Scope( prototype ) public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} @PostConstruct public void saludar(){ System.out.println( Hola ); } @PreDestroy public void despedirse(){ System.out.println( Adios ); } // Setters y getters } Despu√©s de ver como hacer las inyecciones de dependencias con anotaciones probablemente te preguntaras si es mejor o peor usar anotaciones. Desde el punto de vista de que es m√°s f√°cil y m√°s r√°pido esta claro que ganan las anotaciones y desde el punto de vista de tener todo centralizado mejor usar el xml porque con las anotaciones esta repartido por toda la aplicaci√≥n por lo que para modificar algo ser√≠a necesario buscarlo, modificarlo y recompilarlo mientras que con el xml todo esta en el mismo sitio y con cambiar el xml esta todo listo sin hacer nada m√°s. Entonces podr√≠amos decir que las anotaciones son ideales durante la fase de desarrollo porque el c√≥digo esta cambiando constantemente y cuanto m√°s r√°pido sea hacer un cambio mejor y una vez que la aplicaci√≥n ya sea ¬´estable¬ª se sustituyen las anotaciones y de este modo tenemos las ventajas de ambas opciones en los momentos en las que los necesitamos, aunque no se si tiene demasiado sentido hacer esto"
    },

    {
        "id": 80,
        "autor": "Rub√©n Pahino",
        "pagina": "campusmvp",
        "fecha": "31/03/2020",
        "titulo": "¬øQu√© son Spring framework y Spring Boot? Tu primer programa Java con este framework",
        "link": "https://www.campusmvp.es/recursos/post/que-son-spring-framework-y-spring-boot-tu-primer-programa-java-con-este-framework.aspx",
        "contenido": "Si desarrollas con Java, o lo has hecho en alg√∫n momento de los √∫ltimos a√±os, seguramente te suene Spring Framework, aunque sea de o√≠das. Spring Framework es un framework Open Source que facilita la creaci√≥n de aplicaciones de todo tipo en Java, Kotlin y Groovy. Si bien es cierto que, por lo que es m√°s conocido es por la inyecci√≥n de dependencias, Spring Framework est√° dividido en diversos m√≥dulos que podemos utilizar, ofreci√©ndonos muchas m√°s funcionalidades: Core container: proporciona inyecci√≥n de dependencias e inversi√≥n de control. Web: nos permite crear controladores Web, tanto de vistas MVC como aplicaciones REST. Acceso a datos: abstracciones sobre JDBC, ORMs como Hibernate, sistemas OXM (Object XML Mappers), JSM y transacciones. Programaci√≥n orientada a Aspectos (AOP): ofrece el soporte para aspectos. Instrumentaci√≥n: proporciona soporte para la instrumentaci√≥n de clases. Pruebas de c√≥digo: contiene un framework de testing, con soporte para JUnit y TestNG y todo lo necesario para probar los mecanismos de Spring. Estos m√≥dulos son opcionales, por lo que podemos utilizar los que necesitemos sin tener que llenar nuestro classpath con clases que no vamos a usar. Esquema que ilustra los diferentes m√≥dulos de Spring, obtenido de la documentaci√≥n oficial Razones para usar Spring Aunque no sea una caracter√≠stica √∫nica de Spring, el uso de inyecci√≥n de dependencias facilita la programaci√≥n contra interfaz, permitiendo a los distintos componentes depender √∫nicamente de interfaces y produciendo as√≠ un c√≥digo menos acoplado. No solo eso, tambi√©n permite implementar el patr√≥n singleton de una forma extremadamente sencilla (por defecto, las dependencias que inyectamos son singletons). Hay cientos de tecnolog√≠as que Spring permite integrar. Desde bibliotecas que implementan opentracing hasta las que nos generan m√©tricas para nuestra aplicaci√≥n, pasando por serializaci√≥n/deserializaci√≥n a JSON y XML, seguridad con OAuth2 o programaci√≥n reactiva entre otras. En general, Spring aumenta la productividad y reduce la fricci√≥n al ofrecernos abstracciones sobre implementaciones de tecnolog√≠as concretas. Un ejemplo claro es el de spring-data, que nos permite definir el acceso a base de datos con interfaces Java. Esto lo consigue parseando el nombre de los m√©todos y generando la consulta con la sintaxis espec√≠fica para el driver que utilicemos. Por ejemplo, cambiar nuestra aplicaci√≥n de MySQL a PostgreSQL es tan sencillo como cambiar el driver: Spring se encarga de la sintaxis de forma transparente. A pesar de  la magia de Spring  üßôüèª‚Äç‚ôÇÔ∏è, como muchos lo llaman, Spring nos permite desactivar estos  comportamientos m√°gicos  en caso de ser necesario, por lo que podemos tomar el control cuando necesitemos m√°s granularidad. Siguiendo con el ejemplo de spring-data, este control ser√≠a necesario si tenemos que realizar consultas mucho m√°s complejas que un SELECT * BY name. En esos casos, entre otras opciones, podemos anotar nuestro m√©todo con @Query y escribir la consulta que deseemos. Ya no hay magia üòâ Por lo general, Spring no obliga a implementar ni extender nada, lo que nos permite escribir c√≥digo que es  agn√≥stico  del framework. De esta forma, desarrolladores con cero o muy poco conocimiento de Spring pueden realizar su trabajo sin mayores complicaciones. Spring es de c√≥digo abierto y tiene una gran comunidad detr√°s. Si encuentras un bug, echas en falta una funcionalidad o lo que sea, siempre puedes abrir un ticket o contribuir por tu cuenta. ¬øPero no √≠bamos a hablar de Spring Boot? Hasta ahora he hablado de Spring Framework en general, pero el t√≠tulo de esta entrada menciona Spring Boot, as√≠ que voy a presentarlo. Si bien es cierto que Spring Framework es muy potente, la configuraci√≥n inicial y la preparaci√≥n de las aplicaciones para producci√≥n son tareas bastante tediosas. Spring Boot simplifica el proceso al m√°ximo gracias a sus dos principales mecanismos. Contenedor de aplicaciones integrado Spring Boot permite compilar nuestras aplicaciones Web como un archivo .jar que podemos ejecutar como una aplicaci√≥n Java normal (como alternativa a un archivo .war, que desplegar√≠amos en un servidor de aplicaciones como Tomcat). Esto lo consigue integrando el servidor de aplicaciones en el propio .jar y levant√°ndolo cuando arrancamos la aplicaci√≥n. De esta forma, podemos distribuir nuestras aplicaciones de una forma mucho m√°s sencilla, al poder configurar el servidor junto con la aplicaci√≥n. Esto tambi√©n es muy √∫til en arquitecturas de microservicios, puesto que permite distribuir nuestras aplicaciones como im√°genes Docker que podemos escalar horizontalmente (algo muy complicado con un .war). Nota: Spring boot permite distribuir tu aplicaci√≥n como un jar, no lo impone. Si prefieres desplegar tu aplicaci√≥n en un servidor de aplicaciones tradicional, Spring Boot te deja compilar el c√≥digo como un .war que no incluya ning√∫n servidor de aplicaciones integrado. Starters Spring Boot nos proporciona una serie de dependencias, llamadas starters, que podemos a√±adir a nuestro proyecto dependiendo de lo que necesitemos: crear un controlador REST, acceder a una base de datos usando JDBC, conectar con una cola de mensajes Apache ActiveMQ, etc. Una vez a√±adimos un starter, √©ste nos proporciona todas las dependencias que necesitamos, tanto de Spring como de terceros. Adem√°s, los starters vienen configurados con valores por defecto, que pretenden minimizar la necesidad de configuraci√≥n a la hora de desarrollar. Un buen ejemplo es el de spring-boot-starter-actuator: una vez que a√±adimos la dependencia, nuestra aplicaci√≥n empezar√° a generar m√©tricas tanto de la JVM como de la aplicaci√≥n en s√≠ (latencias, errores, etc). Al igual que con Spring Framework, cualquier configuraci√≥n puede ser modificada de ser necesario: desde el puerto en el que la aplicaci√≥n escucha peticiones, hasta el banner que sale por consola al arrancar la aplicaci√≥n. Hola Mundo con Spring Boot Para demostrar lo f√°cil que es empezar a usar Spring Boot, vamos a ver el c√≥digo necesario para crear nuestro primer  Hola mundo : @SpringBootApplication @RestController public class Application { @GetMapping( /hello ) public String hello() { return  Hello Bootiful! ; } } Sencillo, ¬øverdad? Aprende con nosotros a sacarle todo el partido a Spring Framework y Spring Boot. Un poco m√°s abajo te explico en un v√≠deo pr√°ctico c√≥mo llegar a este c√≥digo y qu√© significa. Bonus tip: Spring Initializr Captura de Spring Initializr El equipo de Spring tambi√©n ha creado Spring Initializr, una herramienta web que puedes utilizar para autogenerar el esqueleto de tu aplicaci√≥n Spring Boot. Se trata de un inicializador muy √∫til, ya que genera el pom.xml (o build.gradle), el main de la aplicaci√≥n, y un test que comprueba que la aplicaci√≥n arranca correctamente."
    },

    {
        "id": 81,
        "autor": "Cleventy",
        "pagina": "cleventy",
        "fecha": "8/07/2020",
        "titulo": "Capa controlador de un proyecto Spring Boot",
        "link": "https://cleventy.com/capa-controlador-de-un-proyecto-spring-boot/",
        "contenido": "Este art√≠culo continua la serie iniciada en el primer art√≠culo. En este art√≠culo vamos a presentar la implementaci√≥n de la capa controlador de la aplicaci√≥n. Entendemos como controlador a la capa de una aplicaci√≥n que responde a eventos e invoca peticiones a la capa modelo. En nuestro ejemplo, los controladores est√°n bajo el paquete controller y tienen las siguientes caracter√≠sticas: Est√°n anotados con @Controller (o @RestController) Atienden peticiones bajo una ruta definida en la anotaci√≥n @RequestMapping Su nombre termina en Controller Suelen tener inyectados (con anotaci√≥n @Autowired) el servicio relacionado al que acceden Responden a diferentes m√©todos HTTP definidos por la anotaci√≥n @GetMapping Diferenciamos, dependiendo de la naturaleza de los eventos, entre Controlador Web y Controlador API. Controlador Web Responde a eventos lanzados por el usuario desde la web. Un ejemplo es el controlador web de administraci√≥n de usuarios. En √©l hay un √∫nico m√©todo que lo que hace es obtener todos los usuarios y devolverlos a una vista. Esta comunicaci√≥n se realiza a trav√©s del enlace de propiedades en el objeto del modelo (org.springframework.ui.Model). Para lanzar este invocaci√≥n basta con lanzar una petici√≥n GET a la p√°gina de administraci√≥n de usuarios, o, en otras palabras m√°s sencillas, acceder a dicha URL desde el navegador. Controlador API Define un API Rest y por lo tanto responde a diferentes tipos de peticiones. √ötil para comunicar e integrar nuestra aplicaci√≥n con otros sistemas como por ejemplo una aplicaci√≥n m√≥vil. Un ejemplo (an√°logo al anterior) ser√≠a el controlador API de administraci√≥n de usuarios. En √©l hay poco m√°s que un CRUD completo de Usuario, permitiendo, por lo tanto, crear, leer, actualizar y borrar usuarios. Algunas de sus caracter√≠sticas son: A diferencia de los controladores web, estos est√°n anotados por @RestController. Devuelven una objeto gen√©rico de respuesta (org.springframework.http.ResponseEntity) que contiene, a su vez, m√°s informaci√≥n propia de la petici√≥n. Admite diferentes tipos de par√°metros: @RequestParam: por ejemplo, el par√°metro page en /api/admin/users?page=1 @PathVariable: por ejemplo, el identificador de usuario 3 en /api/admin/users/3/sendwelcomeemail @RequestBody: por ejemplo, el cuerpo de la petici√≥n POST de creaci√≥n de usuario /api/admin/users Para explotar/visualizar estos datos es bueno verlo con un ejemplo. Podemos verlo con Postman o directamente con una petici√≥n cURL. Podemos importar la petici√≥n cURL directamente en Postman o ejecutar en la consola la siguiente petici√≥n para obtener los usuarios: curl --location --request GET 'http://localhost:8080/application-4.0.5/api/admin/users'  --header 'Content-Type: application/json'  --header 'Accept: '  --header 'Authorization: Bearer <my_token>' </my_token> Otro ejemplo de petici√≥n, esta sin autenticaci√≥n, ser√≠a, por ejemplo, esta: curl --location --request GET 'http://localhost:8080/application-4.0.5/api/version'  --header 'Content-Type: application/json'"
    },

    {
        "id": 82,
        "autor": "Cecilio √Ålvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "24/07/2015",
        "titulo": "Spring REST Service con @RestController",
        "link": "https://www.arquitecturajava.com/spring-rest-service-con-restcontroller/",
        "contenido": "Crear un Spring REST Service es ahora muy sencillo a trav√©s del uso de la anotaci√≥n @RestController que Spring 4 soporta. En primer lugar se configura el fichero de pom.xml de Maven con las siguientes dependencias. <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>4.1.7.RELEASE</version> </dependency> <dependency> <groupId>javax.servlet</groupId> <artifactId>jstl</artifactId> <version>1.2</version> <scope>provided</scope> </dependency> <dependency> <groupId>javax.servlet</groupId> <artifactId>servlet-api</artifactId> <version>2.5</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-validator</artifactId> <version>5.1.3.Final</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-core</artifactId> <version>2.4.2</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.4.2</version> </dependency> </dependencies> El siguiente paso es configurar el Servlet Dispatcher en el web.xml que es el que nos permite mapear todas las urls de los controladores de Spring. <web-app xmlns= http://java.sun.com/xml/ns/javaee  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd version= 3.0 > <servlet> <servlet-name>ServletSpring</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/config/applicationContext.xml</param-value> </init-param> </servlet> <servlet-mapping> <servlet-name>ServletSpring</servlet-name> <url-pattern>*.html</url-pattern> <url-pattern>*.json</url-pattern> </servlet-mapping> </web-app> El √∫ltimo paso a nivel de configuraci√≥n es definir el fichero applicationContext.xml: <beans xmlns= http://www.springframework.org/schema/beans xmlns:context= http://www.springframework.org/schema/context xmlns:mvc= http://www.springframework.org/schema/mvc  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:p= http://www.springframework.org/schema/p xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc12 http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd > <mvc:annotation-driven /> <context:component-scan base-package= com.arquitecturajava.controller  /> </beans> Realizada la configuraci√≥n ser√° suficiente con crear una clase que use la anotaci√≥n @RestController y automaticamente se publicara como un  Spring REST Service. springrestservicepublicacion package com.arquitecturajava.controller; import java.util.ArrayList; import java.util.List; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import com.arquitecturajava.negocio.Persona; @RestController public class ControladorREST { @RequestMapping(value =  /personas , method = RequestMethod.GET) public List < Persona > listaPersonas() { List < Persona > lista = new ArrayList < Persona > (); Persona p = new Persona(); p.setNombre( angel ); p.setEdad(20); lista.add(p); Persona p1 = new Persona(); p1.setNombre( gema ); p1.setEdad(30); lista.add(p1); return lista; } } Acabamos de crear un servicio REST que nos devuelve una Persona en una url determinada , concretamente en /personas recordemos que para las url REST normalmente se utilizan los plurales. Cursos asociados Curso de Spring Boot Curso de Spring WebFlux Curso de Java 8 Ya solo queda realizar una petici√≥n web a la URL en donde se ha mapeado el Spring REST Service: spring rest service Conclusiones Spring 4 introduce novedades que hacen la vida m√°s sencilla a los desarrolladores"
    },

    {
        "id": 83,
        "autor": "Cristian Ruiz",
        "pagina": "cristianruizblog",
        "fecha": "29/09/2018",
        "titulo": "Spring Boot 2 + MVC Parte 1| Usando JSP?",
        "link": "http://cristianruizblog.com/spring-boot-mvc-parte-1-usando-jsp/",
        "contenido": "Que es MVC? Es la solucion al problema de como conectar el CLIENTE con el SERVIDOR, en este caso en una aplicacion web de manera rapida, organizada y sencilla. Con Spring Boot Framework se puede implementar el patron de dise√±o Modelo ‚Äì Vista ‚Äì Controlador mejor conovido como MVC, donde la capa llamada vista (archivos HTML o JSP) que normalmente es el cliente en nuestra aplicacion web se comunica con la capa de negocio (Archivos Java llamados Controladores) que seria el servidor, por medio de Modelos (Archivos Java mejor conocidos como Plain Old Java Object). Para comprender como se comunica una aplicacion web que implementa el patron de dise√±o MVC analisa la siguiente imagen: El cliente hace un request al despachador de servlets y este llama al encargado de mapeo url, identifica a que controller y que metodo estas queriendo acceder y le devuelve esa informacion al despachador para invocar ese metodo. En la declaracion del metodo puedes poner tu model(POJO) Y si los atributos del request son iguales a los atributos de tu POJO, la implementacion de Spring Boot MVC asignara esos valores automaticamente, permitiendote utilizar esa informacion para tu logica de negocio y persistencia. Una vez terminado el proceso anterior vas a querer mostrar algun tipo de mensaje o pagina web, aqui es donde entra el view. Debes indicarle a Spring Boot cual es la siguiente pagina y que informacion deseas enviar. Spring Boot creara un view(response) en base a esa informacion y se lo devolvera al cliente. Manos a la obra. Paso a Paso: En el siguiente video te mostrare paso a paso como crear una aplicacion WEB, con arquitectura MVC, ademas podras encontrar el codigo en github para poder compararlo con el tuyo. github: Repositorio github Crear Proyecto: Asegurate de utilizar el initializr de spring boot Selecciona el tipo de packaging war Selecciona la dependencia WEB Finish (Si necesitas ayuda creando proyecto con SpringBoot revisa mi tutorial Spring Boot ‚Äì Que es? y como se come? Configuracion para que interprete archivos JSP: Crear la estructura de carpetas src/main/webapp/WEB-INF/jsp Crear los archivos jsp que necesite tu proyecto Agrega estas dos atributos en el archivos application.properties : spring.mvc.view.prefix: /WEB-INF/jsp/ spring.mvc.view.suffix: .jsp Alterar ruta de ubicacion para JSP Agrega la siguiente dendencia al archivo application.properties Dependencia necesaria para compilar JSP en Spring Boot Ok, ya tu proyecto esta listo para ejecutar archivos JSP, procede a crear los puntos de acceso o controladores: crea una clase Java y en la declaracion de la clase agrega la notacion @Controller hay diferentes maneras de crear metodos dependiendo del proposito: Para renderizar un JSP, declara un metodo que retorne un String (el nombre del jsp) Agrega la anotacion @GetMapping y dentro de su constructor agrega la ruta en la url por la cualquieras acceder a ese JSP Ejemplo de un Controller simple donde redireccionas a otra pagina. Si quieres mas ejemplo de como enviar y recibir datos desde y hacia un jsp mira el video que hay mas arriba. No uses mas JSP y da un paso alfrente y se mas productivo creando codigo mas limpio y entendible para otros, usando Thymeleaf. No olvides de ver la segunda parte de este tutorial. Spring Boot + MVC Parte 2| Usando Thymeleaf Para cerrar : Spring Boot es muy popular para la creacion de Paginas y Servicios Web, poco a poco explicare mas a fondo las capacidades y caracteristicas unicas de SPRING BOOT. Espero este post responda tus dudas y si tienes alguna sugerencia y/o aporte por favor dejalo en los comentarios."
    },

    {
        "id": 84,
        "autor": "Gary Brice√±o",
        "pagina": "clubdetecnologia",
        "fecha": "30/10/2018",
        "titulo": "10 Conceptos de POO en Java",
        "link": "https://www.clubdetecnologia.net/blog/2018/10-conceptos-de-poo-en-java/",
        "contenido": "C√≥mo probablemente sepa, los conceptos de programaci√≥n orientada a objetos son muy importantes. Sin una idea de los conceptos de la POO, no estar√° en la capacidad de dise√±ar sistemas utilizando el modelo de POO ya que este simplifica el desarrollo de software y mantenimiento. En este art√≠culo, se van a explicar 10 conceptos importantes de la POO con ejemplos.[/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 1. Abstracci√≥n Intenci√≥n: La abstracci√≥n significa ocultar detalles de nivel interior o exponer solo los detalles esenciales y relevantes a los usuarios. Ejemplo real: Un autom√≥vil abstrae los detalles internos y expone al conductor solo a detalles que son relevantes para la interacci√≥n del conductor con el autom√≥vil. Por ejemplo, cuando recibimos una llamada telef√≥nica, no conocemos el proceso interno. En Java, se usa la clase abstracta y la interfaz para lograr la abstracci√≥n. Nunca compramos un ‚Äúdispositivo‚Äù, pero siempre compramos algo m√°s espec√≠fico: iPhone, Nokia 3310, etc. Aqu√≠ estos ejemplos son concretos, el dispositivo es algo abstracto. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 2. Encapsulaci√≥n Intenci√≥n: La encapsulaci√≥n se refiere a la combinaci√≥n de datos y funciones asociadas como una sola unidad. En la POO, los datos y las funciones que operan con estos datos se combinan para tomar una sola unidad, lo que se conoce como una clase. Ejemplo: C√°psula: Se envuelven diferentes medicamentos. Una clase de Java es el ejemplo de una encapsulaci√≥n. Un bean Java es la clase totalmente encapsulada porque todos los miembros de datos son privados aqu√≠. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 3. Herencia Intenci√≥n: La herencia es una relaci√≥n entre una super clase y sus sub clases. En consecuencia, este es un proceso donde un objeto adquiere los miembros de otro; adem√°s, el mismo puede formar parte de √©l. Explicaci√≥n: La herencia es un mecanismo de reutilizaci√≥n en la programaci√≥n orientada a objetos en el que se explotan las propiedades comunes de varios objetos para establecer relaciones entre s√≠. Las propiedades abstractas y comunes se proporcionan en la superclase, que esta disponible para las subclases m√°s especializadas. Cuando decimos que la clase B se hereda de otra clase A, se hace referencia a la clase B como una clase derivada (o subclase), y la clase A se llama una clase base (o superclase). Por herencia, la clase derivada recibe el comportamiento de la clase base para que todos los m√©todos y variables de miembros visibles de la clase base est√©n disponibles en la clase derivada. Aparte del comportamiento heredado, la clase derivada especializa su comportamiento al agregar o anular el comportamiento de la clase base.[/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 4. Polimorfismo Intenci√≥n: El polimorfismo nos permite realizar una misma acci√≥n de diferentes maneras El polimorfismo le permite definir una interfaz y tener m√∫ltiples implementaciones Podemos crear funciones o variables de referencia que se comportan de manera diferente en diferentes contextos program√°ticos. El polimorfismo significa muchas formas. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 5. Asociaci√≥n Intenci√≥n Representa una relaci√≥n entre dos o m√°s objetos donde todos los objetos tienen su propio ciclo de vida y no hay ning√∫n propietario. El nombre de una asociaci√≥n especifica la naturaleza de la relaci√≥n entre los objetos. La asociaci√≥n es una relaci√≥n entre dos clases separadas que se establece a trav√©s de sus objetos. La asociaci√≥n puede ser uno a uno, uno a muchos, muchos a uno y muchos a muchos. En la programaci√≥n orientada a objetos, un objeto se comunica con otro objeto para usar la funcionalidad y los servicios proporcionados por ese objeto. Hay dos formas de asociaci√≥n: Composici√≥n Agregaci√≥n [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 6. Composici√≥n Intenci√≥n La composici√≥n es una asociaci√≥n que representa una parte de una relaci√≥n completa donde una parte no puede existir sin un todo. Si se elimina un entero, entonces se eliminan todas las partes. Tiene una relaci√≥n m√°s fuerte. Puntos clave: Representa una parte de la relaci√≥n. En composici√≥n, ambas entidades dependen una de la otra. Cuando hay una composici√≥n entre dos entidades, el objeto compuesto no puede existir sin la otra entidad. Por ejemplo, si el pedido tiene art√≠culos de l√≠nea A-A, un pedido es un art√≠culo completo y los art√≠culos de l√≠nea son partes. Si se elimina un pedido, se deben eliminar todas las l√≠neas correspondientes a ese pedido. Favorecer la composici√≥n sobre la herencia. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 7. Agregaci√≥n Intenci√≥n La agregaci√≥n es una asociaci√≥n que representa parte de una relaci√≥n completa donde una parte puede existir sin un todo. Tiene una relaci√≥n m√°s d√©bil. Es una forma especializada de asociaci√≥n donde todos los objetos tienen su propio ciclo de vida, pero existe la propiedad. Esto representa una relaci√≥n de ‚Äúparte completa‚Äù o ‚Äúparte de parte‚Äù. Tomemos un ejemplo de la relaci√≥n entre el Departamento y el Maestro. Un profesor puede pertenecer a m√∫ltiples departamentos. Por lo tanto, el profesor es parte de m√∫ltiples departamentos. Pero si eliminamos un Departamento, el objeto Maestro no ser√° destruido. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 8. Delegaci√≥n Intenci√≥n: Entregar la responsabilidad de una tarea particular a otra clase o m√©todo. Es una t√©cnica en la que un objeto expresa cierto comportamiento hacia el exterior, pero en realidad, es responsabilidad de los delegados implementar ese comportamiento en un objeto asociado. Aplicabilidad: Utilice la delegaci√≥n para lograr lo siguiente: Reducir el acoplamiento de m√©todos a su clase. Componentes que se comportan de manera id√©ntica pero se dan cuenta de que esta situaci√≥n puede cambiar en el futuro. Si necesita utilizar la funcionalidad en otra clase pero no desea cambiar esa funcionalidad, utilice la delegaci√≥n en lugar de la herencia. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 9. Acoplamiento Intenci√≥n: Acoplamiento se refiere al grado en que una clase sabe acerca de otra clase. Si una clase usa otra clase, eso es acoplamiento. Esto incluye bajas dependencias entre ‚Äúartefactos‚Äù (clases, m√≥dulos, componentes). No debe haber una dependencia demasiado grande entre los m√≥dulos; incluso si hay una dependencia, deber√≠a ser a trav√©s de las interfaces y deber√≠a ser m√≠nima. Puntos clave: Al crear una aplicaci√≥n compleja en Java, la l√≥gica de una clase llamar√° a la l√≥gica de otra clase para proporcionar el mismo servicio a los clientes. Si una clase est√° llamando a otra l√≥gica de clase, entonces se llama colaboraci√≥n. Cuando una clase est√° colaborando con otra clase, entonces existe un acoplamiento estrecho entre las dos clases. Si una clase quiere llamar a la l√≥gica de una segunda clase, entonces la primera clase necesita un objeto de una segunda clase. Significa que la primera clase crea un objeto de una segunda clase. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 10. Cohesi√≥n Intenci√≥n: El t√©rmino cohesi√≥n se usa para indicar el grado en que una clase tiene una responsabilidad √∫nica y bien enfocada. La cohesi√≥n es una medida de c√≥mo los m√©todos de una clase o un m√≥dulo est√°n relacionados de manera significativa y significativa, y de cu√°n enfocados est√°n en proporcionar un prop√≥sito bien definido al sistema. Explicaci√≥n: En el dise√±o orientado a objetos, la cohesi√≥n se refiere a c√≥mo se dise√±a una sola clase. La cohesi√≥n es el principio orientado a objetos que est√° m√°s estrechamente asociado con asegurarse de que una clase est√© dise√±ada con un prop√≥sito √∫nico y bien enfocado. Cuanto m√°s enfocada est√° una clase, m√°s cohesiva es esa clase. Las ventajas de la alta cohesi√≥n son que estas clases son mucho m√°s f√°ciles de mantener (y cambian con menos frecuencia) que las clases con baja cohesi√≥n. Otro beneficio de la alta cohesi√≥n es que las clases con un prop√≥sito bien enfocado tienden a ser m√°s reutilizables que otras clases."
    },

    {
        "id": 85,
        "autor": "Eduardo Ismael Garc√≠a P√©rez",
        "pagina": "codigofacilito",
        "fecha": "27/01/2020",
        "titulo": "Diferencia Entre Clases Abstractas E Interfaces En Java",
        "link": "https://codigofacilito.com/articulos/clases-abstractas-interfaces-java",
        "contenido": "Hace un par de d√≠as en C√≥digoFacilito nos lleg√≥ una pregunta muy puntual acerca de Java, una pregunta que muy probablemente en alg√∫n momento te hayas hecho ¬øC√∫al es la diferencia entre una clases abstracta y una interfaz? ü§î Al ser conceptos muy parecidos de programaci√≥n orientada a objetos sin duda estos temas pueden ser dif√≠ciles de comprender y puede que a m√°s de uno le haya causado uno que otro dolor de cabeza, üò≤es por ello que en esta ocasi√≥n me gustar√≠a que explicaremos en detalle qu√© es una clase abstracta, qu√© es una interfaz, en qu√© caso son buenos utilizarlos y por su puesto, cual es la diferencia entre uno y otro. Bien, una vez dicho todo esto comencemos. source: imgur.com CLASES ABSTRACTAS Comencemos hablando de clases abstractas. Habr√° ocasiones en las cuales necesitemos crear una clase padre donde √∫nicamente coloquemos la estructura de una abstracci√≥n, una estructura muy general, dejando que sean las clases hijas quienes definan los detalles. En estos casos haremos uso de las clases abstractas. Una clase abstracta es practicamente identica a una clase convencional; las clases abstractas pueden poseer atributos, m√©todos, constructores, etc ... La principal diferencia entre una clases convencional y una clase abstracta es que la clase abstracta debe poseer por lo menos un m√©todo abstracto. Ok, pero ahora, ¬ø Qu√© es un m√©todo abstracto? Ver√°s, un m√©todo abstracto no es m√°s que un m√©todo vac√≠o, un m√©todo el cual no posee cuerpo, por ende no puede realizar ninguna acci√≥n. La utilidad de un m√©todo abstracto es definir qu√© se debe hacer pero no el c√≥mo se debe hacer. Veamos un ejemplo para que nos quede m√°s en claro. public class Figura { private int numeroLados; public Figura() { this.numeroLados = 0; } public float area() { return 0f; } } En este caso la clase posee una atributo, un constructor y un m√©todo, a partir de esta clase podr√© generar la n cantidad de figuras que necesite, ya sean cuadrados, rectangulos, triangulos, circulos etc... Dentro de la clase encontramos el m√©todo √°rea, m√©todo que se encuentra pensado para obtener el √°rea de cualquier figura, sin embargo c√≥mo sabemos todas las figuras poseen su propia f√≥rmula matem√°tica para calcular su √°rea. Si yo comienzo a heredar de la clase Figura todas las clases hijas tendr√≠an que sobre escribir el m√©todo √°rea e implementar su propia formula para as√≠ poder calcular su √°rea. En estos casos, en los casos la clase hija siempre deba que sobreescribir el m√©todo lo que podemos hacer es convertir al m√©todo convencional en un m√©todo abstracto, un m√©todo que defina qu√© hacer, pero no c√≥mo se deba hacer. üòÉ public abstract float area(); Ahora que el m√©todo √°rea es un m√©todo abstracto la clase se convierte en una clase abstracta. public abstract class Figura { Es importante mencionar que las clases abstractas pueden ser heredadas por la n cantidad de clases que necesitemos, pero no pueden ser instanciadas. Para heredar de una clase abstracta basta con utilizar la palabra reservada extends. public class Triangulo extends Figura { Al nosotros heredar de una clase abstracta es obligatorio implementar todos sus m√©todos abstractos, es decir debemos definir comportamiento, definir c√≥mo se va a realizar la tarea. INTERFACES Ahora hablaremos de interfaces. A pesar que es un tema un poco complejo si nosotros hemos comprendido el tema de clases abstractas y el por que de ellas, el tema de interfaces ser√° un tema muy sencillo. Veamos. A diferencia de otros lenguajes de programaci√≥n, en Java no es posible la herencia m√∫ltiple, nuestras clases √∫nicamente podr√°n heredar de una y solo una clase. Si conceptualizamos esto una representaci√≥n pudiese ser la siguiente. source: imgur.com El nivel de jerarqu√≠a es descendente. Esto sin duda funciona, sin embargo, si queremos representar conceptos de la vida real necesitaremos una jerarqu√≠a mucho m√°s compleja, algo como esto. source: imgur.com Para que podamos diagramar nuestro proyecto de esta forma, teniendo en cuenta que √∫nicamente es posible heredar de una clase, entonces haremos uso de interfaces. Podemos definir a una interfaz como una colecci√≥n de m√©todos abstractos y propiedades constantes en las que se especifica que se debe de hacer pero no como, ser√°n las clases hijas quienes definan el comportamiento. A diferencia de una clase abstracta, una interface no puede hacer nada por s√≠ sola, es pr√°cticamente un contrato, en donde las clases que la implementen deben, obligatoriamente, definir el comportamiento de todos los m√©todos abstractos, contestando a la pregunta ¬øC√≥mo se debe hacer? Veamos un ejemplo de una interfaz. public interface Canino { public abstract void aullar(); public abstract void ladrar(); } C√≥mo podemos observar en la interfaz solo encontraremos m√©todos abstractos, m√©todo vac√≠os. Para poder implementar la interfaz basta con utilizar la palabra reservada implements. public class Perro implements Canino { Si bien es cierto que en versiones actuales de Java podemos encontrar los m√©todos default en las interfaces, m√©todos que nos permite definir comportamientos, en esencia las interfaces ser√°n contratos que indicar√°n que es lo que se debe hacer sin proveer ninguna funcionalidad. Otra diferencia entre una clase abstracta y una interface recae en su implementaci√≥n ya que una clase hija solo podr√° heredar de una clase abstracta, por otro lado podr√° hacer uso de la n cantidad de interfaces que necesite. public class Perro extends Canino implementes Mascota CONCLUSI√ìN En conclusi√≥n un m√©todo abstracto no es m√°s que un m√©todo vac√≠o el cual resuelve la pregunta ¬øQu√© se debe hacer? pero no el ¬øC√≥mo se deba hacer? ya que ser√°n las clases hijas quienes definan el comportamiento. Los m√©todos abstractos podemos encontrarlos en dos entidades, las clases abstractas y las interfaces. Una clase abstracta no es m√°s que una clase com√∫n la cual posee atributos, m√©todos, constructores y por lo menos un m√©todo abstracto. Una clase abstracta no puede ser instanciada, solo heredada. C√≥mo Java no permite la herencia m√∫ltiple habr√° ocasiones en las cuales debamos utilizar interfaces, las cuales podemos verlas como contratos, contratos donde est√° muy bien establecido que debe hacer la clase que la implementa."
    },

    {
        "id": 86,
        "autor": "Alex Rodr√≠guez",
        "pagina": "aprenderaprogramar",
        "fecha": "0/0/0",
        "titulo": "Clases y m√©todos abstractos en Java. Abstract class. Clases del api. Ejemplos c√≥digo y ejercicios. ",
        "link": "https://www.aprenderaprogramar.com/index.php?option=com_content&view=article&id=668:clases-y-metodos-abstractos-en-java-abstract-class-clases-del-api-ejemplos-codigo-y-ejercicios-cu00695b&catid=68&Itemid=188",
        "contenido": "CLASES Y M√âTODOS ABSTRACTOS EN JAVA. Supongamos un esquema de herencia que consta de la clase Profesor de la que heredan ProfesorInterino y ProfesorTitular. Es posible que todo profesor haya de ser o bien ProfesorInterino o bien ProfesorTitular, es decir, que no vayan a existir instancias de la clase Profesor. Entonces, ¬øqu√© sentido tendr√≠a tener una clase Profesor? El sentido est√° en que una superclase permite unificar campos y m√©todos de las subclases, evitando la repetici√≥n de c√≥digo y unificando procesos. Ahora bien, una clase de la que no se tiene intenci√≥n de crear objetos, sino que √∫nicamente sirve para unificar datos u operaciones de subclases, puede declararse de forma especial en Java: como clase abstracta. La declaraci√≥n de que una clase es abstracta se hace con la sintaxis public abstract class NombreDeLaClase { ‚Ä¶ }. Por ejemplo public abstract class Profesor. Cuando utilizamos esta sintaxis, no resulta posible instanciar la clase, es decir, no resulta posible crear objetos de ese tipo. Sin embargo, sigue funcionando como superclase de forma similar a como lo har√≠a una superclase ‚Äúnormal‚Äù. La diferencia principal radica en que no se pueden crear objetos de esta clase. Declarar una clase abstracta es distinto a tener una clase de la que no se crean objetos. En una clase abstracta, no existe la posibilidad. En una clase normal, existe la posibilidad de crearlos aunque no lo hagamos. El hecho de que no creemos instancias de una clase no es suficiente para que Java considere que una clase es abstracta. Para lograr esto hemos de declarar expl√≠citamente la clase como abstracta mediante la sintaxis que hemos indicado. Si una clase no se declara usando abstract se cataloga como ‚Äúclase concreta‚Äù. En ingl√©s abstract significa ‚Äúresumen‚Äù, por eso en algunos textos en castellano a las clases abstractas se les llama res√∫menes. Una clase abstracta para Java es una clase de la que nunca se van a crear instancias: simplemente va a servir como superclase a otras clases. No se puede usar la palabra clave new aplicada a clases abstractas. En el men√∫ contextual de la clase en BlueJ simplemente no aparece, y si intentamos crear objetos en el c√≥digo nos saltar√° un error. A su vez, las clases abstractas suelen contener m√©todos abstractos: la situaci√≥n es la misma. Para que un m√©todo se considere abstracto ha de incluir en su signatura la palabra clave abstract. Adem√°s un m√©todo abstracto tiene estas peculiaridades: a) No tiene cuerpo (llaves): s√≥lo consta de signatura con par√©ntesis. b) Su signatura termina con un punto y coma. c) S√≥lo puede existir dentro de una clase abstracta. De esta forma se evita que haya m√©todos que no se puedan ejecutar dentro de clases concretas. Visto de otra manera, si una clase incluye un m√©todo abstracto, forzosamente la clase ser√° una clase abstracta. d) Los m√©todos abstractos forzosamente habr√°n de estar sobreescritos en las subclases. Si una subclase no implementa un m√©todo abstracto de la superclase tiene un m√©todo no ejecutable, lo que la fuerza a ser una subclase abstracta. Para que la subclase sea concreta habr√° de implementar m√©todos sobreescritos para todos los m√©todos abstractos de sus superclases. Un m√©todo abstracto para Java es un m√©todo que nunca va a ser ejecutado porque no tiene cuerpo. Simplemente, un m√©todo abstracto referencia a otros m√©todos de las subclases. ¬øQu√© utilidad tiene un m√©todo abstracto? Podemos ver un m√©todo abstracto como una palanca que fuerza dos cosas: la primera, que no se puedan crear objetos de una clase. La segunda, que todas las subclases sobreescriban el m√©todo declarado como abstracto. Sintaxis tipo: abstract public/private/protected TipodeRetorno/void ( par√°metros        ‚Ä¶   ); Por ejemplo: abstract public void generarNomina (int diasCotizados, boolean plusAntiguedad); Que un m√©todo sea abstracto tiene otra implicaci√≥n adicional: que podamos invocar el m√©todo abstracto sobre una variable de la superclase que apunta a un objeto de una subclase de modo que el m√©todo que se ejecute sea el correspondiente al tipo din√°mico de la variable. En cierta manera, podr√≠amos verlo como un m√©todo sobreescrito para que Java comprenda que debe buscar din√°micamente el m√©todo adecuado seg√∫n la subclase a la que apunte la variable. ¬øEs necesario que una clase que tiene uno o m√°s m√©todos abstractos se defina como abstracta? S√≠, si declaramos un m√©todo abstracto el compilador nos obliga a declarar la clase como abstracta porque si no lo hici√©ramos as√≠ tendr√≠amos un m√©todo de una clase concreta no ejecutable, y eso no es admitido por Java. ¬øUna clase se puede declarar como abstracta y no contener m√©todos abstractos? S√≠, una clase puede ser declarada como abstracta y no contener m√©todos abstractos. En algunos casos la clase abstracta simplemente sirve para efectuar operaciones comunes a subclases sin necesidad de m√©todos abstractos. En otros casos s√≠ se usar√°n los m√©todos abstractos para referenciar operaciones en la clase abstracta al contenido de la sobreescritura en las subclases. ¬øUna clase que hereda de una clase abstracta puede ser no abstracta? S√≠, de hecho esta es una de las razones de ser de las clases abstractas. Una clase abstracta no puede ser instanciada, pero pueden crearse subclases concretas sobre la base de una clase abstracta, y crear instancias de estas subclases. Para ello hay que heredar de la clase abstracta y anular los m√©todos abstractos, es decir, implementarlos. Vamos a ver un ejemplo basado en el siguiente esquema: clase abstracta java En este diagrama de clases vemos c√≥mo hemos definido una clase abstracta denominada Profesor. BlueJ la identifica se√±alando <<abstract>> en la parte superior del icono de la clase. Sin embargo, hereda de la clase Persona que no es abstracta, lo cual significa que puede haber instancias de Persona pero no de Profesor. El test que hemos dise√±ado se basa en lo siguiente: ProfesorTitular y ProfesorInterino son subclases de la clase abstracta Profesor. ListinProfesores sirve para crear un ArrayList de profesores que pueden ser tanto interinos como titulares y realizar operaciones con esos conjuntos. El list√≠n se basa en el tipo est√°tico Profesor, pero su contenido din√°mico siempre ser√° a base de instancias de ProfesorTitular o de ProfesorInterino ya que Profesor es una clase abstracta, no instanciable. En la clase de test creamos profesores interinos y profesores titulares y los vamos a√±adiendo a un list√≠n. Posteriormente, invocamos el m√©todo imprimirListin, que se basa en los m√©todos toString de las subclases y de sus superclases mediante invocaciones sucesivas a super. Por otro lado, en la clase ListinProfesores hemos definido el m√©todo importeTotalNominaProfesorado() que se basa en un bucle que calcula la n√≥mina de todos los profesores que haya en el list√≠n (sean interinos o titulares) mediante el uso de un m√©todo abstracto: importeNomina(). Este m√©todo est√° definido como abstract public float importeNomina (); dentro de la clase abstracta profesor, e implementado en las clases ProfesorInterino y ProfesorTitular. El aspecto central de este ejemplo es comprobar c√≥mo una clase abstracta como Profesor nos permite realizar operaciones conjuntas sobre varias clases, ahorrando c√≥digo y ganando en claridad para nuestros programas. Escribe este c√≥digo: public class Persona { //C√≥digo de la clase Persona ejemplo aprenderaprogramar.com private String nombre; private String apellidos; private int edad; public Persona() { nombre =   ; apellidos =   ; edad = 0; } public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad; } public String getNombre() { return nombre;  } public String getApellidos() { return apellidos;  } public int getEdad() { return edad;  } public String toString() {   Integer datoEdad = edad; return  -Nombre:  .concat(nombre).concat(  -Apellidos:  ).concat(apellidos).concat(  -Edad:  ).concat(datoEdad.toString() ); } } //Cierre de la clase En la clase Persona transformamos edad en un Integer para poder aplicarle el m√©todo toString(). De otra manera no podemos hacerlo por ser edad un tipo primitivo. Escribe este c√≥digo: public abstract class Profesor extends Persona { // Campo de la clase ejemplo aprenderaprogramar.com private String IdProfesor; // Constructores public Profesor () { super();         IdProfesor =  Unknown ;   } public Profesor (String nombre, String apellidos, int edad, String id) { super(nombre, apellidos, edad);   IdProfesor = id; } // M√©todos public void setIdProfesor (String IdProfesor) { this.IdProfesor = IdProfesor;   } public String getIdProfesor () { return IdProfesor;   } public void mostrarDatos() { System.out.println ( Datos Profesor. Profesor de nombre:   + getNombre() +     + getApellidos() +   con Id de profesor:   + getIdProfesor() );   } public String toString () { return super.toString().concat(  -IdProfesor:  ).concat(IdProfesor); } abstract public float importeNomina ();  // M√©todo abstracto } //Cierre de la clase Hemos declarado la clase Profesor como abstracta. De hecho, tenemos un m√©todo abstracto (definido como abstract y sin cuerpo), lo cual de facto nos obliga a declarar la clase como abstracta. El m√©todo sobreescrito toString llama al m√©todo toString de la superclase y lo concatena con nuevas cadenas. Como clases que heredan de Profesor tenemos a ProfesorTitular y ProfesorInterino: public class ProfesorTitular extends Profesor { // Constructor ejemplo aprenderaprogramar.com public ProfesorTitular(String nombre, String apellidos, int edad, String id) { super(nombre, apellidos, edad, id); } public float importeNomina () { return 30f * 43.20f; }  //M√©todo abstracto sobreescrito en esta clase } //Cierre de la clase import java.util.Calendar; public class ProfesorInterino extends Profesor { // Campo de la clase ejemplo aprenderaprogramar.com private Calendar fechaComienzoInterinidad; // Constructores public ProfesorInterino (Calendar fechaInicioInterinidad) { super();      fechaComienzoInterinidad = fechaInicioInterinidad; } public ProfesorInterino (String nombre, String apellidos, int edad, String id, Calendar fechaInicioInterinidad) { super(nombre, apellidos, edad, id); fechaComienzoInterinidad = fechaInicioInterinidad; } public Calendar getFechaComienzoInterinidad () { return fechaComienzoInterinidad; } //M√©todo public String toString () { // Sobreescritura del m√©todo return super.toString().concat (  Fecha comienzo interinidad:  ).concat (fechaComienzoInterinidad.getTime().toString()); } public float importeNomina () { return 30f * 35.60f ; } //M√©todo abstracto sobreescrito en esta clase } //Cierre de la clase import java.util.ArrayList; import java.util.Iterator; public class ListinProfesores { private ArrayList <Profesor> listinProfesores; //Campo de la clase public ListinProfesores () {  listinProfesores = new ArrayList <Profesor> ();  } //Constructor public void addProfesor (Profesor profesor) {  listinProfesores.add(profesor);  } //M√©todo public void imprimirListin() {  //M√©todo String tmpStr1 =   ; //String temporal que usamos como auxiliar System.out.println ( Se procede a mostrar los datos de los profesores existentes en el list√≠n \n ); for (Profesor tmp: listinProfesores) {          System.out.println (tmp.toString () ); if (tmp instanceof ProfesorInterino) { tmpStr1 =  Interino ;} else { tmpStr1 =  Titular ; } System.out.println( -Tipo de este profesor: +tmpStr1+  -N√≥mina de este profesor:  +(tmp.importeNomina())+  \n );} } //Cierre m√©todo imprimirListin public float importeTotalNominaProfesorado() { float importeTotal = 0f; //Variable temporal que usamos como auxiliar Iterator<Profesor> it = listinProfesores.iterator(); while (it.hasNext() ) { importeTotal = importeTotal + it.next().importeNomina(); } return importeTotal; } //Cierre del m√©todo importeTotalNominaProfesorado } //Cierre de la clase ejemplo aprenderaprogramar.com ProfesorTitular y ProfesorInterino se han definido como clases concretas que heredan de la clase abstracta Profesor. Ambas clases redefinen (obligatoriamente han de hacerlo) el m√©todo abstracto importeNomina() de la superclase. El m√©todo sobreescrito toString() de la clase ProfesorInterino llama al m√©todo toString() de la superclase y lo concatena con nuevas cadenas. El c√°lculo de importeNomina en ambas clases es una trivialidad: hemos incluido un c√°lculo sin mayor inter√©s excepto que el de ver el funcionamiento de la implementaci√≥n de m√©todos abstractos. ProfesorTitular lo hemos dejado con escaso contenido porque aqu√≠ lo usamos solo a modo de ejemplo de uso de clases abstractas y herencia. Su √∫nico cometido es mostrar que existe otra subclase de Profesor. Por otro lado, en la clase ListinProfesores tenemos un ejemplo de uso de instanceof para determinar qu√© tipo (ProfesorInterino o ProfesorTitular) es el que porta una variable Profesor. Iteramos con clase declarada Profesor y clases din√°micas ProfesorTitular y ProfesorInterino. Din√°micamente se determina de qu√© tipo es cada objeto y al invocar el m√©todo abstracto importeNomina() Java determina si debe utilizar el m√©todo propio de un subtipo u otro. En imprimirListin llegamos incluso a mostrar por pantalla de qu√© tipo es cada objeto usando la sentencia instanceof para determinarlo. Escribe y ejecuta el c√≥digo del test: import java.util.Calendar; //Ejemplo aprenderaprogramar.com public class TestAbstract { public static void main (String [ ] Args) { Calendar fecha1 = Calendar.getInstance(); fecha1.set(2019,10,22); //Los meses van de 0 a 11, luego 10 representa noviembre ProfesorInterino pi1 = new ProfesorInterino( Jos√© ,  Hern√°ndez L√≥pez , 45,  45221887-K , fecha1); ProfesorInterino pi2 = new ProfesorInterino( Andr√©s ,  Molt√≥ Parra , 87,  72332634-L , fecha1); ProfesorInterino pi3 = new ProfesorInterino ( Jos√© ,  R√≠os Mesa , 76,  34998128-M , fecha1); ProfesorTitular pt1 = new ProfesorTitular ( Juan ,  P√©rez P√©rez , 23,  73-K ); ProfesorTitular pt2 = new ProfesorTitular ( Alberto ,  Centa Mota , 49,  88-L ); ProfesorTitular pt3 = new ProfesorTitular ( Alberto ,  Centa Mota , 49,  81-F ); ListinProfesores listinProfesorado = new ListinProfesores (); listinProfesorado.addProfesor (pi1); listinProfesorado.addProfesor(pi2); listinProfesorado.addProfesor (pi3); listinProfesorado.addProfesor (pt1); listinProfesorado.addProfesor(pt2); listinProfesorado.addProfesor (pt3); listinProfesorado.imprimirListin(); System.out.println ( El importe de las n√≥minas del profesorado que consta en el list√≠n es   + listinProfesorado.importeTotalNominaProfesorado()+   euros ); }  }   //Cierre del main y cierre de la clase Comprueba el resultado de ejecuci√≥n. El resultado del test nos muestra que operamos exitosamente sobre las dos clases usando abstracci√≥n: Se procede a mostrar los datos de los profesores existentes en el list√≠n -Nombre: Jos√© -Apellidos: Hdez L√≥pez -Edad: 45 -IdProfesor: 45221887-K Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -N√≥mina de este profesor: 1068.0 -Nombre: Andr√©s -Apellidos: Mlt√≥ Parra -Edad: 87 -IdProfesor: 72332634-L Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -N√≥mina de este profesor: 1068.0 -Nombre: Jos√© -Apellidos: R√≠os Mesa -Edad: 76 -IdProfesor: 34998128-M Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -N√≥mina de este profesor: 1068.0 -Nombre: Juan -Apellidos: P√©rez P√©rez -Edad: 23 -IdProfesor: 73-K -Tipo de este profesor: Titular -N√≥mina de este profesor: 1296.0 -Nombre: Alberto -Apellidos: Centa Mota -Edad: 49 -IdProfesor: 88-L -Tipo de este profesor: Titular -N√≥mina de este profesor: 1296.0 -Nombre: Alberto -Apellidos: Centa Mota -Edad: 49 -IdProfesor: 81-F -Tipo de este profesor: Titular -N√≥mina de este profesor: 1296.0 El importe de las n√≥minas del profesorado que consta en el list√≠n es 7092.0 euros CLASES ABSTRACTAS EN EL API DE JAVA Java utiliza clases abstractas en el API de la misma forma que podemos nosotros usarlas en nuestros programas. Por ejemplo, la clase AbstractList del paquete java.util es una clase abstracta con tres subclases: clases abstractas api java Como vemos, entre las subclases dos de ellas son concretas mientras que una todav√≠a es abstracta. En una clase como AbstractList algunos m√©todos son abstractos, lo que obliga a que el m√©todo est√© sobreescrito en las subclases, mientras que otros m√©todos no son abstractos. Sobre un objeto de una subclase, llamar a un m√©todo puede dar lugar a: a) La ejecuci√≥n del m√©todo tal y como est√© definido en la subclase. b) La b√∫squeda del m√©todo ascendiendo por las superclases hasta que se encuentra y puede ser ejecutado. Es lo que ocurrir√° por ejemplo con toString() si no est√° definido en la subclase."
    },

    {
        "id": 87,
        "autor": "arkaitzgarro",
        "pagina": "arkaitzgarro",
        "fecha": "0/0/0",
        "titulo": "CAP√çTULO 18 INTERFACES",
        "link": "https://www.arkaitzgarro.com/java/capitulo-18.html",
        "contenido": "Una interfaz es una especie de plantilla para la construcci√≥n de clases. Normalmente una interfaz se compone de un conjunto de declaraciones de cabeceras de m√©todos (sin implementar, de forma similar a un m√©todo abstracto) que especifican un protocolo de comportamiento para una o varias clases. Adem√°s, una clase puede implementar una o varias interfaces: en ese caso, la clase debe proporcionar la declaraci√≥n y definici√≥n de todos los m√©todos de cada una de las interfaces o bien declararse como clase abstract. Por otro lado, una interfaz puede emplearse tambi√©n para declarar constantes que luego puedan ser utilizadas por otras clases. Una interfaz puede parecer similar a una clase abstracta, pero existen una serie de diferencias entre una interfaz y una clase abstracta: Todos los m√©todos de una interfaz se declaran impl√≠citamente como abstractos y p√∫blicos. Una clase abstracta no puede implementar los m√©todos declarados como abstractos, una interfaz no puede implementar ning√∫n m√©todo (ya que todos son abstractos). Una interfaz no declara variables de instancia. Una clase puede implementar varias interfaces, pero s√≥lo puede tener una clase ascendiente directa. Una clase abstracta pertenece a una jerarqu√≠a de clases mientras que una interfaz no pertenece a una jerarqu√≠a de clases. En consecuencia, clases sin relaci√≥n de herencia pueden implementar la misma interfaz. 18.1 DECLARACI√ìN DE UNA INTERFAZ La declaraci√≥n de una interfaz es similar a una clase, aunque emplea la palabra reservada interface en lugar de class y no incluye ni la declaraci√≥n de variables de instancia ni la implementaci√≥n del cuerpo de los m√©todos (s√≥lo las cabeceras). La sintaxis de declaraci√≥n de una interfaz es la siguiente: public interface IdentificadorInterfaz { // Cuerpo de la interfaz ... } Una interfaz declarada como public debe ser definida en un archivo con el mismo nombre de la interfaz y con extensi√≥n .java. Las cabeceras de los m√©todos declarados en el cuerpo de la interfaz se separan entre s√≠ por caracteres de punto y coma y todos son declarados impl√≠citamente como public y abstract (se pueden omitir). Por su parte, todas las constantes incluidas en una interfaz se declaran impl√≠citamente como public, static y final (tambi√©n se pueden omitir) y es necesario inicializarlas en la misma sentencia de declaraci√≥n. Por ejemplo, la interfaz Modificacion declara la cabecera de un √∫nico m√©todo: /** * Declaracion de la interfaz Modificacion */ public interface Modificacion { void incremento(int a); } que se almacena en el archivo fuente Modificacion.java y que, al compilarse: $>javac Modificacion.java genera un archivo Modificacion.class. Al no corresponder a una clase que implementa un m√©todo main, este archivo no puede ejecutarse con el int√©rprete de Java. Segundo ejemplo: la interfaz constantes declara dos constantes reales con el siguiente c√≥digo fuente: /** * Declaracion de la interfaz Constantes */ public interface Constantes { double VALOR_MAXIMO = 10000000.0; double VALOR_MINIMO = -0.01; } que se almacena en el archivo fuente Constantes.java y que, al compilarse, genera un archivo Constantes.class Tercer ejemplo: la interfaz Numerico declara una constante real y dos cabeceras de m√©todos con el siguiente c√≥digo fuente: /** * Declaracion de la interfaz Numerico */ public interface Numerico { double EPSILON = 0.000001; void establecePrecision(float p); void estableceMaximo(float m); } que se almacena en el archivo fuente Numerico.java y que, al compilarse, genera un archivo Numerico.class. 18.2 IMPLEMENTACI√ìN DE UNA INTERFAZ EN UNA CLASE Para declarar una clase que implemente una interfaz es necesario utilizar la palabra reservada implements en la cabecera de declaraci√≥n de la clase. Las cabeceras de los m√©todos (identificador y n√∫mero y tipo de par√°metros) deben aparecer en la clase tal y como aparecen en la interfaz implementada. Por ejemplo, la clase Acumulador implementa la interfaz Modificacion y por lo tanto debe declarar un m√©todo incremento: /** * Declaracion de la clase Acumulador */ public class Acumulador implements Modificacion { private int valor; public Acumulador (int i) { this.valor = i; } public int daValor () { return this.valor; } public void incremento (int a) { this.valor += a; } } Esta cabecera con la palabra implements... implica la obligaci√≥n de la clase Acumulador de definir el m√©todo incremento declarado en la interfaz Modificacion. El siguiente c√≥digo muestra un ejemplo de uso de la clase Acumulador. /** * Demostracion de la clase Acumulador */ public class PruebaAcumulador { public static void main (String [] args) { Acumulador p = new Acumulador(25); p.incremento(12); System.out.println(p.daValor()); } } La compilaci√≥n y posterior ejecuci√≥n del c√≥digo anterior origina la siguiente salida por pantalla: $>javac PruebaAcumulador.java $>java PruebaAcumulador 37 La clase Acumulador tendr√≠a tambi√©n la posibilidad de utilizar directamente las constantes declaradas en la interfaz si las hubiera. Para poder emplear una constante declarada en una interfaz, las clases que no implementen esa interfaz deben anteponer el identificador de la interfaz al de la constante. 18.3 JERARQU√çA ENTRE INTERFACES La jerarqu√≠a entre interfaces permite la herencia simple y m√∫ltiple. Es decir, tanto la declaraci√≥n de una clase, como la de una interfaz pueden incluir la implementaci√≥n de otras interfaces. Los identificadores de las interfaces se separan por comas. Por ejemplo, la interfaz Una implementa otras dos interfaces: Dos y Tres. public interface Una implements Dos, Tres { // Cuerpo de la interfaz ... } Las clases que implementan la interfaz Una tambi√©n lo hacen con Dos y Tres. Otro ejemplo: pueden construirse dos interfaces, Constantes y Variaciones, y una clase, Factura, que las implementa: // Declaracion de la interfaz Constantes public interface Constantes { double valorMaximo = 10000000.0; double valorMinimo = -0.01; } // Declaracion de la interfaz Variaciones public interface Variaciones { void asignaValor(double x); void rebaja(double t); } // Declaracion de la clase Factura public class Factura implements Constantes, Variaciones { private double totalSinIVA; public final static double IVA = 0.16; public double sinIVA() { return this.totalSinIVA; } public double conIVA() { return this.totalSinIVA * (1+IVA); } public void asignaValor(double x) { if (this.valorMinimo<x) this.totalSinIVA=x; else this.totalSinIVA=0; } public void rebaja(double t) { this.totalSinIVA *= (1-t/100); } public static void main (String [] args) { factura a = new Factura(); a.asignaValor(250.0); System.out.println( El precio sin IVA es:   + a.sinIVA()); System.out.println( El precio con IVA es:   + a.conIVA()); System.out.println( Rebajado durante el mes de mayo un 20% ); a.rebaja(20); System.out.println( Rebajado sin IVA es:   + a.sinIVA()); System.out.println( Rebajado con IVA es:   + a.conIVA()); } } Si una interfaz implementa otra, incluye todas sus constantes y declaraciones de m√©todos, aunque puede redefinir tanto constantes como m√©todos. Importante: Es peligroso modificar una interfaz ya que las clases dependientes dejan de funcionar hasta que √©stas implementen los nuevos m√©todos. Una clase puede simult√°neamente descender de otra clase e implementar una o varias interfaces. En este caso la seccion implements se coloca a continuaci√≥n de extends en la cabecera de declaraci√≥n de la clase. Por ejemplo: public class ClaseDescendiente extends ClaseAscendiente implements Interfaz { ... } 18.4 UTILIZACI√ìN DE UNA INTERFAZ COMO UN TIPO DE DATO Al declarar una interfaz, se declara un nuevo tipo de referencia. Pueden emplearse identificadores de interfaz en cualquier lugar donde se pueda utilizar el identificador de un tipo de dato (o de una clase). El objetivo es garantizar la sustituibilidad por cualquier instancia de una clase que la implemente. Por ejemplo, puede emplearse como tipo de un par√°metro de un m√©todo: public class Calculos { public void asignacion(Variaciones x); { ... } } S√≥lo una instancia de una clase que implemente la interfaz puede asignarse al par√°metro cuyo tipo corresponde al identificador de la interfaz. Esta facultad se puede aprovechar dentro la propia interfaz. Por ejemplo: public interface Comparable { // La instancia que llama a esMayor (this) y el parametro otra // deben ser de la misma clase o de clases que implementen esta interfaz // La funcion devuelve 1, 0, -1 si this es mayor, igual o menor que otra public int esMayor(Comparable otra); } En alg√∫n caso puede ser √∫til declarar una interfaz vac√≠a como, por ejemplo: public interface Marcador { } Esta declaraci√≥n es totalmente v√°lida ya que no es obligatorio incluir dentro de una interfaz la declaraci√≥n de una constante o la cabecera de un m√©todo. La utilidad de estas interfaces reside en la posibilidad de ser empleadas como tipos de dato para especificar clases sin necesidad de obligar a √©stas a implementar alg√∫n m√©todo en concreto. Una interfaz no es una clase pero se considera un tipo en Java y puede ser utilizado como tal."
    },

    {
        "id": 88,
        "autor": "Alex Walton ",
        "pagina": "javadesdecero",
        "fecha": "7/05/2020",
        "titulo": "Interfaces en Java con Ejemplos",
        "link": "https://javadesdecero.es/intermedio/interfaces-ejemplos/",
        "contenido": "En la programaci√≥n orientada a objetos, a veces es √∫til definir qu√© debe hacer una clase, pero no c√≥mo lo har√°. Ya has visto un ejemplo de esto: el m√©todo abstract. Un m√©todo abstracto define la firma de un m√©todo pero no proporciona ninguna implementaci√≥n. Una subclase debe proporcionar su propia implementaci√≥n de cada m√©todo abstracto definido por su superclase. Por lo tanto, un m√©todo abstracto especifica la interfaz para el m√©todo pero no la implementaci√≥n. Si bien las clases y m√©todos abstractos son √∫tiles, es posible llevar este concepto un paso m√°s all√°. En Java, puede separar por completo la interfaz de una clase de su implementaci√≥n utilizando la palabra clave . Table de Contenido 1. Qu√© es una interface en Java 2. interface en el nuevo JDK 3. Implementaci√≥n de interfaces 4. Uso de referencias a interface 5. Variables en interfaces 6. Las interfaces pueden ser extendidas 1. Qu√© es una interface en Java Una interfaz () es sint√°cticamente similar a una clase abstracta, en la que puede especificar uno o m√°s m√©todos que no tienen cuerpo ({}). Esos m√©todos deben ser implementados por una clase para que se definan sus acciones. Por lo tanto, una interfaz especifica qu√© se debe hacer, pero no c√≥mo hacerlo. Una vez que se define una interfaz, cualquier cantidad de clases puede implementarla. Adem√°s, una clase puede implementar cualquier cantidad de interfaces. Para implementar una interfaz, una clase debe proporcionar cuerpos (implementaciones) para los m√©todos descritos por la interfaz. Cada clase es libre de determinar los detalles de su propia implementaci√≥n. Dos clases pueden implementar la misma interfaz de diferentes maneras, pero cada clase a√∫n admite el mismo conjunto de m√©todos. Por lo tanto, el c√≥digo que tiene conocimiento de la interfaz puede usar objetos de cualquier clase, ya que la interfaz con esos objetos es la misma. √óAl proporcionar la palabra clave interface, Java le permite utilizar completamente el aspecto de ‚Äúuna interfaz, m√∫ltiples m√©todos‚Äù del polimorfismo. 2. interface en el nuevo JDK Antes de continuar, se necesita hacer un punto importante. JDK 8 agreg√≥ una funci√≥n a interface que hizo un cambio significativo en sus capacidades. Antes de JDK 8, una interfaz no pod√≠a definir ninguna implementaci√≥n de ning√∫n tipo. Por lo tanto, antes de JDK 8, una interfaz podr√≠a definir solo el qu√©, pero no el c√≥mo, como se acaba de describir. JDK 8 cambi√≥ esto. Hoy, es posible agregar una implementaci√≥n predeterminada a un m√©todo de interfaz. Adem√°s, ahora se admiten los m√©todos de interfaz est√°tica y, a partir de JDK 9, una interfaz tambi√©n puede incluir m√©todos privados. Por lo tanto, ahora es posible que la interfaz especifique alg√∫n comportamiento. Sin embargo, tales m√©todos constituyen lo que son, en esencia, caracter√≠sticas de uso especial, y la intenci√≥n original detr√°s de la interfaz a√∫n permanece. Por lo tanto, como regla general, con frecuencia crear√° y utilizar√° interfaces en las que no se utilizar√°n estas nuevas funciones. Por esta raz√≥n, comenzaremos discutiendo la interfaz en su forma tradicional. Las nuevas funciones de la interfaz se describen m√°s adelante. Aqu√≠ hay una forma general simplificada de una interfaz tradicional: acceso interface nombre { tipo-retorno metodo-nombre1(lista-parametros); tipo-retorno metodo-nombre2(lista-parametros); tipo var1 = valor; tipo var2 = valor; // ... tipo-retorno metodo-nombreN(lista-parametros); tipo varN = valor; } Para una interfaz de nivel superior, acceso es public o no se usa. Cuando no se incluye ning√∫n modificador de acceso, los resultados de acceso predeterminados y la interfaz solo est√°n disponibles para otros miembros de su paquete. Si se declara como public, la interfaz puede ser utilizada por cualquier otro c√≥digo. (Cuando una interfaz se declara public,, debe estar en un archivo del mismo nombre.) nombre es el nombre de la interfaz y puede ser cualquier identificador v√°lido. En la forma tradicional de una interfaz, los m√©todos se declaran utilizando solo su tipo de devoluci√≥n y firma. Son, esencialmente, m√©todos abstractos. Por lo tanto, cada clase que incluye dicha interfaz debe implementar todos sus m√©todos. En una interfaz, los m√©todos son impl√≠citamente p√∫blicos. Las variables declaradas en una interfaz no son variables de instancia. En cambio, son impl√≠citamente public, final, y static, y deben inicializarse. Por lo tanto, son esencialmente constantes. Aqu√≠ hay un ejemplo de una definici√≥n de interfaz. Especifica la interfaz a una clase que genera una serie de n√∫meros. public interface Series { int getSiguiente(); //Retorna el siguiente n√∫mero de la serie void reiniciar(); //Reinicia void setComenzar(int x); //Establece un valor inicial } Esta interfaz se declara p√∫blica para que pueda ser implementada por c√≥digo en cualquier paquete. 3. Implementaci√≥n de interfaces Una vez que se ha definido una interfaz, una o m√°s clases pueden implementar esa interfaz. Para implementar una interfaz, incluya la cl√°usula  en una definici√≥n de clase y luego cree los m√©todos requeridos por la interfaz. La forma general de una clase que incluye la cl√°usula de implements se ve as√≠: class nombreclase extends superclase implements interface { // cuerpo-clase } Para implementar m√°s de una interfaz, las interfaces se separan con una coma. √óPor supuesto, la cl√°usula extends es opcional. Los m√©todos que implementan una interfaz deben declararse p√∫blicos. Adem√°s, la firma de tipo del m√©todo de implementaci√≥n debe coincidir exactamente con la firma de tipo especificada en la definici√≥n de la interfaz. Aqu√≠ hay un ejemplo que implementa la interfaz de Series mostrada anteriormente. Crea una clase llamada DeDos, que genera una serie de n√∫meros, cada uno mayor que el anterior. class DeDos implements Series { int iniciar; int valor; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=2; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } Observe que los m√©todos getSiguiente(), reiniciar() y setComenzar() se declaran utilizando el especificador de acceso p√∫blico (). Esto es necesario. Siempre que implemente un m√©todo definido por una interfaz, debe implementarse como p√∫blico porque todos los miembros de una interfaz son impl√≠citamente p√∫blicos. Aqu√≠ hay una clase que demuestra DeDos: class SeriesDemo { public static void main(String[] args) { DeDos ob=new DeDos(); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); System.out.println( \nReiniciando ); ob.reiniciar(); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); System.out.println( \nIniciando en 100 ); ob.setComenzar(100); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); } } Salida: Siguiente valor es: 2 Siguiente valor es: 4 Siguiente valor es: 6 Siguiente valor es: 8 Siguiente valor es: 10 Reiniciando Siguiente valor es: 2 Siguiente valor es: 4 Siguiente valor es: 6 Siguiente valor es: 8 Siguiente valor es: 10 Iniciando en 100 Siguiente valor es: 102 Siguiente valor es: 104 Siguiente valor es: 106 Siguiente valor es: 108 Siguiente valor es: 110 Es permitido y com√∫n para las clases que implementan interfaces definir miembros adicionales propios. Por ejemplo, la siguiente versi√≥n de DeDos agrega el m√©todo getAnterior(), que devuelve el valor anterior: class DeDos implements Series { int iniciar; int valor; int anterior; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { anterior=valor; valor+=2; return valor; } public void reiniciar() { valor=iniciar; anterior=valor-2; } public void setComenzar(int x) { iniciar=x; valor=x; anterior=x-2; } //A√±adiendo un m√©todo que no est√° definido en Series int getAnterior(){ return anterior; } } Observe que la adici√≥n de getAnterior() requiri√≥ un cambio en las implementaciones de los m√©todos definidos por Series. Sin embargo, dado que la interfaz con esos m√©todos permanece igual, el cambio es continuo y no rompe el c√≥digo preexistente. Esta es una de las ventajas de las interfaces. Como se explic√≥, cualquier cantidad de clases puede implementar una interfaz. Por ejemplo, aqu√≠ hay una clase llamada DeTres que genera una serie que consta de m√∫ltiplos de tres: public class DeTres implements Series{ int iniciar; int valor; DeTres(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=3; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } Un punto m√°s: si una clase incluye una interfaz pero no implementa completamente los m√©todos definidos por esa interfaz, esa clase debe declararse como abstracta (). No se pueden crear objetos de dicha clase, pero se puede usar como una superclase abstracta, lo que permite que las subclases proporcionen la implementaci√≥n completa. 4. Uso de referencias a interface Es posible que se sorprenda al descubrir que puede declarar una variable de referencia de un tipo de interfaz. En otras palabras, puede crear una variable de referencia de interfaz. Dicha variable puede referirse a cualquier objeto que implemente su interfaz. Cuando llama a un m√©todo en un objeto a trav√©s de una referencia de interfaz, es la versi√≥n del m√©todo implementado por el objeto que se ejecuta. Este proceso es similar al uso de una referencia de superclase para acceder a un objeto de subclase. El siguiente ejemplo ilustra este proceso. Utiliza la misma variable de referencia de interfaz para llamar a m√©todos en objetos de DeDos y DeTres. //Demostraci√≥n de referencia de interface class DeDos implements Series { int iniciar; int valor; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=2; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } public class DeTres implements Series{ int iniciar; int valor; DeTres(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=3; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } class SeriesDemo { public static void main(String[] args) { DeDos dosOb=new DeDos(); DeTres tresOb=new DeTres(); Series ob; for (int i=0;i<5;i++) { ob = dosOb; System.out.println( Siguiente valor DeDos es:   + ob.getSiguiente()); ob = tresOb; System.out.println( Siguiente valor DeTres es:   + ob.getSiguiente()); } } } Salida: Siguiente valor DeDos es: 2 Siguiente valor DeTres es: 3 Siguiente valor DeDos es: 4 Siguiente valor DeTres es: 6 [...] En main(), ob se declara como una referencia a una interfaz de Series. Esto significa que se puede usar para almacenar referencias a cualquier objeto que implemente Series. En este caso, se utiliza para referirse a dosOb y tresOb, que son objetos de tipo DeDos y DeTres, respectivamente, que implementan Series. Una variable de referencia de interfaz solo tiene conocimiento de los m√©todos declarados por su declaraci√≥n de interfaz. Por lo tanto, ob no se podr√≠a usar para acceder a otras variables o m√©todos que puedan ser compatibles con el objeto. 5. Variables en interfaces Como se mencion√≥, las variables se pueden declarar en una interfaz, pero son impl√≠citamente p√∫blicas, est√°ticas y finales (public, static, y final). A primera vista, podr√≠a pensar que habr√≠a un uso muy limitado para tales variables, pero ocurre lo contrario. Los programas grandes normalmente hacen uso de varios valores constantes que describen cosas como el tama√±o de la matriz, diversos l√≠mites, valores especiales y similares. Dado que un programa grande generalmente se mantiene en una cantidad de archivos fuente separados, debe haber una forma conveniente de hacer que estas constantes est√©n disponibles para cada archivo. En Java, las variables de interfaz ofrecen una soluci√≥n. Para definir un conjunto de constantes compartidas, cree una interfaz que contenga solo estas constantes, sin ning√∫n m√©todo. Cada archivo que necesita acceso a las constantes simplemente ‚Äúimplementa‚Äù la interfaz. Esto trae las constantes a la vista. Aqu√≠ hay un ejemplo: //Una interfaz que contiene constantes interface Constante { //Definiendo 3 constantes int MIN=0; int MAX=10; String MSJERROR= LIMITE ERROR ; } class ConstanteD implements Constante{ public static void main(String[] args) { int numeros[]=new int; for (int i=MIN; i<11; i++){ if (i>=MAX) System.out.println(MSJERROR); else { numeros=i; System.out.println(numeros+    ); } } } } La t√©cnica de usar una interfaz para definir constantes compartidas es controvertida. Veremos m√°s ejemplos m√°s adelante. 6. Las interfaces pueden ser extendidas Una interfaz puede heredar otra mediante el uso de la palabra clave extends. La sintaxis es la misma que para heredar clases. Cuando una clase implementa una interfaz que hereda otra interfaz, debe proporcionar implementaciones para todos los m√©todos requeridos por la cadena de herencia de la interfaz. Lo siguiente es un ejemplo: //Una interface puede extender de otra interface A{ void metodo1(); void metodo2(); } //B ahora incluye metodo1() y metodo2() - y a√±ade metodo3() interface B extends A{ void metodo3(); } //Esta clase debe implementar los m√©todos de A y B class MiClase implements B{ public void metodo1() { System.out.println( Implementaci√≥n de metodo1(). ); } public void metodo2() { System.out.println( Implementaci√≥n de metodo2(). ); } public void metodo3() { System.out.println( Implementaci√≥n de metodo3(). ); } } public class Extender { public static void main(String[] args) { MiClase mc=new MiClase(); mc.metodo1(); mc.metodo2(); mc.metodo3(); } } Salida: Implementaci√≥n de metodo1(). Implementaci√≥n de metodo2(). Implementaci√≥n de metodo3(). Como experimento, puede intentar eliminar la implementaci√≥n de metodo1() en MiClase. Esto causar√° un error en tiempo de compilaci√≥n. Como se dijo anteriormente, cualquier clase que implemente una interfaz debe implementar todos los m√©todos requeridos por esa interfaz, incluidos los heredados de otras interfaces."
    },

    {
        "id": 89,
        "autor": "Ricardo Moya",
        "pagina": "jarroba",
        "fecha": "8/04/2014",
        "titulo": "Herencia en Java, con ejemplos",
        "link": "https://jarroba.com/herencia-en-la-programacion-orientada-a-objetos-ejemplo-en-java/",
        "contenido": "La Herencia es uno de los 4 pilares de la programaci√≥n orientada a objetos (POO) junto con la Abstracci√≥n, Encapsulaci√≥n y Polimorfismo. Al principio cuesta un poco entender estos conceptos caracter√≠sticos del paradigma de la POO porque solemos venir de otro paradigma de programaci√≥n como el paradigma de la programaci√≥n estructurada (ver la entrada Paradigmas de Programaci√≥n), pero se ha de decir que la complejidad est√° en entender este nuevo paradigma y no en otra cosa. En esta entrada vamos a explicar de la mejor manera posible que es la herencia y lo vamos a explicar con un ejemplo. Respecto a la herencia se han dado muchas definiciones como por ejemplo la siguiente:  La herencia es un mecanismo que permite la definici√≥n de una clase a partir de la definici√≥n de otra ya existente. La herencia permite compartir autom√°ticamente m√©todos y datos entre clases, subclases y objetos. . As√≠ de primeras esta definici√≥n es un poco dif√≠cil de digerir para aquellos que est√©is empezando con la POO, as√≠ que vamos a intentar digerir esta definici√≥n con un ejemplo en el que veremos que la herencia no es m√°s que un  Copy-Paste Din√°mico  o una forma de  sacar factor com√∫n  al c√≥digo que escribimos. El ejemplo que proponemos es un caso en el que vamos a simular el comportamiento que tendr√≠an los diferentes integrantes de la selecci√≥n espa√±ola de futbol; tanto los Futbolistas como el cuerpo t√©cnico (Entrenadores, Masajistas, etc‚Ä¶). Para simular este comportamiento vamos a definir tres clases que van a representaran a objetos Futbolista, Entrenador y Masajista. De cada unos de ellos vamos a necesitar algunos datos que reflejaremos en los atributos y una serie de acciones que reflejaremos en sus m√©todos. Estos atributos y m√©todos los mostramos en el siguiente diagrama de clases: NoHerencia_jarroba NOTA: en este diagrama y en adelante no vamos a poner los constructores y m√©todos getter y setter con el fin de que el diagrama nos quede grande e  intendible  aunque en un buen diagrama de clases deber√≠an aparecer para respetar el principio de encapsulaci√≥n de la POO Como se puede observar, vemos que en las tres clases tenemos atributos y m√©todos que son iguales ya que los tres tienen los atributos id, Nombre, Apellidos y Edad; y los tres tienen los m√©todos de Viajar y Concentrarse: Herencia_jarroba A nivel de c√≥digo tenemos lo siguiente tras ver el diagrama de clases: public class Futbolista { private int id; private String Nombre; private String Apellidos; private int Edad; private int dorsal; private String demarcacion; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void jugarPartido() { ... } public void entrenar() { ... } } public class Entrenador { private int id; private String Nombre; private String Apellidos; private int Edad; private String idFederacion; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void dirigirPartido() { ... } public void dirigirEntreno() { ... } } public class Masajista { private int id; private String Nombre; private String Apellidos; private int Edad; private String Titulacion; private int aniosExperiencia; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void darMasaje() { ... } } Lo que podemos ver en este punto es que estamos escribiendo mucho c√≥digo repetido ya que las tres clases tienen m√©todos y atributos comunes, de ahi y como veremos enseguida, decimos que la herencia consiste en  sacar factor com√∫n  para no escribir c√≥digo de m√°s, por tanto lo que haremos sera crearnos una clase con el  c√≥digo que es com√∫n a las tres clases  (a esta clase se le denomina en la herencia como  Clase Padre o SuperClase ) y el c√≥digo que es  especifico de cada clase, lo dejaremos en ella, siendo denominadas estas clases como  Clases Hijas , las cuales heredan de la clase padre todos los atributos y m√©todos p√∫blicos o protegidos. Es muy importante decir que las clases hijas no van a heredar nunca los atributos y m√©todos privados de la clase padre, as√≠ que mucho cuidado con esto. En resumen para que ve√°is la ventaja de la herencia, tenemos ahora una clase padre con 'n' lineas de c√≥digo y tres clases hijas con 'a', 'b' y 'c' lineas de c√≥digos respectivamente, por tanto si hech√°is cuentas, hemos reducido nuestro c√≥digo en '2n' l√≠neas menos ya que antes ten√≠amos '(n+a)+(n+b)+(n+c)' l√≠neas de c√≥digo y ahora tras aplicar herencia tenemos 'n+a+b+c' l√≠neas, aunque tambi√©n es cierto que tenemos una clase m√°s, pero veremos un poco m√°s adelante la ventaja de tener esa clase padre. En resumen, al  sacar factor com√∫n  y aplicar herencia, tenemos las siguientes clases: HerenciaV2_jarroba A nivel de c√≥digo, las clases quedar√≠an implementadas de la siguiente forma: public class SeleccionFutbol { protected int id; protected String Nombre; protected String Apellidos; protected int Edad; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } } public class Futbolista extends SeleccionFutbol { private int dorsal; private String demarcacion; public Futbolista() { super(); } // getter y setter public void jugarPartido() { ... } public void entrenar() { ... } } public class Entrenador extends SeleccionFutbol { private String idFederacion; public Entrenador() { super(); } // getter y setter public void dirigirPartido() { ... } public void dirigirEntreno() { ... } } public class Masajista extends SeleccionFutbol { private String Titulacion; private int aniosExperiencia; public Masajista() { super(); } // getter y setter public void darMasaje() { ... } } Como pod√©is observar ahora queda un c√≥digo mucho m√°s limpio, estructurado y con menos l√≠neas de c√≥digo, lo que lo hace m√°s legible, cosa que es muy importante y lo que todav√≠a lo hace m√°s importante es que es un c√≥digo reutilizable, lo que significa que ahora si queremos a√±adir m√°s clases a nuestra aplicaci√≥n como por ejemplo una clase M√©dico, Utiller@, Jefe/a de prensa etc. que pertenezcan tambi√©n al equipo t√©cnico de la selecci√≥n Espa√±ola, lo podemos hacer de forma muy sencilla ya que en la clase padre (SeleccionFutbol) tenemos implementado parte de sus datos y de su comportamiento y solo habr√° que implementar los atributos y m√©todos propios de esa clase. ¬øEmpez√°is a ver la utilidad de la herencia?. Ahora si os hab√©is fijado bien en el c√≥digo que se ha escrito y sino hab√©is tenido experiencia con la herencia en Java, habr√©is podido observar dos palabras reservadas  nuevas  como son  extends ,  protected  y  super . Pues bien, ahora vamos a explicar el significado de ellas: extends: Esta palabra reservada, indica a la clase hija cual va a ser su clase padre, es decir que por ejemplo en la clase Futbolista al poner  public class Futbolista extends SeleccionFutbol  le estamos indicando a la clase 'Futbolista' que su clase padre es la clase 'SeleccionFutbol' o dicho de otra manera para que se entienda mejor, al poner esto estamos haciendo un  copy-paste din√°mico  diciendo a la clase 'Futbolista' que se 'copie' todos los atributos y m√©todos p√∫blicos o protegidos de la clase 'SeleccionFutbol'. De aqu√≠ viene esa 'definici√≥n' que dimos de que la herencia en un 'copy-paste din√°mico'. protected:  sirve para indicar un tipo de visibilidad de los atributos y m√©todos de la clase padre y significa que cuando un atributo es 'protected' o protegido, solo es visible ese atributo o m√©todo desde una de las clases hijas y no desde otra clase. super: sirve para llamar al constructor de la clase padre. Quiz√°s en el c√≥digo que hemos puesto no se ha visto muy bien, pero a continuaci√≥n lo mostramos de formas m√°s clara, viendo el constructor de los objetos pas√°ndole los atributos: public class SeleccionFutbol { ...... public SeleccionFutbol() { } public SeleccionFutbol(int id, String nombre, String apellidos, int edad) { this.id = id; this.Nombre = nombre; this.Apellidos = apellidos; this.Edad = edad; } ...... public class Futbolista extends SeleccionFutbol { ...... public Futbolista() { super(); } public Futbolista(int id, String nombre, String apellidos, int edad, int dorsal, String demarcacion) { super(id, nombre, apellidos, edad); this.dorsal = dorsal; this.demarcacion = demarcacion; } ...... Hasta aqu√≠ todo correcto, pero ahora vamos a ver como trabajamos con estas clases. Para ver este funcionamiento de forma clara y sencilla vamos a trabajar con un objeto de cada clase y vamos a ver como se crean y de que forma ejecutan sus m√©todo. Para ello empecemos mostrando el siguiente fragmento de c√≥digo: public class Main { // ArrayList de objetos SeleccionFutbol. Idenpendientemente de la clase hija a la que pertenezca el objeto public static ArrayList<SeleccionFutbol> integrantes = new ArrayList<SeleccionFutbol>(); public static void main(String[] args) { Entrenador delBosque = new Entrenador(1,  Vicente ,  Del Bosque , 60,  284EZ89 ); Futbolista iniesta = new Futbolista(2,  Andres ,  Iniesta , 29, 6,  Interior Derecho ); Masajista raulMartinez = new Masajista(3,  Ra√∫l ,  Martinez , 41,  Licenciado en Fisioterapia , 18); integrantes.add(delBosque); integrantes.add(iniesta); integrantes.add(raulMartinez); // CONCENTRACION System.out.println( Todos los integrantes comienzan una concentracion. (Todos ejecutan el mismo m√©todo) ); for (SeleccionFutbol integrante : integrantes) { System.out.print(integrante.getNombre()+   +integrante.getApellidos()+  ->  ); integrante.Concentrarse(); } // VIAJE System.out.println( nTodos los integrantes viajan para jugar un partido. (Todos ejecutan el mismo m√©todo) ); for (SeleccionFutbol integrante : integrantes) { System.out.print(integrante.getNombre()+   +integrante.getApellidos()+  ->  ); integrante.Viajar(); } ...... Lo primero que vemos es que nos creamos un objeto de cada clase, pas√°ndole los atributos al constructor como par√°metro y despu√©s  sorprendentemente  los metemos en un  ArrayList  de objetos de la clase  SeleccionFutbol  que es la clase padre. Esto evidentemente te lo permite hacer ya que todos los objetos son hijos de la misma clase padre. Luego como veis, recorremos el ArrayList y ejecutamos sus m√©todos  comunes  como son el 'Concentrarse' y el 'Viajar'. Este c√≥digo da como salida lo siguiente: Todos los integrantes comienzan una concentracion. (Todos ejecutan el mismo m√©todo) Vicente Del Bosque -> Concentrarse Andres Iniesta -> Concentrarse Ra√∫l Martinez -> Concentrarse Todos los integrantes viajan para jugar un partido. (Todos ejecutan el mismo m√©todo) Vicente Del Bosque -> Viajar Andres Iniesta -> Viajar Ra√∫l Martinez -> Viajar Como veis al ejecutar todos el mismo m√©todo de la clase padre el c√≥digo puesto funciona correctamente. Posteriormente vamos a ejecutar c√≥digo especifico de las clases hijas, de ahi que ahora no podamos recorrer el ArrayList y ejecutar el mismo m√©todo para todos los objetos ya que ahora esos objetos son √∫nicos de la clases hijas. El c√≥digo es el siguiente: // ENTRENAMIENTO System.out.println( nEntrenamiento: Solamente el entrenador y el futbolista tiene metodos para entrenar: ); System.out.print(delBosque.getNombre()+   +delBosque.getApellidos()+  ->  ); delBosque.dirigirEntrenamiento(); System.out.print(iniesta.getNombre()+   +iniesta.getApellidos()+  ->  ); iniesta.entrenar(); // MASAJE System.out.println( nMasaje: Solo el masajista tiene el m√©todo para dar un masaje: ); System.out.print(raulMartinez.getNombre()+   +raulMartinez.getApellidos()+  ->  ); raulMartinez.darMasaje(); // PARTIDO DE FUTBOL System.out.println( nPartido de F√∫tbol: Solamente el entrenador y el futbolista tiene metodos para el partido de f√∫tbol: ); System.out.print(delBosque.getNombre()+   +delBosque.getApellidos()+  ->  ); delBosque.dirigirPartido(); System.out.print(iniesta.getNombre()+   +iniesta.getApellidos()+  ->  ); iniesta.jugarPartido(); Como vemos aunque el entrenador y los futbolistas asistan a un entrenamiento, los dos hacen una funci√≥n diferente en el mismo, por tanto hay que hacer m√©todos diferente para cada una de las clases. Ya veremos cuando hablemos del polimorfismo que podremos ejecutar el mismo m√©todo para clases diferentes y que esos m√©todos hagan cosas distintas. Como resultado al c√≥digo mostrado tenemos lo siguiente: Entrenamiento: Solamente el entrenador y el futbolista tiene metodos para entrenar: Vicente Del Bosque -> Dirige un entrenamiento Andres Iniesta -> Entrena Masaje: Solo el masajista tiene el m√©todo para dar un masaje: Ra√∫l Martinez -> Da un masaje Partido de F√∫tbol: Solamente el entrenador y el futbolista tiene metodos para el partido de f√∫tbol: Vicente Del Bosque -> Dirige un partido Andres Iniesta -> Juega un partido CONCLUSIONES Y ACLARACIONES: Esto ha sido todo lo que hemos contado sobre la herencia en esta entrada. El tema de la herencia es un tema que puede ser un poco m√°s complejo de lo que lo hemos contado aqu√≠, ya que solo hemos contado lo que es la herencia simple (ya que Java por el momento es el √∫nico tipo de herencia que soporta) y no la herencia m√∫ltiple, que es un tipo de herencia en la que una clase hija puede tener varios padres, aunque por el momento si est√°is empezando a aprender el concepto de la herencia, con la herencia simple ten√©is m√°s que suficiente. Para los que os est√©is iniciando en el mundo de la ingenier√≠a inform√°tica, habr√©is podido ver que hemos puesto unos ejemplo mostrando unos diagramas  un poco raros ; pues bien, estos diagramas se llaman diagramas de clases (que los hemos realizado con la herramienta web de www.genmymodel.com) y sirven para representar de forma gr√°fica los atributos y m√©todos de las clases y las relaciones entre ellos, utilizando el lenguaje UML del cual intentaremos hablar m√°s adelante en otros tutoriales. Por √∫ltimo decir y aclarar que en esta entrada quiz√°s no hemos utilizado una terminolog√≠a correcta para explicar la herencia, pero lo hemos explicadode una forma algo distinta a como esta explicada por ahi para que los que empeceis podais entender la herencia desde otro punto de vista."
    },

    {
        "id": 90,
        "autor": "arkaitzgarro",
        "pagina": "arkaitzgarro",
        "fecha": "0/0/0",
        "titulo": "CAP√çTULO 16 HERENCIA",
        "link": "https://www.arkaitzgarro.com/java/capitulo-16.html",
        "contenido": "16.1 DEFINICI√ìN DE HERENCIA La herencia es una propiedad que permite la declaraci√≥n de nuevas clases a partir de otras ya existentes. Esto proporciona una de las ventajas principales de la Programaci√≥n Orientada a Objetos: la reutilizaci√≥n de c√≥digo previamente desarrollado ya que permite a una clase m√°s espec√≠fica incorporar la estructura y comportamiento de una clase m√°s general. Cuando una clase B se construye a partir de otra A mediante la herencia, la clase B hereda todos los atributos, m√©todos y clases internas de la clase A. Adem√°s la clase B puede redefinir los componentes heredados y a√±adir atributos, m√©todos y clases internas espec√≠ficas. Para indicar que la clase B (clase descendiente, derivada, hija o subclase) hereda de la clase A (clase ascendiente, heredada, padre, base o superclase) se emplea la palabra reservada extends en la cabecera de la declaraci√≥n de la clase descendiente. La sintaxis es la siguiente: public class ClaseB extends ClaseA { // Declaracion de atributos y metodos especificos de ClaseB // y/o redeclaracion de componentes heredados } Por ejemplo, a partir de la clase Precio: /** * Ejemplo de declaracion de la clase Precio */ public class Precio { // Variable de instancia public double euros; // Metodos publicos public double da() { return this.euros; } public void pone(double x) { this.euros = x; } } se construye la clase Producto como descendiente de la clase Precio de la siguiente forma: /** * Ejemplo de declaracion de la clase Producto * clase producto desciende de Precio */ public class Producto extends Precio { // Variable de instancia public int codigo; // Metodos publicos public int daCodigo() { return this.codigo; } public void asignaCodigo(int x) { this.codigo=x; } public void asignaProducto(int cod, double p) { this.asignaCodigo(cod); this.pone(p); } public String toString() { return  Codigo:   + codigo +   ; precio:   + euros +   euros ; } } La clase PruebaClaseProducto trabaja con dos instancias de la clase Producto: /** *  Demostracion de la clase Producto */ public class PruebaClaseProducto { public static void main (String [] args){ Producto p = new Producto(); p.asignaProducto(200201, 15.8); System.out.println(p.toString()); Producto q = new Producto(); q.asignaCodigo(200202); q.pone(34.3); System.out.println(q.toString()); } } Durante la ejecuci√≥n del c√≥digo anterior, se generan las instancias, referenciadas por p y q, cada una de las cuales est√° compuesta por dos atributos: euros, variable de instancia heredada de la clase Precio y codigo, variable de instancia espec√≠fica de la clase Producto. Representaci√≥n grafica de las instancias de la clase <code>Producto</code> Figura 16.1 Representaci√≥n grafica de las instancias de la clase Producto Por otro lado, la ejecuci√≥n de PruebaClaseProducto produce la siguiente salida por pantalla: $>javac PruebaClaseProducto.java $>java PruebaClaseProductoCodigo: 200201 ; precio: 15.8 euros Codigo: 200202 ; precio: 34.3 euros 16.2 JERARQU√çA DE CLASES Java permite m√∫ltiples niveles de herencia pero no la herencia multiple, es decir una clase s√≥lo puede heredar directamente de una clase ascendiente. Por otro lado, una clase puede ser ascendiente de tantas clases descendiente como se desee (un unico padre, multitud de hijos). En la siguiente figura se muestra gr√°ficamente un ejemplo de jerarqu√≠a entre diferentes clases relacionadas mediante la herencia. Representaci√≥n de una jerarqu√≠a de clases relacionadas mediante la herencia Figura 16.2 Representaci√≥n de una jerarqu√≠a de clases relacionadas mediante la herencia 16.3 REDEFINICI√ìN DE ELEMENTOS HEREDADOS Como se ha comentado anteriormente la clase descendiente puede a√±adir sus propios atributos y m√©todos pero tambi√©n puede sustituir u ocultar los heredados. En concreto: Se puede declarar un nuevo atributo con el mismo identificador que uno heredado, quedando este atributo oculto. Esta t√©cnica no es recomendable. Se puede declarar un nuevo m√©todo de instancia con la misma cabecera que el de la clase ascendiente, lo que supone su sobreescritura. Por lo tanto, la sobreescritura o redefinici√≥n consiste en que m√©todos adicionales declarados en la clase descendiente con el mismo nombre, tipo de dato devuelto y n√∫mero y tipo de par√°metros sustituyen a los heredados. Se puede declarar un nuevo m√©todo de clase con la misma cabecera que el de la clase ascendiente, lo que hace que √©ste quede oculto. Por lo tanto, los m√©todos de clase o est√°ticos (declarados como static) no pueden ser redefinidos. Un m√©todo declarado con el modificador final tampoco puede ser redefinido por una clase derivada. Se puede declarar un constructor de la subclase que llame al de la superclase de forma impl√≠cita o de mediante la palabra reservada super. En general puede accederse a los m√©todos de la clase ascendiente que han sido redefinidos empleando la palabra reservada super delante del identificador del m√©todo. Este mecanismo s√≥lo permite acceder al metodo perteneciente a la clase en el nivel inmediatamente superior de la jerarqu√≠a de clases. 16.4 LA CLASE OBJECT Independientemente de utilizar la palabra reservada extends en su declaraci√≥n, todas las clases derivan de una superclase llamada Object. √âsta es la clase ra√≠z de toda la jerarqu√≠a de clases de Java. El hecho de que todas las clases deriven impl√≠citamente de la clase Object no se considera herencia m√∫ltiple. Jerarqu√≠a de clases predefinidas en Java Figura 16.3 Jerarqu√≠a de clases predefinidas en Java Como consecuencia de ello, todas las clases tienen algunos m√©todos heredados de la clase Object. Algunos de los m√©todos de la clase predefinida <code>Object</code> Figura 16.4 Algunos de los m√©todos de la clase predefinida Object Es bastante frecuente tener que sobreescribir algunos de estos m√©todos. Por ejemplo, para verificar si dos instancias son iguales en el sentido de contener la misma informaci√≥n en sus atributos se deber√≠a sobreescribir el m√©todo equals(). El siguiente c√≥digo muestra un ejemplo de m√≥dificaci√≥n de la clase Producto para incluir una sobreescritura del m√©todo equals(): public class Producto extends Precio { ... public boolean equals(Object a) { if (a instanceof Producto) return (codigo==a.daCodigo()); else return false; } } Tambi√©n es bastante habitual sobreescribir el m√©todo toString(). 16.5 HERENCIA Y CONSTRUCTORES La subclase necesita normalmente que se ejecute el constructor de la superclase antes que su propio constructor para inicializar las variables de instancia heredadas. La soluci√≥n consiste en utilizar la palabra reservada super seguida entre par√©ntesis de los par√°metros correspondiente en el cuerpo del constructor de la subclase. Es decir, incluir la siguiente sentencia como primera l√≠nea de c√≥digo: super(argumentos opcionales); De esta forma la implementaci√≥n de un constructor de la clase descendiente s√≥lo necesita inicializar directamente las variables de instancia no heredadas. Si no aparece como primera sentencia, el compilador inserta una llamada impl√≠cita super(); que inicializa las variables de instancia a cero, false, car√°cter nulo o null dependiendo de su tipo. Esta llamada en cadena a los constructores de las clases ascendientes llega hasta el origen de la jerarqu√≠a de clases, es decir, hasta el constructor de la clase Object. En cualquier caso, la creaci√≥n de una nueva instancia mediante un constructor debe tener tres fases: Llamada al constructor de la clase ascendiente. Se asignan valores a los atributos. Se ejecuta el resto del constructor. 16.6 CASTING O MOLDES ENTRE OBJETOS CON RELACI√ìN DE HERENCIA El casting o moldeo permite el uso de un objeto de una clase en lugar de otro de otras clase con el que haya una relaci√≥n de herencia. Por ejemplo: Object a = new Producto(); Entonces a es moment√°neamente tanto una instancia de la clase Object como Producto (hasta que m√°s adelante se le asigne un objeto que no sea un Producto). A esto se le llama moldeo impl√≠cito. Por otro lado, si se escribe: Producto b = a; se obtendr√° un error de compilaci√≥n porque el objeto referenciado por a no es considerado por el compilador como un Producto. Sin embargo se le puede indicar al compilador que a la referencia a se le va a asignar obligatoriamente un Producto. Producto b = (Producto)a; Este moldeo expl√≠cito introduce la verificaci√≥n durante la ejecuci√≥n de que a la referencia a se le ha asignado un Producto as√≠ que el compilador no genera un error. En el caso que durante la ejecuci√≥n la referencia a no fuera a un Producto, se generar√≠a una excepci√≥n. Para asegurar esta situaci√≥n y evitar el error de ejecuci√≥n se podr√≠a emplear el operador instanceof: if (a instanceof Producto) { Producto b = (Producto)a; } 16.7 CLASES Y M√âTODOS ABSTRACTOS Una clase abstracta es una clase de la que no se pueden crear instancias. Su utilidad consiste en permitir que otras clases deriven de ella. De esta forma, proporciona un modelo de referencia a seguir a la vez que una serie de m√©todos de utilidad general. Las clases abstractas se declaran empleando la palabra reservada abstract como se muestra a continuaci√≥n: public abstract class IdClase . . . Una clase abstracta puede componerse de varios atributos y m√©todos pero debe tener, al menos, un m√©todo abstracto (declarado tambi√©n con la palabra reservada abstract en la cabecera). Los m√©todos abstractos no se implementan en el c√≥digo de la clase abstracta pero las clases descendientes de √©sta han de implementarlos o volver a declararlos como abstractos (en cuyo caso la subclase tambi√©n debe declararse como abstracta). En cualquier caso, ha de indicarse el tipo de dato que devuelve y el n√∫mero y tipo de par√°metros. La sintaxis de declaraci√≥n de un m√©todo abstracto es: abstract modificador tipo_retorno idClase(lista_parametros); Si una clase tiene m√©todos abstractos, entonces tambi√©n la clase debe declararse como abstracta. Como los m√©todos de clase (static) no pueden ser redefinidos, un m√©todo abstracto no puede ser est√°tico. Tampoco tiene sentido que declarar constructores abstractos ya que un constructor se emplea siempre al crear una instancia (y con las clases abstractas no se crean instancias). Ejemplo de c√≥digo con la declaraci√≥n de clase abstracta: /** * Declaracion de la clase abstracta FiguraGeometrica */ public abstract class FiguraGeometrica { // Declaracion de atributos private String nombre; // Declaracion de metodos abstract public double area(); public figuraGeometrica (String nombreFigura ) { this.nombre = nombreFigura; } final public boolean mayorQue (FiguraGeometrica otra) { return this.area()>otra.area(); } final public String toString() return this.nombre +   con area   + this.area(); } } Como ejemplo de utilizaci√≥n de Rectangulo se construye a partir de la clase abstracta FiguraGeometrica: /** * Ejemplo de uso de la declaracion de una clase abstracta * Declaracion de la clase Rectangulo */ public class Rectangulo extends FiguraGeometrica { private double base; private double altura; public Rectangulo (double largo, double ancho) { super( Rectangulo ); this.base = largo; this.altura = ancho; } public double area () { return this.base * this.altura; } } Ejemplo de uso de la clase Rectangulo: /** * Ejemplo de uso de la clase Rectangulo */ public class pruebaRectangulo { public static void main (String [] args ) { Rectangulo r1; r1 = new Rectangulo(12.5, 23.7); System.out.println( Area de r1 =   + r1.area()); Rectangulo r2 = new Rectangulo(8.6, 33.1); System.out.println( Area de r2 =   + r2.toString()); if (r1.mayorQue(r2)) System.out.println( El rectangulo de mayor area es r1 ); else System.out.println( El rectangulo de mayor area es r2 ); } } Salida por pantalla de la ejecuci√≥n del c√≥digo anterior: $>java PruebaRectangulo Area de r1 = 296.25 Area de r2 = Rectangulo con area 284.66 El rectangulo de mayor area es r1 16.8 CLASES Y M√âTODOS FINALES Una clase declarada con la palabra reservada final no puede tener clases descendientes. Por ejemplo, la clase predefinida de Java Math est√° declarada como final. A modo de ejemplo, se desarrolla una clase final MathBis (de operatividad similar a la clase Math est√°ndar de Java) que incluye la declaraci√≥n de dos m√©todos que calculan y devuelven respectivamente las siguientes funciones trigonom√©tricas: El c√≥digo fuente de la clase es: /** * Ejemplo de declaracion de una clase final * Declaracion de la clase MathBis */ public final class MathBis { public static double asinh(double x) { return Math.log(x+Math.sqrt(x*x+1)); } public static double acosh(double x) { return Math.log(x+Math.sqrt(x*x-1)); } } Ejemplo de uso de la clase MathBis: /** * Ejemplo de uso de una clase final * Declaracion de la clase pruebaMathBis */ public class PruebaMathBis { public static void main (String [] args) { for (int i=-5; i<10; i++) { double x = i/5.0; System.out.print( Para x =   + x); System.out.print( : asinh(x) =   +MathBis.asinh(x)); System.out.println( , acosh(x) =   +MathBis.acosh(x)); } } } Por otro lado, un m√©todo declarado como final no puede ser redefinido por una clase descendiente. Los m√©todos que son llamados desde los constructores deber√≠an declararse como final, ya que si un constructor llama a un m√©todo que no lo sea, la subclase podr√≠a haberla redefinido con resultados indeseables."
    },

    {
        "id": 91,
        "autor": "Alex Rodr√≠guez",
        "pagina": "aprenderaprogramar",
        "fecha": "0/0/0",
        "titulo": "Ejemplo de herencia en Java. Uso de palabras clave extends y super. Constructores con herencia.",
        "link": "https://www.aprenderaprogramar.com/index.php?option=com_content&view=article&id=653:ejemplo-de-herencia-en-java-uso-de-palabras-clave-extends-y-super-constructores-con-herencia-cu00686b&catid=68&Itemid=188#:~:text=Para%20declarar%20la%20herencia%20en,clases%20que%20mostramos%20a%20continuaci%C3%B3n.",
        "contenido": "EJEMPLO DE HERENCIA EN JAVA. EXTENDS Y SUPER. Para declarar la herencia en Java usamos la palabra clave extends. Ejemplo: public class MiClase2 extends Miclase1. Para familiarizarte con la herencia te proponemos que escribas y estudies un peque√±o programa donde se hace uso de ella. Escribe el c√≥digo de las clases que mostramos a continuaci√≥n. //C√≥digo de la clase Persona ejemplo aprenderaprogramar.com public class Persona { private String nombre; private String apellidos; private int edad; //Constructor public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad;                   } //M√©todos public String getNombre () { return nombre;  } public String getApellidos () { return apellidos;  } public int getEdad () { return edad;   } } //Cierre de la clase //C√≥digo de la clase profesor, subclase de la clase Persona ejemplo aprenderaprogramar.com public class Profesor extends Persona { //Campos espec√≠ficos de la subclase. private String IdProfesor; //Constructor de la subclase: incluimos como par√°metros al menos los del constructor de la superclase public Profesor (String nombre, String apellidos, int edad) { super(nombre, apellidos, edad); IdProfesor =  Unknown ;   } //Cierre del constructor //M√©todos espec√≠ficos de la subclase public void setIdProfesor (String IdProfesor) { this.IdProfesor = IdProfesor;   } public String getIdProfesor () { return IdProfesor;   } public void mostrarNombreApellidosYCarnet() { // nombre =  Paco ; Si trat√°ramos de acceder directamente a un campo privado de la superclase, salta un error // S√≠ podemos acceder a variables de instancia a trav√©s de los m√©todos de acceso p√∫blicos de la superclase System.out.println ( Profesor de nombre:   + getNombre() +     +  getApellidos() + con Id de profesor:   + getIdProfesor() ); } } //Cierre de la clase //C√≥digo de test aprenderaprogramar.com public class TestHerencia1 { public static void main (String [ ] Args) { Profesor profesor1 = new Profesor ( Juan ,  Hern√°ndez Garc√≠a , 33); profesor1.setIdProfesor( Prof 22-387-11 ); profesor1.mostrarNombreApellidosYCarnet();} } //Cierre de la clase El diagrama de clases y el resultado del test son del tipo que mostramos a continuaci√≥n: herencia, java Profesor de nombre: Juan Hern√°ndez Garc√≠a con Id de profesor: Prof 22-387-11 Los aspectos a destacar del c√≥digo son: a) La clase persona es una clase ‚Äúnormal‚Äù definida tal y como lo venimos haciendo habitualmente mientras que la clase Profesor es una subclase de Persona con ciertas peculiaridades. b) Los objetos de la subclase van a tener campos nombre, apellidos y edad (heredados de Persona) y un campo espec√≠fico IdProfesor. El constructor de una subclase ha de llevar obligatoriamente como par√°metros al menos los mismos par√°metros que el constructor de la superclase. c) El constructor de la subclase invoca al constructor de la superclase. Para ello se incluye, obligatoriamente, la palabra clave super como primera l√≠nea del constructor de la subclase. La palabra super ir√° seguida de par√©ntesis dentro de los cuales pondremos los par√°metros que requiera el constructor de la superclase al que queramos invocar. En este caso solo ten√≠amos un constructor de superclase que requer√≠a tres par√°metros. Si p.ej. hubi√©ramos tenido otro constructor que no requiriera ning√∫n par√°metro podr√≠amos haber usado uno u otro, es decir, super(nombre, apellidos, edad) √≥ super(), o bien ambos teniendo dos constructores para la superclase y dos constructores para la subclase. Ejemplo: En la superclase:                                public Persona() { nombre =   ; apellidos =   ; edad = 0; } public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad;                   } En la subclase:                                   public Profesor () { super(); IdProfesor =  Unknown ;} public Profesor (String nombre, String apellidos, int edad) { super(nombre, apellidos, edad); IdProfesor =  Unknown ;   } Modifica el c√≥digo de las clases Persona y Profesor para que queden con dos constructores tal y como hemos mostrado aqu√≠. Crea objetos de ambos tipos en BlueJ y prueba sus m√©todos. ¬øQu√© ocurre si olvidamos poner super como primera l√≠nea de la subclase? Hay dos posibilidades: si la superclase tiene un constructor sin par√°metros, el compilador incluir√° en segundo plano super de forma autom√°tica y no saltar√° un error. De cualquier manera se considera contrario al buen estilo de programaci√≥n, ya que no queda claro si se trata de un olvido. Por ello incluiremos siempre la palabra clave super. La otra posibilidad es que no haya un constructor sin par√°metros, en cuyo caso saltar√° un error. A modo de resumen: la inicializaci√≥n de un objeto de una subclase comprende dos pasos. La invocaci√≥n al constructor de la superclase (primera l√≠nea del constructor: super‚Ä¶) y el resto de instrucciones propias del constructor de la subclase."
    }
  ]
  