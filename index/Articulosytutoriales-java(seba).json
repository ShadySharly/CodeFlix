[
    {
        "id": 61,
        "autor": "Oscar Blancarte",
        "pagina": "oscarblancarteblog",
        "fecha": "25/06/2018",
        "titulo": "Creando un API REST en Java (parte 1)",
        "link": "https://www.oscarblancarteblog.com/2018/06/25/creando-un-api-rest-en-java-parte-1/",
        "contenido": "Sin lugar a duda, los servicios REST ya se han convertido en la principal tecnología para construir servicios, superando con creces a los servicios SOAP o comúnmente conocidos como Web Services. A pesar de que REST ya es visiblemente la tendencia en el desarrollo de servicios, sigue existiendo una gran discusión acerca de si SOAP es mejor que REST o al revés, sin embargo, no quiera tocar este tema ahora, pues no es el tema central de este artículo, para eso he creado el artículo “SOA vs REST” donde discutimos sobre estas dos tecnologías y sus ventajas y desventajas. NOTA: Este artículo es parte de un tutorial completo para crear API REST con JAX-RS, si quieres ver el índice completo entra aquí. Antes de comenzar, te cuento que puedes descargar el código completo en https://github.com/oscarjb1/blog-tutorial-jaxrs/tree/master/M%C3%A9todos%20HTTP/api Configurando el proyecto Dicho este, pasemos ahora si a implementar un API REST con Java, para esto, será indispensable crear un proyecto de tipo WEB en tu IDE favorito, en este caso, vamos a crear un “Dynamic web project” en Eclipse, para esto nos dirigimos a file -> new -> Other en el menú superior: Seleccionamos la opción Dynamic web Project y presionamos Next para iniciar con la configuración de la aplicación: Una vez aquí, escribimos “api” como nombre del proyecto y seleccionamos nuestro servidor de aplicaciones de preferencia, en nuestro caso, utilizamos Wildfly 11 pero podrías utilizar cualquier otro que tengas disponible. Finalmente, presionamos “Finish” para concluir con la creación del proyecto. El siguiente paso será convertir nuestro proyecto a un proyecto Maven, con la finalidad de administrar más fácilmente nuestras librerías. Para ello, nos posicionaremos sobre el proyecto creado y presionaremos “click derecho“ para abrir las opciones del proyecto, estando allí, nos dirigimos a configure -> convert to Maven Project, tras presionar esto, saldrá una ventana para configurar el proyecto, a lo que simplemente daremos finalizar. Tras realizar los pasos anteriores deberás ver el proyecto tal y como se ve en la imagen anterior. Podrás observar una pequeña “M” en el ícono del proyecto, señal de que se trata de un proyecto Maven. El siguiente paso es configurar las librerías de JavaEE y Wildfly con la finalidad de que estén disponibles en nuestro proyecto, por lo que tendremos que ir al archivo pom.xml y agregar las siguientes dos librerías: <dependency> <groupId>javax</groupId> <artifactId>javaee-api</artifactId> <version>7.0</version> <scope>provided</scope> <type>jar</type> </dependency> <dependency> <groupId>org.wildfly.core</groupId> <artifactId>wildfly-server</artifactId> <version>2.2.0.Final</version> <scope>provided</scope> </dependency> Guardamos los cambios y tendremos que esperar un momento hasta que Eclipse descarga todas las dependencias necesarias, para esto, verás un indicador de progreso en la parte inferior derecha de Eclipse. Una vez que ha finalizado, estamos listos para empezar a desarrollar. Iniciando el desarrollo Lo primero que debemos de hacer para iniciar nuestra API REST es indicarle el Path base desde el cual estará respondiendo nuestra API. Este path corresponde a la URL a partir de la cual se expondrá nuestros servicios. Para lograr esto, será necesario crear una clase que extienda de “Application”, esta clase puede llamarse como sea y puede colocarse en cualquier paquete, lo único importante es que extienda de Application y defina la anotación @ApplicationPath. En nuestro caso crearemos la clase RestApplication en el package api. package api; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( / ) public class RestApplication extends Application { } Como podemos ver, hemos definido “/” como URL base, es decir que los servicios responderán a partir de la raíz del proyecto, pero tu podrías remplazarla por la URL base que más te guste, como por ejemplo “/api” o “/services”. El siguiente paso será crear nuestro primer servicio, para lo cual deberemos crear una nueva clase, en este caso, crearemos la clase HelloWorldRest en el mismo paquete: package api; import javax.ws.rs.Consumes; import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.Produces; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; @Path( /helloworld ) @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class HelloWorldRest { @GET public Response sayHello() { return Response.ok( Hello World desde el API REST ,MediaType.APPLICATION_JSON).build(); } } Como podrás observar, esta es una clase común y corriente pero que tiene algunas anotaciones, las cuales serán reconocidas por el servidor de aplicaciones para finalmente exponer el servicio, analicemos para que esta cada una de ellas. La anotación @Path indica la URL en la cual responderá este servicio, cabe mencionar que esta anotación se puede poner a nivel de clase y método, en este caso, al estar a nivel de clase, afecta a todos los servicios que definamos, pero eso lo vamos a analizar más adelante. Las siguientes dos anotaciones son para indicar que tipo de mensaje esperamos como entrada (consumes) y que tipo de mensaje vamos a responder (produces). En este caso, estamos indicando que esperamos JSON como entrada y que vamos a responder igualmente con JSON. Finalmente, siguen los métodos, una clase puede tener más de un método, y cada método se puede exponer como un servicio independiente, sin embargo, en esta primera introducción empezaremos con uno. La anotación @GET le indica al servidor de aplicaciones que el método responde por el método GET únicamente. Adicional tenemos anotaciones para los demás métodos, como @POST, @PUT, @DELETE, etc. pero estos los estaremos analizando más adelante. Podrás observar que el método responde con un tipo llamado Response, esta es una clase de utilidad que nos proporciona el API de JAX-RS para convertir fácilmente un objeto en un JSON en nuestro caso. Esta clase nos proporciona el método ok, el cual nos crea una respuesta con status 200, es decir, respuesta exitosa, la cual recibe el mensaje que queremos responder y el tipo de datos del mensaje, en nuestro caso JSON. Probando nuestro Hello World En este punto hemos terminado nuestro primer servicio, por lo que solo resta desplegarlo y probarlo. Para desplegarlo, basta con presionar el click derecho sobre el proyecto y presionar Run As -> Run on Server, presionar siguiente y finalizar. Si la aplicación desplego correctamente, podremos probar el servicio en la URL http://localhost:8080/api-0.0.1-SNAPSHOT/helloworld, esta URL la podrás ejecutar directamente sobre el navegador: En este punto te estarás preguntando como es que se generó esta URL, por lo que explico a continuación: La URL se forma con la siguiente formula: <server_path>:<port>/<app_context>/<app_path>/<service_path> La sección <server_path> y <port> corresponde al host del servidor y el puerto en el cual responde, esto corresponde a Wildfly. La sección <app_context> corresponde a la URL base que nos asigna el servidor de aplicaciones cuando desplegamos. La sección <app_path> fue la que definimos en la anotación @ApplicationPath. En nuestro caso, al definirla como “/” quiere decir que responderá a partir de la raíz del proyecto. Finalmente, <service_path> corresponde a la URL definida en la anotación @Path, la cual se definió como “helloworld”. Te invito a que veas mi curso Mastering API REST con Spring Boot Conclusiones Hasta este punto hemos aprendido a crear un proyecto web y configurarlo para que responda a nuestras solicitudes como un API REST, por lo que en la siguiente sección de esta guía aprenderemos a utilizar los demás métodos (POST, DELETE, PUT) y aprenderemos a configurar nuestras URL para responder a URL más complejas, por lo que te invito a que te suscribas a mi blog para hacerte llegar las actualizaciones."
    },

    {
        "id": 62,
        "autor": "Rosa",
        "pagina": "developrogramming",
        "fecha": "12/05/2020",
        "titulo": "Crear API REST JAVA",
        "link": "https://developrogramming.com/crear-api-rest-java/",
        "contenido": "A continuación, explicaré cómo crear servicios web desarrollando una API REST JAVA con la librería JAX-RS y Jersey. ¿Qué es REST? Sus siglas significan Transferencia de Estado Representacional. No es un protocolo de comunicación, sino una definición de arquitectura donde la comunicación se realiza vía HTTP utilizando los métodos GET, POST, PUT, DELETE y PATCH. La respuesta de esos métodos admiten formatos como JSON (Notación de Objeto de JavaScript), XML, HTML o TEXTO PLANO, entre otros. Así, cuando se habla de aplicación RESTful quiere decir que implementa este tipo de arquitectura. ¿Qué es JAX-RS? Java API for RESTful Web Services. Es una especificación para crear Servicios Web REST que se basa en anotaciones para simplificar el desarrollo y despliegue de los clientes. ¿Qué es Jersey? Es un cliente RESTful e implementa JAX-RS. Facilita a los desarrolladores crear servicios web RESTful con Java. api rest Operaciones REST Las principales operaciones de un sistema REST y la especificación HTTP son las siguientes: GET (leer) POST (crear) PUT (editar) DELETE (eliminar) PATCH (actualizar) Crear proyecto Lo primero que hay que hacer es crear un proyecto web dinámico Java y configurarlo para poder trabajar con Maven. Como entorno de desarrollo he utilizado Eclipse. Modificar fichero pom.xml A continuación, introducimos las dependencias en el fichero de configuración de Maven. pom.xml <project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>API_REST_WS-RS</groupId> <artifactId>API_REST_WS-RS</artifactId> <version>0.0.1-SNAPSHOT</version> <packaging>war</packaging> <build> <sourceDirectory>src</sourceDirectory> <plugins> <plugin> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.0</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <plugin> <artifactId>maven-war-plugin</artifactId> <version>3.2.1</version> <configuration> <warSourceDirectory>WebContent</warSourceDirectory> </configuration> </plugin> </plugins> </build> <dependencies> <dependency> <groupId>javax.ws.rs</groupId> <artifactId>javax.ws.rs-api</artifactId> <version>2.1.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-servlet</artifactId> <version>2.25.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.25.1</version> </dependency> </dependencies> </project> Crear clases A continuación, vamos a crear las clases User.java, ServicioUsers.java y Configuration.java. User.java package es.rosamarfil.modelo; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } ServicioUsers.java package es.rosamarfil.services; import java.util.ArrayList; import java.util.List; import javax.ws.rs.BeanParam; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.GET; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.client.Entity; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; import javax.ws.rs.core.Response.Status; import es.rosamarfil.modelo.User; @Path( /users ) public class ServicioUsers { private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; /** * URL: http://localhost:8080/API_REST_WS-RS/api/users * @return Response list Users */ @GET @Produces(MediaType.APPLICATION_JSON) public Response getUsers() { return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/Rosa * * @param name String * @return Response */ @GET @Path( /{name} ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response getUserById(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/createUser Parameters in * Postman: { name : Rosa3333 , username : Marfi3333l } * * @param User * @return Response list NOTA: Si no existe el constructor vacío de User, da un *         error y el userRequest viene null. */ @POST @Path( /createUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response createUser(User userRequest) { this.listaUsuarios.add(userRequest); //return Response.status(Status.CREATED).build(); return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/updateUser Parameters in * Postman: { name : Rosa , username : Marfil3333 } * * @param User * @return user modified NOTA: Si no existe el constructor vacío de User, da un *         error y el userRequest viene null. */ @PUT @Path( /updateUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateUser(User userUpdate) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(userUpdate.getName())) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { found.setUsername(userUpdate.getUsername()); return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa * * @param User * @return Response */ @DELETE @Path( /deleteUser/{name} ) @Produces(MediaType.APPLICATION_JSON) public Response deleteUser(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); listaUsuarios.remove(found); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(listaUsuarios).build(); } } } Configuration.java package es.rosamarfil.services; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( api ) public class Configuration extends Application { } Probar nuestra API REST Para poder acceder a los servicios creados, lo primero que hay que hacer es publicarlos a través de un servidor. Para ello, desde Eclipse arrancaremos nuestro proyecto. Previamente necesitaremos tener un servidor configurado, como por ejemplo Apache. Una vez hecho esto, nos situaremos sobre nuestro proyecto, desplegaremos el menú contexual y seleccionaremos Run As -> Run on Server. Crear API REST JAVA - JAX-RS y Jersey Una vez arrancado el servidor con nuestra aplicación, podemos probar los servicios o bien desde la barra de direcciones de un navegador o desde algún programa cliente como Postman. La dirección base de nuestra aplicación es: http://localhost:8080/API_REST_WS-RS Vamos a ver los parámetros a introducir: GET (leer) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users GET (leer) a partir de un parámetro. En este caso buscaremos un usuario por nombre. En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/Rosa POST (crear) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/createUser y en la sección Body, introduce un usuario en formato json, como se muestra en la imagen: Crear API REST JAVA - JAX-RS y Jersey - Postman PUT (editar) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/updateUser y en la sección Body de Postman introduce: {«name»:»Rosa»,»username»:»Marfil3333″} DELETE (eliminar) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa Y hasta aquí la creación de tu primera API REST. Como ves, con unos simples pasos es posible crear servicios web basados en REST. Espero que te haya sido de utilidad. Comparte si te ha gustado!!"
    },

    {
        "id": 63,
        "autor": "Emmanuel Guzmán",
        "pagina": "oracle-max",
        "fecha": "21/03/2020",
        "titulo": "Creando un API REST con Java y Netbeans, que devuelva un json en su request",
        "link": "https://oracle-max.com/creando-un-api-rest-con-java-y-netbeans-que-devuelva-un-json-en-su-request/",
        "contenido": "En este laboratorio aprenderás paso a paso, como crear un API Rest con Java en Netbeans, este a su vez devolverá un json como respuesta a su request. Primero debemos crear un proyecto Maven Web Application: Luego en el source package crearemos un paquete al cual le llamaré API, daremos click derecho en el paquete y buscaremos la siguiente opción: Seleccionamos Simple Root Resource En la siguiente pantalla debemos llenar lo siguientes campos según corresponda: Path: nombre por el cual realizaremos la consulta a nuestro API. Class Name: nombre de la clase donde programaremos nuestra función GET. MIME Type: Tipo de contenido que dará como respuesta nuestro API. Lo demás quedará igual y presionamos Finish. Se nos crearán dos clases como las siguientes: Tenemos un método llamado getJson dentro de la clase ApipruebaResource, a este le cambiaremos el nombre a consultaPersona y le envíaremos 4 parámetros usando la anotación @QueryParam: Ahora crearemos un nuevo paquete llamado com.api.bean y dentro crearemos dos clases, una llamada Persona y otra llamada Telefono, las cuales tendrán lo siguiente: Clase Persona Clase Telefono Por último crearemos una clase más llamada Json la cuál solamente le enviaremos el objeto persona. Clase Json Ahora nos devolvemos a la clase ApipruebaResource y crearemos nuestro objeto persona el cual convertiremos a json: Antes de continuar, debemos colocar la librería de gson en nuestro archivo pom.xml para poder usar la conversión a json: Luego regresamos a la clase ApipruebaResource y colocaremos el siguiente código: De esta forma nuestro API Rest quedaría terminada, por lo que debemos compilar y probar nuestra API Rest. Para probar nuestro API Rest lo podemos hacer de 2 maneras: Damos click derecho en la carpeta RESTful Web Services y seleccionamos Test RESTful Web Services: Se nos abrirá la siguiente pantalla donde lo probaremos: 2. La segunda forma de probarlo es por medio de un url en un navegador, para ello deberemos enviar el siguiente url, el puerto puede variar según la configuración de su servidor web: http://localhost:8080/APIrestJava/webresources/apiprueba?cedula=12345&nombre=Emmanuel+Guzman&telefono=88888888&operador=Movistar De esta manera hemos logrado crear un API Restful que nos devuelva un json como respuesta, si lo vemos formateado en json queda así: { persona : { cedula :  12345 , nombre :  Emmanuel Guzman , telefono : { telefono :  88888888 , operador :  Movistar } } } Luego de esto ya queda a nuestra creatividad la cantidad de contenedores que queramos crear en el json, sus respectivos atributos y la lógica detrás a implementar para responder el request."
    },

    {
        "id": 64,
        "autor": "nigmacode",
        "pagina": "nigmacode",
        "fecha": "01/01/2020",
        "titulo": "Crear API REST con Spring",
        "link": "https://www.nigmacode.com/java/crear-api-rest-con-spring/",
        "contenido": "En este artículo, crearemos una API REST con el framework Spring, el framework más utilizado para la plataforma Java. Para ello, utilizaremos Spring boot que nos facilitará su configuración (uso de dependencias, conexión con la base de datos, despliegue de servidor, etc). Debemos tener instalado Java, Maven en nuestro PC y como entorno de desarrollo utilizaremos Eclipse. Creando proyecto con SpringBoot Como hemos comentado, utilizaremos Springboot, que es una de las tecnologías dentro del mundo de spring, que nos facilita el desarrollo de aplicaciones con este framework, ya que nos facilita el trabajo con de las dependencias (Maven/Grandle), del despliegue del servidor, ya que nos provee de uno (a parte de mucha otra configuración). Para comenzar, nos dirigimos a la página https://start.spring.io/ dónde descargaremos nuestro proyecto: Project: En la primera opción, elegimos si queremos trabajar con maven o gradle, en este ejemplo, utilizaremos Maven. Language: En la segunda opción, elegimos con que lenguaje trabajar, Java. Springboot: En esta opción, elegimos la versión que queremos utilizar, en este caso 2.1.5 Project Metadata: El nombre de nuestro proyecto. Dependencies: En el buscador de dependecias, buscaremos y añadiremos WEB para crear nuestra API REST. Daremos click sobre el botón Generate the project, comenzará la descarga y una vez descargado lo descomprimiremos. Incluyendo proyecto Spring boot en Eclipse Ahora importaremos nuestro proyecto spring boot en Eclipse, para ello, iremos a la barra de eclipse e iremos a file/import/Maven/Existing Maven Porjects y daremos a browse, dónde buscaremos el proyecto que acabamos de descargar, nos fijamos en que este el check que nos aparecerá del pom.xml marcado y daremos a next. Nuestro proyecto ya aparecerá en eclipse y comenzará a descargar las dependencias de su archivo pom.xml. Configurando spring boot Dependencias Para aprender a añadir nuevas dependencias en nuestro proyecto, vamos a dirigirnos a pom.xml, que se encuentra en la raiz de nuestro proyecto, ahí nos aparecerán las dependencias que se han agregado al añadirle en spring init la dependencia WEB. En este archivo, en el apartado de dependencias, vamos a añadir debajo de las que ya tenemos, tres más, una será para trabajar con JPA, otra para conectarnos a nuestra base mysql y otra para que refresque el servidor cada vez que haya algún cambio: <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.1.5.RELEASE</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.jlguisado.webjob</groupId> <artifactId>api</artifactId> <version>0.0.1-SNAPSHOT</version> <name>api</name> <description>Demo project for Spring Boot</description> <properties> <java.version>1.8</java.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> </project> Una vez hecho esto, actualizaremos nuestro proyecto con estas nuevas dependencias, haciendo click derecho sobre su carpeta, maven/update project. Base de datos En este ejemplo, estoy utilizando xampp para trabajar con la base de datos que he llamado api y una tabla llamada user que tiene la siguiente estructura: Una vez creada nuestra base de datos y su tabla user, vamos a volver a nuestro proyecto spring y nos dirigimos al archivo application.properties, que se encuentra en src/main/resources e indicaremos la ruta de la base de datos, su usuario y contraseña: # # JDBC Properties # spring.datasource.url = jdbc:mysql://localhost:3306/api?useUnicode=true&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=UTC #direccion de la base de datos, puede variar el puerto y nombre de la bd spring.datasource.username=root #usuario que utilizas en la bd spring.datasource.password=root #contraseña que utilizas en la bd Una vez hecho esto, ya estaríamos listo para crear nuestra API REST. Creando API REST con Spring boot Para comenzar, os mostraré el carpetado que va a tener nuestro API REST, tendréis que crear estos paquetes con estas clases: ApiApplication.java Es la clase que arranca nuestra aplicación springboot, dando click derecho sobre la clase y run as application: package com.nigmacode.apirest; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } Paquete entity En este paquete tenemos nuestro clase User.java y utilizaremos las @anotaciones JPA para relacionarla con nuestra tabla user, quedaría de la siguiente forma: package com.nigmacode.apirest.entity; import java.util.Date; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.UpdateTimestamp; @Entity @Table(name= user ) public class User { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name= id ) private int id; @Column(name= email ) private String email; @Column(name= password ) private String password; @Column(name= created_at ) @CreationTimestamp private Date createdAt; @Column(name= updated_at ) @UpdateTimestamp private Date updatedAt; public User() {} public User(int id, String email, String password) { this.id = id; this.email = email; this.password = password; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Date getCreatedAt() { return createdAt; } public void setCreatedAt(Date createdAt) { this.createdAt = createdAt; } public Date getUpdatedAt() { return updatedAt; } public void setUpdatedAt(Date updatedAt) { this.updatedAt = updatedAt; } @Override public String toString() { return  User [id=  + id +  , email=  + email +  , password=  + password +  , createdAt=  + createdAt +  , updatedAt=  + updatedAt +  ] ; } } Paquete DAO En UserDAO, crearemos los métodos que utilizará la clase UserDAOimpl, para conectarse con nuestra base de datos. Interfaz userDAO: package com.nigmacode.apirest.dao; import java.util.List; import com.nigmacode.apirest.entity.User; public interface UserDAO { public List<User> findAll(); public User findById(int id); public void save(User user); public void deleteById(int id); } En nuestra clase UserDAOImpl, implementamos la interfaz, le añadiremos la anotación @Repository que indica que es un DAO,y mediante la anotación @Autowired inyectaremos EntityManager, que lo utilizaremos para crear una sessión y poder enviar las peticiones a la base de datos en cada método: package com.nigmacode.apirest.dao; import java.util.List; import javax.persistence.EntityManager; import org.hibernate.Session; import org.hibernate.query.Query; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Repository; import com.nigmacode.apirest.entity.User; @Repository public class UserDAOImpl implements UserDAO{ @Autowired private EntityManager entityManager; @Override public List<User> findAll() { Session currentSession = entityManager.unwrap(Session.class); Query<User> theQuery = currentSession.createQuery( from User , User.class); List<User> users = theQuery.getResultList(); return users; } @Override public User findById(int id) { Session currentSession = entityManager.unwrap(Session.class); User user = currentSession.get(User.class, id); return user; } @Override public void save(User user) { Session currentSession = entityManager.unwrap(Session.class); currentSession.saveOrUpdate(user); } @Override public void deleteById(int id) { Session currentSession = entityManager.unwrap(Session.class); Query<User> theQuery = currentSession.createQuery( delete from User where id=:idUser ); theQuery.setParameter( idUser , id); theQuery.executeUpdate(); } } Paquete Service Como en el paquete anterior tendremos una clase y una interface. El servicio será el que hará de interemediario entre el DAO y el controlador(La clase que gestionará las peticiones de la API que veremos más adelante). La interfaz de service tendría esta estructura UserService.java: package com.nigmacode.apirest.service; import java.util.List; import com.nigmacode.apirest.entity.User; public interface UserService { public List<User> findAll(); public User findById(int id); public void save(User user); public void deleteById(int id); } Y la clase UserServiceImpl.java, será implementada por la interfaz anterior. Le añadiremos la anotación @Service, para indicar que es un servicio y también de @Autowired para inyectar nuestro DAO y hacer uso de él: package com.nigmacode.apirest.service; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.nigmacode.apirest.dao.UserDAO; import com.nigmacode.apirest.entity.User; @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Override public List<User> findAll() { List<User> listUsers= userDAO.findAll(); return listUsers; } @Override public User findById(int id) { User user = userDAO.findById(id); return user; } @Override public void save(User user) { userDAO.save(user); } @Override public void deleteById(int id) { userDAO.deleteById(id); } } Paquete controller Por último, en el paquete controller tendremos la clase UserRestController.java que será la encargada de gestionar las peticiones que se hagan a nuestra API, esta clase en más extensa y será explicada mediante comentarios en el siguiente código: package com.nigmacode.apirest.controller; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.PutMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import com.nigmacode.apirest.entity.User; import com.nigmacode.apirest.service.UserService; //Indiciamos que es un controlador rest @RestController @RequestMapping( /api ) //esta sera la raiz de la url, es decir http://127.0.0.1:8080/api/ public class UserRestController { //Inyectamos el servicio para poder hacer uso de el @Autowired private UserService userService; /*Este método se hará cuando por una petición GET (como indica la anotación) se llame a la url http://127.0.0.1:8080/api/users*/ @GetMapping( /users ) public List<User> findAll(){ //retornará todos los usuarios return userService.findAll(); } /*Este método se hará cuando por una petición GET (como indica la anotación) se llame a la url + el id de un usuario http://127.0.0.1:8080/api/users/1*/ @GetMapping( /users/{userId} ) public User getUser(@PathVariable int userId){ User user = userService.findById(userId); if(user == null) { throw new RuntimeException( User id not found - +userId); } //retornará al usuario con id pasado en la url return user; } /*Este método se hará cuando por una petición POST (como indica la anotación) se llame a la url http://127.0.0.1:8080/api/users/  */ @PostMapping( /users ) public User addUser(@RequestBody User user) { user.setId(0); //Este metodo guardará al usuario enviado userService.save(user); return user; } /*Este método se hará cuando por una petición PUT (como indica la anotación) se llame a la url http://127.0.0.1:8080/api/users/  */ @PutMapping( /users ) public User updateUser(@RequestBody User user) { userService.save(user); //este metodo actualizará al usuario enviado return user; } /*Este método se hará cuando por una petición DELETE (como indica la anotación) se llame a la url + id del usuario http://127.0.0.1:8080/api/users/1  */ @DeleteMapping( users/{userId} ) public String deteteUser(@PathVariable int userId) { User user = userService.findById(userId); if(user == null) { throw new RuntimeException( User id not found - +userId); } userService.deleteById(userId); //Esto método, recibira el id de un usuario por URL y se borrará de la bd. return  Deleted user id -  +userId; } } Solucionar problema CORS en nuestra API Para que nuestra aplicación no nos de problemas a la hora de utilizarla desde otra dirección, debemos configurarla para que no de error de CORS, para ello debemos seguir las intrucciones de nuestro artículo 👉https://www.nigmacode.com/java/Solucionar-CORS-en-Spring De está forma, ya tendríamos nuestra API REST con Spring boot lista, ya solo quedaría levantar el servidor, como hemos dicho anteriormente, dando click derecho sobre ApiApplication.java y run as application"
    },

    {
        "id": 65,
        "autor": "Rosa",
        "pagina": "rosamarfil",
        "fecha": "05/05/2020",
        "titulo": "Crear una API REST Java con JAX-RS y Jersey",
        "link": "https://rosamarfil.es/tutoriales/programacion/crear-api-rest-java-jax-rs-jersey/",
        "contenido": "A continuación, explicaré cómo crear una API REST Java con JAX-RS y Jersey. Usaremos los métodos comunes para publicar los servicios en nuestra máquina local. ¿Qué es JAX-RS? Java API for RESTful Web Services. Es una especificación para crear Servicios Web REST que se basa en anotaciones para simplificar el desarrollo y despliegue de los clientes. ¿Qué es Jersey? Es un cliente RESTful e implementa JAX-RS. Facilita a los desarrolladores crear servicios web RESTful con Java. Las operaciones de un sistema REST y la especificación HTTP son cuatro: GET (leer) POST (crear) PUT (editar) DELETE (eliminar) Lo primero que hay que hacer es crear un proyecto web dinámico Java (mejor la última versión Java JDK 1.8) y configurarlo para poder trabajar con Maven. Yo he utilizado Eclipse como entorno de desarrollo. Si tienes dudas en cómo hacerlo, puedes consultar el tutorial Crear un proyecto web dinámico. Modificar fichero pom.xml Introduciremos las dependencias en el fichero de configuración de Maven. pom.xml <project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>API_REST_WS-RS</groupId> <artifactId>API_REST_WS-RS</artifactId> <version>0.0.1-SNAPSHOT</version> <packaging>war</packaging> <build> <sourceDirectory>src</sourceDirectory> <plugins> <plugin> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.0</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <plugin> <artifactId>maven-war-plugin</artifactId> <version>3.2.1</version> <configuration> <warSourceDirectory>WebContent</warSourceDirectory> </configuration> </plugin> </plugins> </build> <dependencies> <dependency> <groupId>javax.ws.rs</groupId> <artifactId>javax.ws.rs-api</artifactId> <version>2.1.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-<a href= https://rosamarfil.es/tutoriales/diccionario/servlet/  data-cmtooltip= Es una clase java que(...)  class= glossaryLink  >servlet</a></artifactId> <version>2.25.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.25.1</version> </dependency> </dependencies> </project> Crear el resto de clases User.java package es.rosamarfil.modelo; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } ServicioUsers.java package es.rosamarfil.services; import java.util.ArrayList; import java.util.List; import javax.ws.rs.BeanParam; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.GET; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.client.Entity; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; import javax.ws.rs.core.Response.Status; import es.rosamarfil.modelo.User; @Path( /users ) public class ServicioUsers { private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; /** * URL: http://localhost:8080/API_REST_WS-RS/api/users * @return Response list Users */ @GET @Produces(MediaType.APPLICATION_JSON) public Response getUsers() { return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/Rosa * * @param name String * @return Response */ @GET @Path( /{name} ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response getUserById(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/createUser Parameters in * Postman: { name : Rosa3333 , username : Marfi3333l } * * @param User * @return Response list NOTA: Si no existe el constructor vacío de User, da un *         error y el userRequest viene null. */ @POST @Path( /createUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response createUser(User userRequest) { this.listaUsuarios.add(userRequest); //return Response.status(Status.CREATED).build(); return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/updateUser Parameters in * Postman: { name : Rosa , username : Marfil3333 } * * @param User * @return user modified NOTA: Si no existe el constructor vacío de User, da un *         error y el userRequest viene null. */ @PUT @Path( /updateUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateUser(User userUpdate) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(userUpdate.getName())) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { found.setUsername(userUpdate.getUsername()); return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa * * @param User * @return Response */ @DELETE @Path( /deleteUser/{name} ) @Produces(MediaType.APPLICATION_JSON) public Response deleteUser(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); listaUsuarios.remove(found); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(listaUsuarios).build(); } } } Configuration.java package es.rosamarfil.services; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( api ) public class Configuration extends Application { } Probar nuestros Servicios Lo primero es levantar la aplicación. Para ello, selecciona el proyecto y ejecútalo sobre un servidor Apache previamente configurado. Si no sabes como configurarlo, puedes ver el tutorial Configurar Proyecto web y ver la sección Añadir Servidor Apache Tomcat a Eclipse. Crear una API REST Java con JAX-RS y Jersey Una vez arrancado el servidor con nuestra aplicación, podemos probar los servicios o bien desde la barra de direcciones de un navegador o desde algún programa cliente como Postman. La dirección base de nuestra aplicación es: http://localhost:8080/API_REST_WS-RS Vamos a ver los parámetros a introducir: GET (leer) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users GET (leer) a partir de un parámetro. En este caso buscaremos un usuario por nombre. En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/Rosa POST (crear) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/createUser y en la sección Body, introduce un usuario en formato json, como se muestra en la imagen: Crear una API REST Java con JAX-RS y Jersey PUT (editar) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/updateUser y en la sección Body de Postman introduce: {«name»:»Rosa»,»username»:»Marfil3333″} DELETE (eliminar) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa Y esto es todo!! Esta es una forma sencilla para empezar a crear servicios REST JAVA y crear una API REST Java con JAX-RS y Jersey."
    },

    {
        "id": 66,
        "autor": "AWS",
        "pagina": "amazon",
        "fecha": "01/01/2021",
        "titulo": "Tutorial: Crear una API de REST importando un ejemplo",
        "link": "https://docs.aws.amazon.com/es_es/apigateway/latest/developerguide/api-gateway-create-api-from-example.html",
        "contenido": "Puede utilizar la consola de Amazon API Gateway para crear y probar una API REST sencilla con integración HTTP para un sitio web PetStore. La definición de la API está preconfigurada como un archivo de OpenAPI 2.0. Después de cargar la definición de API en API Gateway, puede utilizar la consola de API Gateway para examinar la estructura básica de API o simplemente implementar y probar la API. La API de ejemplo de PetStore admite los siguientes métodos para que un cliente obtenga acceso al sitio web de backend HTTP de http://petstore-demo-endpoint.execute-api.com/petstore/pets. GET /: para leer el acceso del recurso raíz de la API que no se integra con ningún punto de enlace de backend. API Gateway responde con información general del sitio web PetStore. Este es un ejemplo del tipo de integración MOCK. GET /pets: para obtener acceso de lectura al recurso /pets de la API que se integra con el recurso /pets de backend asignado. El backend devuelve una página de mascotas disponibles en PetStore. Este es un ejemplo del tipo de integración HTTP. La URL del punto de enlace de integración es http://petstore-demo-endpoint.execute-api.com/petstore/pets. POST /pets: para obtener acceso de escritura al recurso /pets de la API que se integra con el recurso /petstore/pets de backend. Tras recibir una solicitud correcta, el backend agrega la mascota especificada a PetStore y devuelve el resultado al autor de la llamada. La integración también es HTTP. GET /pets/{petId}: para obtener acceso de lectura a una mascota identificada por un valor petId tal como se especifica en una ruta variable de la URL de solicitud de entrada. Este método también tiene el tipo de integración HTTP. El backend devuelve la mascota especificada que se encuentra en PetStore. La URL del punto de enlace HTTP del backend es http://petstore-demo-endpoint.execute-api.com/petstore/pets/n, donde n es un entero como identificador de la mascota consultada. La API admite el acceso a CORS a través de los métodos OPTIONS del tipo de integración MOCK. API Gateway devuelve los encabezados solicitados que admiten el acceso a CORS. El siguiente procedimiento le guiará por los pasos para crear y probar una API a partir de un ejemplo mediante la consola de API Gateway. Para importar, desarrollar y probar la API de ejemplo Si aún no lo ha hecho, realice los pasos de Requisitos previos para comenzar con API Gateway. Inicie sesión en la consola de API Gateway en https://console.aws.amazon.com/apigateway. Si es la primera vez que utiliza API Gateway, verá una página en la que aparecen las características del servicio. En REST API, elija Build (Compilación). Cuando aparezca el menú emergente Create Example API (Crear API de ejemplo), elija OK (Aceptar). Si esta no es la primera vez que utiliza API Gateway, elija Create API (Crear API). En REST API, elija Build (Compilación). En Create new API (Crear nueva API), elija Example API (API de ejemplo) y, a continuación, elija Import (Importar) para crear la API de ejemplo. Para la primera API, la consola de API Gateway comienza con esta opción de forma predeterminada. Puede desplazarse por la definición de OpenAPI para obtener información detallada sobre esta API de ejemplo antes de elegir Import (Importar). La API recién creada se muestra de la siguiente forma: El panel Resources (Recursos) muestra la estructura de la API creada como un árbol de nodos. Los métodos de API definidos en cada recurso son los extremos del árbol. Cuando se selecciona un recurso, todos sus métodos se muestran en el panel Methods (Métodos) situado a la derecha. Debajo de cada método hay un breve resumen del método, incluidos sus requisitos de URL de punto de enlace, tipo de autorización y clave de API. Para ver los detalles de un método, para modificar su configuración o para probar la invocación del método, elija el nombre del método en la lista de métodos o en el árbol de recursos. A continuación, elegimos el POST /pets método como ejemplo: El panel resultante Method Execution (Ejecución del método) presenta una vista lógica de la estructura del método (POST /pets) elegida y los comportamientos: Method Request (Solicitud de método) y Method Response (Respuesta de método) son la interfaz de la API con el frontend de la API (un cliente), mientras que Integration Request (Solicitud de integración) e Integration Response (Respuesta de integración) son la interfaz de la API con el backend (http://petstore-demo-endpoint.execute-api.com/petstore/pets). Un cliente utiliza la API para obtener acceso a una característica del backend a través de Method Request (Solicitud de método). API Gateway traduce la solicitud del cliente, si fuera necesario, a un formato aceptable por el backend en Integration Request (Solicitud de integración) antes de reenviar la solicitud entrante al backend. La solicitud transformada se conoce como la solicitud de integración. Del mismo modo, el backend devuelve la respuesta a API Gateway en Integration Response (Respuesta de integración). A continuación, API Gateway la dirige a Method Response (Respuesta de método) antes de enviarla al cliente. De nuevo, si fuera necesario, API Gateway puede asignar los datos de la respuesta del backend a un formulario previsto por el cliente. En el caso del método POST de recurso de API, la carga de la solicitud del método puede transmitirse a través de la solicitud de integración sin modificación si la carga de la solicitud de método está en el mismo formato que la carga de la solicitud de integración. La solicitud del método GET / usa el tipo de integración MOCK y no está vinculada a ningún punto de enlace de backend real. La Integration Response (Respuesta de integración) correspondiente está configurada para devolver una página HTML estática. Cuando se llama al método, API Gateway simplemente acepta la solicitud e inmediatamente devuelve la respuesta a la integración configurada al cliente a través de Method Response (Método de respuesta). Puede utilizar la integración simulada para probar una API sin requerir un punto de enlace del backend. También puede utilizarla para servir una respuesta local generada partir de una plantilla de asignación de cuerpo de respuesta. Como desarrollador de la API, puede controlar los comportamientos de las interacciones del frontend de la API mediante la configuración de la solicitud de método y una respuesta de método. Puede controlar los comportamientos de las interacciones del backend de la API mediante la configuración de la solicitud de integración y la respuesta de integración. Estos comportamientos implican asignaciones de datos entre un método y su integración correspondiente. Explicaremos cómo configurar un método en Tutorial: Desarrollo de una API de REST con integración HTTP no de proxy. Por el momento, nos centraremos en probar la API para proporcionar una experiencia de usuario completa. Elija Test (Probar) en Client (Cliente) (tal y como se muestra en la imagen anterior) para comenzar la prueba. Por ejemplo, para probar el método POST /pets, escriba la siguiente carga { type :  dog , price : 249.99} en Request Body (Cuerpo de la solicitud) antes de elegir el botón Test (Probar). La entrada especifica los atributos de la mascota que deseamos añadir a la lista de mascotas en el sitio web PetStore. El resultado es el siguiente: La entrada Logs (Registros) de la salida muestra los cambios de estado de la solicitud del método a la solicitud de integración y de la respuesta de integración a la respuesta del método. Esto puede resultar útil para la resolución de errores de asignación que impidan que la solicitud se realice correctamente. En este ejemplo, la asignación no se aplica: la carga de la solicitud de método se transfiere a través de la solicitud integración al backend y, de forma parecida, la respuesta del backend se transfiere a través de la respuesta de integración al método de respuesta. Para probar la API con un cliente distinto de la característica test-invoke-request de API Gateway, primero debe implementar la API en una etapa. Para implementar la API de ejemplo, seleccione la API PetStore y, a continuación, elija Deploy API (Implementar API) en el menú desplegable Actions (Acciones). En Deploy API (Implementar API), para Deployment stage (Etapa de implementación), elija [New Stage] (Nueva etapa) porque esta es la primera implementación de la API. Escriba un nombre (por ejemplo, test) en Stage name (Nombre de etapa) y, si lo desea, escriba las descripciones en Stage description (Descripción de etapa) y Deployment description (Descripción de implementación). Elija Deploy (Implementar). En el panel Stage Editor (Editor de etapas) resultante, Invoke URL (URL de invocación) muestra la dirección URL para invocar la solicitud del método GET / de la API. En Stage Editor (Editor de etapas), siga el enlace Invoke URL (URL de invocación) para enviar la solicitud del método GET / en un navegador. Una respuesta correcta devuelve el resultado, generado a partir de la plantilla de asignación de la respuesta de integración. En el panel de navegación Stages (Etapas), expanda la etapa test (prueba), seleccione GET en /pets/{petId} y, a continuación, copie el valor Invoke URL (URL de invocación) de https://api-id.execute-api.region.amazonaws.com/test/pets/{petId}. {petId} hace referencia a una variable de ruta. Pegue el valor de Invoke URL (URL de invocación) (obtenido en el paso anterior) en la barra de direcciones de un navegador, sustituyendo {petId} por, por ejemplo, 1 y, a continuación, pulse Intro para enviar la solicitud. Debería devolverse una respuesta 200 OK con la siguiente carga JSON: { id : 1, type :  dog , price : 249.99 } La invocación del método de la API tal como se muestra es posible porque su tipo Authorization (Autorización) está establecido en NONE. Si se ha utilizado la autorización de AWS_IAM, firmaría la solicitud con los protocolos Signature Version 4 (SigV4). Para ver un ejemplo de una solicitud de este tipo, consulte Tutorial: Desarrollo de una API de REST con integración HTTP no de proxy."
    },

    {
        "id": 67,
        "autor": "Adrian Francisco Becerra Arias",
        "pagina": "soloenbinario",
        "fecha": "30/07/2019",
        "titulo": "Creando servicios REST con JAVA",
        "link": "https://soloenbinario.wordpress.com/2019/07/30/creando-servicios-rest-java/",
        "contenido": "Actualmente la gran mayoría de aplicaciones cuentan con, por lo menos, un servicio WEB. En los últimos tiempos se ha popularizado una nueva forma de crear y consumir servicios llamado RESTful. Este tipo de servicios ha tenido una gran acogida por su fácil uso y también por los tiempos de respuesta cuando se consumen estos. Dada esta pequeña introducción vamos al grueso del asunto y para ello vamos a utilizar las siguientes herramientas: Eclipse 2018-09 o superior. Maven 3.5.4 Jersey 2.27 JAXB 2.3.1 Creando el servicio WEB Vamos a crear una aplicación WEB y para ello escoge la opción haciendo clic derecho, New -> Other… -> WEB -> Dynamic WEB Project. Selecciona la opción Next. Ahora dale un nombre a tu aplicación WEB y selecciona la opción Next. En la siguiente pantalla no es necesario configurar nada por lo que puedes seleccionar la opción Next. En esta pantalla selecciona la opción Genérate web.xml deployment descriptor. Es importante que lo selecciones porque en este archivo de configuración vamos definir el API REST y también cuales son las clases que se encargan de publicar los servicios que vamos a definir. Seleccionadas las opciones importantes, ahora selecciona la opción Finish. Configurando Maven Has clic derecho sobre tu aplicación WEB recientemente creada y selecciona la opción Configure -> Convert to Maven Project… En la ventana que aparece puedes configurar los datos que aparecen allí, te recomiendo que el packaging no lo modifiques. Luego, selecciona la opción Finish. Configuración del POM Ahora vamos a realizar lo siguiente: Vamos a importar las dependencias necesarias para que los servicios WEB funcionen sin problemas, y vamos a configurar el nombre del servicio WEB. Las dependencias que te recomiendo para la configuración de un servicio WEB RESTful son: Glassfish Jersey Core Server. Glassfish Jersey Containers Servlet. Glassfish Jersey Inject HK2. Glassfish Jersey Media JSON Jackson. JAXB. Estas dependencias las puedes encontrar en la pagina MVNRepository, sin embargo aquí te los dejo (Recuerda que el siguiente bloque debe ir después de la etiqueta <build></build>): <dependencies> <dependency> <groupId>org.glassfish.jersey.core</groupId> <artifactId>jersey-server</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-servlet</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.inject</groupId> <artifactId>jersey-hk2</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> </dependencies> Creación del servicio WEB Vamos ahora con la creación de la clase y los métodos de consumo. Lo primero que vas a hacer es crear el package y luego vas a crear la clase que será el servicio WEB como tal. Luego vamos a agregar algunas anotaciones para que nuestro API REST funcione. Para este ejercicio vamos a crear métodos de consumo de tipo GET y tipo POST que retornaran los siguiente: Datos de tipo String. Datos de tipo XML. Datos de tipo JSON. Objetos Objetos de tipo Response. Empecemos. Creada la clase vamos a agregarle encima del nombre de la misma la anotación @Path. Método que retorna un objeto de tipo String Dentro de la clase crea una método que retorne datos de tipo String. Cuando lo hayas creado, agrégale las anotaciones @GET, @Path y @Produces quedando de la siguiente manera: Método que retorna información en formato XML Crea un método que retorne datos de tipo XML. Lo que vas a realizar a continuación es crear un objeto que va a ser retornado por el método en cuestión. Este objeto debe tener lo siguiente para que el API REST lo transforme a XML: Anotaciones JAXB. Un constructor vacío. En ese orden de ideas, crea tu clase la cual deberá quedar como el siguiente ejemplo: Cuando hayas creado el objeto, crea tu método y agrega las anotaciones @GET, @Path, @Produces y dentro de esta última anotación agrega el MediaType APPLICATION_XML quedando de la siguiente manera: Método que retorna información en formato JSON Crea un método que retorne datos en formato JSON. La creación es bastante similar al método que retorna datos en formato XML, lo único que cambia es el tipo de MediaType que es APPLICATION_JSON. Entonces, el resultado deberá ser el siguiente: Método con paso de parámetros mediante PathParam Crea un método que va a recibir un parámetro por la URL. En este caso será un parámetro que reciba uno o varios argumentos y por cada argumento tienes que anteceder la anotación @PathParam([nombre_parametro]) donde nombre_parametro será el alias del parámetro que debe ser parte de la URI, así: Como te comenté, en la anotación @PathParam colocamos el alias p. Si te das cuenta este alias aparece como parte de la URI dentro de la anotación @Path. Entonces, cuando realices el consumo del servicio WEB lo que debe ir en {p} es el dato que vas a pasar al método del servicio REST. Método con paso de parámetros mediante QueryParam Un método con paso de parámetros mediante QueryParam sería, por ejemplo, http://localhost:8080/SampleREST/rest/WebServiceRest/bienvenida/json_qp?p=dato. De este modo, crea un método que retorne un objeto y que este sea retornado en formato JSON y luego agrégale la cantidad de argumentos que necesites pasarle. A cada uno de ellos debes anteponerle la anotación @QueryParam que entre paréntesis debe ir el nombre del parámetro que será enviado por Query String. Es decir, que en la URL que mencioné anteriormente estamos enviando un dato a la variable p, en la anotación @QueryParam debe ir el dato llamado p, quedando de la siguiente manera: Método POST En la creación de métodos POST las variaciones con respecto a un método de tipo GET son que, debemos decirle qué tipo de información va a consumir, el tipo de información que va a producir y el retorno será un dato de tipo Response. En este orden de ideas créate un método con la anotación @POST y la anotación @Consumes la cual va a aceptar datos en formato JSON. Como parámetros al método puedes pasarle un objeto y el dato de retorno un objeto de tipo Response. De resto las anotaciones @Path y @Produces siempre van a ser las más comunes en todos los métodos de un servicio REST. El método debería quedar como este: Creando un cliente para el consumo de los servicios Con pocas líneas de código se pueden crear clientes de consumo de servicios WEB REST en JAVA. Vamos a crear un cliente en JAVA SE para que veas el funcionamiento. Creando el proyecto En Eclipse, haz clic derecho y selecciona la opción New -> Other… Selecciona la opción Java Project. Ahora selecciona un nombre para tu nuevo cliente REST y luego selecciona la opción Finish. Una vez se haya terminado la creación del cliente, has clic derecho en él y selecciona la opción Configure -> Convert to Maven Project. En la nueva ventana que aparece, lo puedes dejar como lo sugiere el asistente y presionas la opción Finish. Las dependencias que puede usar para la creación de los métodos cliente son: <dependencies> <dependency> <groupId>org.glassfish.jersey.core</groupId> <artifactId>jersey-client</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.inject</groupId> <artifactId>jersey-hk2</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> <dependency> <groupId>com.googlecode.json-simple</groupId> <artifactId>json-simple</artifactId> <version>1.1.1</version> </dependency> </dependencies> Creación de la clase cliente En la carpeta src has clic derecho y selecciona la opción New -> Class. En la nueva ventana que aparece selecciona un paquete y luego Escribe el nombre de la clase. Si el paquete que escribiste no existe, no hay problema. El asistente lo crea automáticamente. Ahora Selecciona la opción Finish. Ahora vamos a crear los siguientes métodos que van a consumir cada uno de las funciones que creamos para el servicio REST. Haciendo recuento, los métodos son: Método para retornar datos de tipo String. Método para retornar datos de tipo XML. Método para retornar datos de tipo JSON. Método para retornar objetos de tipo Response. Y los tipos de consumo son: Get Post QueryParam PathParam Declarando las instancias para el consumo del servicio Empieza con crear una instancia de tipo Client. como aparece a continuación: Como puedes observar en la imagen anterior, puedes crear una instancia para toda la clase o bien puedes crear la instancia en cada método donde la vayas a utilizar. La elección es tuya. Consumiendo datos de tipo XML, JSON y String ¿Por qué este apartado abarca tres tipos de datos diferentes? Resulta que lo que vas a ver a continuación es el consumo de servicios de datos de tipo String, JSON y XML con las mismas líneas de código. Es decir que lo único que cambia son los tipos de retorno y las URIs de los servicios WEB. Así pues esta son las líneas de código que deberías usar para consumir los servicios retornando datos String, XML y JSON: En esta instancias lo que debes cambiar para este ejemplo es el target, el request, el accept y el get. En conclusión los métodos quedarían construidos de la siguiente manera: Consumiendo métodos Path Param El consumo de este tipo de servicios es muy similar al que vimos para consumir datos de tipo String, JSON y XML. Lo único que debemos agregar es el método path() después del método target() donde va la URI a consumir, quedando de la siguiente manera: Consumiendo métodos Query Param Exactamente igual que consumir métodos de tipo Path Param, así son los que se pasan datos por Query String. Después del método target() agrega el método queryParam() en el cual el primer argumento es el nombre de la variable Query String y en el segundo argumento colocas el valor para la variable. Recuerda que el nombre de la variable debe ser exactamente igual al que definiste en el método del servicio WEB. Así quedaría: Consumiendo métodos POST Quizá este puede ser el método al cual toca agregarla un poco mas de líneas de código. Pero a la final es un código bastante sencillo de digerir. Como te puedes dar cuenta se necesita crear lo siguiente: Crear una nueva instancia del objeto que vas a enviar. Luego creamos una instancia de tipo Client. Crear una instancia de tipo WebTarget la cual va a recibir la URI del método del servicio a consumir. Crear una instancia de tipo Builder en la cual vamos a solicitar que el servicio nos retorne la información en formato JSON. Crear una instancia de tipo Response en donde vamos a pasar como parámetro el objeto que instanciaste en el punto No . 1. Como pudiste observar, entender y practicar a lo largo de este POST, la creación de servicios WEB REST es bastante sencilla por lo cual a futuro no tendrás tanto problema cuando empieces a crearlos en forma. Espero que este contenido haya sido de gran ayuda para ti. El código fuente de estos ejercicios los puedes encontrar en los siguientes enlaces: Servicio REST: https://github.com/elle184/ScriptsJAVA/tree/master/SampleREST Cliente del servicio REST: https://github.com/elle184/ScriptsJAVA/tree/master/SampleRestClient"
    },

    {
        "id": 68,
        "autor": "Csacanam",
        "pagina": "platzi",
        "fecha": "01/02/2015",
        "titulo": "Cómo crear un API con Spark Java",
        "link": "https://platzi.com/blog/api-spark-java/",
        "contenido": "No es un secreto que el enfoque de Java hacia las aplicaciones web empresariales ha generado opiniones encontradas. Por una parte, Java EE es una arquitectura ideal para hacer aplicaciones de ese tipo, pues el servidor provee características importantes como la seguridad; sin que el desarrollador deba preocuparse por eso. Sin embargo, esto también provoca que sea más complicado desarrollar proyectos más livianos;  pues se requiere de varias configuraciones para lograr hacerlo funcionar. Por esta razón, han surgido varias iniciativas para evitar que la popularidad de Java en la web disminuya. Actualmente, ocupa el tercer lugar en popularidad de lenguajes del lado del servidor. Por debajo de PHP y ASP .NET y por encima de lenguajes como Python y Ruby. Esas iniciativas no apuntan a que se deje de lado a Java EE; sino que buscan solucionar las necesidades de los nichos de las aplicaciones web empresariales. Por otro lado, también surgieron otras que buscan solucionar necesidades menos exigentes de una forma más ágil; y ese es el caso del framework Spark Java. Se trata de un framework web liviano inspirado en Sinatra (framework basado en Ruby), que permite crear aplicaciones web con Java 8 con el mínimo esfuerzo. El objetivo principal de este artículo es introducir el framework y crear una solución sencilla que te permita entender cómo podrías hacer uso del mismo. Para poder seguir el tutorial es necesario que tengas instalado el Java Development Kit 8 (JDK 8). Se puede instalar en Windows, Mac o Linux y descargar en la página oficial de Oracle. Adicionalmente, requerirás de un entorno de desarrollo (IDE) para Java que te permita crear un proyecto de Maven. Puedes hacer uso de Eclipse, IntelliJ o NetBeans. En mi caso, voy a hacer uso de la versión 8.0.2 de NetBeans para Java EE. Y si estás iniciando en el desarrollo de aplicaciones con este lenguaje, no te puedes perder el curso gratuito de Java Básico en Platzi. Aprenderás todo lo que necesitas saber para crear proyectos desde cero. ¿Qué es Spark? Es un micro framework web de Java basado en Sinatra, cuyo tamaño total no excede 1 MB. Para poder mantener un código limpio, los desarrolladores decidieron dejar de soportar Java 7 y aprovechar la simplicidad que ofrece Java 8. Por esta razón, en Spark 2 sólo se puede desarrollar con esta versión del lenguaje. En las imágenes abajo puedes observar el cambio que hubo en el Hello World de Spark 1 a Spark 2. Hello World en Spark 1 API Spark Java Hello World en Spark 2 API Spark Java ¿Para qué se usa Spark? Aunque Spark está basado en Sinatra, no se presenta como una competencia. Su finalidad es que haya una alternativa para los desarrolladores Java, que les permita desarrollar rápidamente aplicaciones web con el lenguaje que ya conocen. Según una encuesta que realizó el equipo de Spark este año, se dio a conocer que alrededor del 50% de los usuarios de Spark lo usan para crear APIs REST y un 25% lo usa para crear páginas web. También mencionan que el 15% de las aplicaciones Spark desplegadas sirven a más de 10.000 usuarios a diario. Con estos datos podemos concluir que es un framework adecuado si la finalidad es construir un API con Java de forma ágil. Creando un Hello World Después de haber instalado el JDK 8 y Netbeans para Java EE, abriremos el último y crearemos un nuevo proyecto File > New project. En el diálogo seleccionamos la carpeta Maven y elegimos Java Application. A continuación seleccionamos la opción Next. API Spark Java En el siguiente diálogo ingresamos el nombre del proyecto y damos clic en Finish. API Spark Java De esta manera, NetBeans creará un proyecto con la estructura de un proyecto Maven. Los elementos sobre los que trabajaremos serán el paquete ubicado en Source Packages y el archivo pom.xml  ubicado en Project Files. API Spark Java Si abrimos el archivo pom.xml encontraremos un contenido parecido al siguiente: [java] <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>com.peewah</groupId> <artifactId>holaplatzi</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <maven.compiler.source>1.7</maven.compiler.source> <maven.compiler.target>1.7</maven.compiler.target> </properties> </project> [/java] Lo que debemos hacer a continuación es agregar la dependencia de Spark al archivo para que Maven lo instale en el proyecto. Nuestro archivo pom.xml quedaría así: [java] <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>com.peewah</groupId> <artifactId>holaplatzi</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <maven.compiler.source>1.7</maven.compiler.source> <maven.compiler.target>1.7</maven.compiler.target> </properties> <!-- Dependencias de Maven --> <dependencies> <!-- Dependencia Spark Java --> <dependency> <groupId>com.sparkjava</groupId> <artifactId>spark-core</artifactId> <version>2.3</version> </dependency> </dependencies> </project> [/java] Para que Maven instale la librería, debemos dar clic derecho sobre el proyecto y seleccionar la opción Build. Al terminar la compilación, nuestro proyecto tendrá instalado Spark Java. Ahora que ya configuramos lo necesario para agregar Spark Java al proyecto, vamos a escribir el código necesario. Para lograrlo damos clic derecho sobre el paquete en Source Packages, seleccionamos New y luego Other. API Spark Java En el diálogo seleccionamos la carpeta Java; elegimos Java Class y damos click en Next. API Spark Java En el siguiente diálogo escribimos el nombre de nuestra clase, HolaPlatzi en este caso, y seleccionamos Finish. API Spark Java NetBeans nos crea nuestra clase y la coloca dentro del paquete que hemos creado previamente. El código inicial debe ser algo así: [java] package com.peewah.holaplatzi; /** * * @author csacanam */ public class HolaPlatzi { } [/java] A continuación, agregaremos el código necesario para crear un servicio web de tipo GET que retorne un mensaje que podremos observar en el navegador. Para lograrlo debemos crear el método main, que es el punto de entrada en una aplicación Java. Dentro de main se agrega el servicio web de tipo GET. En la línea de código donde lo definimos, es necesario especificar el tipo, la ruta (/hello), los parámetros req (request) y response (res) y por último, el mensaje que se va a mostrar en el navegador. Así, la clase que creamos anteriormente debe quedar así: [java] package com.peewah.holaplatzi; import static spark.Spark.*; /** * * @author csacanam */ public class HolaPlatzi { public static void main(String[] args) { get( /hello , (req, res) ->  Hola Platzi. Saludos desde Peewah. ); } } [/java] Si NetBeans indica que hay un error por las expresiones lambda, debemos dar clic derecho sobre el proyecto y seleccionar Properties. En la categoría Sources debemos cambiar la opción Source/Binary Format a 1.8. Esto sólo estará disponible si hemos instalado previamente el JDK 8. Para ejecutar el proyecto, elegimos la opción correr proyecto en el botón verde en la parte superior o presionamos F6. Al hacer esto, se abrirá un diálogo donde se indicará que seleccionemos la clase principal (hasta el momento solamente tenemos creada una). Después de esto, presionamos la opción Select Main Class. API Spark Java Después de unos cuantos segundos la consola nos muestra un mensaje similar al mostrado a continuación, indicando que el servidor está corriendo por el puerto 4567. Este es el puerto por defecto de Spark Java. Sin embargo, podemos modificarlo si así lo deseamos. API Spark Java Para probar que nuestro servicio web está funcionando, abrimos nuestro navegador de preferencia y ponemos la dirección http://localhost:4567/hello. El resultado del navegador deberá mostrar algo así: API Spark Java Y así es como logramos crear de forma sencilla y rápida un servicio web con Spark Java que retorna un mensaje de saludo. Si te interesa saber más y conocer el potencial de este framework web y, además, aprender a escribir y leer código en Java, buenas prácticas de programación, paradigma de orientación a objetos y todos los elementos que necesitas para programar desde cero;"
    },

    {
        "id": 69,
        "autor": "Javi Moreno",
        "pagina": "programar",
        "fecha": "18/12/2016",
        "titulo": "Cómo Crear Una API REST",
        "link": "https://programar.cloud/post/como-crear-un-api-rest/",
        "contenido": "Vamos a ponernos el gorrito de un miembro del equipo, en concreto la persona que se haya asignado la tarea de implementar la historia de usuario PROGRESO_CURSOS. ¿La recuerdas del post anterior ? Decía algo así: Como administrador de cursos deseo poder obtener una visualización global de la utilización de cada curso y unidad didáctica para conocer su popularidad y actuar en consecuencia.* Bien, manos a la obra: tendremos que detectar los recursos a manipular, definir unas rutas HTTP claras para invocar operaciones sobre ellos y generar la respuesta deseada. No problem. O sí. ¡Ojo! Para que no haya confusiones entre el rol ágil de product owner y el cargo que ostenta el cliente para el que desarrollamos la aplicación (descrito también como propietaro del producto originalmente pero que no siempre tiene por qué coincidir) he cambido el nombre de este último a un mucho más lógico administrador de cursos. Mil perdones, esta noche me pego unos latigazos. Umh… Vale, ya podemos seguir. Fundada en 1880source: imgur.com Los Recursos En la Wikipedia tienes una buena descripción sobre REST, no voy a repetirte lo que hay allí: mi plan es ir contándote los detalles que hagan falta en el momento en el que los necesites, no adelantarlos todos para después aplicarlos. Es como a mí me gusta aprender. Pero si prefieres hacerte una idea de lo que vamos a hablar antes de seguir no te cortes y visita el link antes de continuar leyendo. Tampoco te preocupes si tu programación está un poco oxidada, verás que no hago mucho hincapié en ese aspecto en este post. Lo primero que tenemos que tener claro es que REST se estructura alrededor de recursos, las entidades que permites manipular. Esas entidades deben quedar representadas en la URL (la ruta) que se utiliza para ejecutar operaciones sobre ellas. Así que el primer paso es definir la lista de recursos y para ello vamos a echar un vistazo a la historia de usuario. El administrador de cursos, claramente, es un actor involucrado que en el fondo corresponderá a un tipo de usuario. No va a tener un papel relevante más allá de la autorización: qué operaciones puede invocar y a qué información tiene acceso. Así que de momento aparcamos su implementación. Esto generará una nueva tarea que consistirá en integrar el sistema de permisos en la funcionalidad que implementemos ahora mismo pero ya la llevaremos a cabo más tarde. Lo comentamos con el resto del equipo, apuntan la nueva tarea y pasamos al siguiente paso. Fíjate en algo importante: hemos pedido una aclaración. Qué loco. Durante el desarrollo. Seguimos revisando la historia de usuario. ¡Encontramos otro sustantivo: curso! Claramente aquí tenemos nuestro primer recurso. Preguntamos al product owner y nos comenta que un curso básicamente ahora mismo está definido por un código alfanumérico único e inmutable, un título en español, una descripción de unas 100 palabras y una serie de unidades didácticas. Fíjate en algo importante: hemos pedido una aclaración. Qué loco. Durante el desarrollo. Más te vale que sea posible llevar a cabo esta acción de la manera más eficiente posible si no quieres acabar como yo en ese horrible proyecto . De la historias de usuario y de la última conversación detectamos que existe otro recurso llamado unidad didáctica. De nuevo el product owner nos explica que cada una de ellas tiene un número de orden (no consecutivo e inmutable) y un título. Usando el código es posible generar el link al post que en el fondo la implementa. El product owner nos dice que simplemente quiere saber cuánta gente ha participado activamente en cada uno de los cursos y en cada una de las unidades didácticas y que ello puede saberse contando cuántas personas han cambiado el estado de una unidad a “completado”. Así que ya tenemos nuestra lista inicial de recursos: curso y unidad-didactica. Además hay una relación jerárquica clarísima entre ellos: un curso está compuesto de unidades didácticas. Compartimos esta información con el resto del equipo que no ha estado presente en la conversación porque está claro que les hará falta y no queremos que nuestro product owner nos odie más de lo imprescindible por preguntarle diez veces lo mismo. Las Operaciones ¡Son consultas, está bastante claro! En concreto confirmamos con el product owner que está interesado en poder visualizar datos del número de estudiantes que han participado en cada curso y también quiere ver el número de estudiantes que han participado en cada lección de un curso concreto entre un rango de fechas determinado. La aclaración no es muy diferente de lo que nos había comentado en la reunión de planificación así que decidimos que podemos implementarlo. Pero no tiene por qué ser así: si el trabajo de planificación fue pobre y fallamos en describir correctamente la tarea resulta imposible estimar su duración correctamente. En ese caso la mejor opción es siempre crear nuevas tareas con los detalles extra que no se puedan asumir en este sprint y dejarlos pendientes para el siguiente. Si implementar el filtro hubiese supuesto mucho trabajo eso es exactamente lo que habríamos hecho. Y ¿sabes una cosa que a mí me sigue costando pero que poco a poco voy aprendiendo? Sí, exacto: a decir NO. Y es crítico hacerlo cuando estás en este tipo de desarrollo y se propone un cambio de funcionalides importante porque te has comprometido a muy corto plazo para completar una serie de tareas. Si tienes problemas enfrentándote a las peticiones del product owner, avisa al scrum master: sus responsabilidades incluyen además de hacer cafés el mantener la dinámica del sprint y (si es necesario) controlar las peticiones del product owner. grumpy cat dice NO.source: imgur.com Bien, volvamos a las operaciones. Vamos a definir rutas que tengan cierta semántica y utilizaremos el plural para representar el recurso (en serio, hazlo, todo queda más natural). Recuerda (por lo que has leído en la Wikipedia) que en REST nos vamos a esforzar en utilizar la semántica original del protocolo HTTP para describir qué queremos hacer sobre esos recursos. Si repasas la RFC de HTTP (no, en serio, hazlo, que es súper legible y sencilla) verás que para obtener un documento debe usarse el método GET. También vamos a tomar la convención de que si una parte de la ruta es variable (para especificar un subconjunto del total de recursos) colocaremos su identificador entre llaves. Digamos que definimos estas operaciones: GET /cursos GET /cursos/{codigo}/unidades-didacticas La primera nos retornará la información de todos los cursos y la segunda información sobre las unidades didácticas de un curso concreto. Un ejemplo de la segunda URL en la que se ha aplicado un valor a la parte variable sería: /cursos/introduccion/unidades-didacticas indicando que quieres conocer los datos de las unidades didácticas del curso con el código introduccion. Así que ¿qué te parece esta primera aproximación? Exacto: posiblemente nos hemos venido arriba. La primera ruta representa todos los cursos con lo que semánticamente sería perfectamente aceptable devolver todos los datos asociados a los mismos. Esto incluiría el número de alumnos inscritos pero también la descripción. Y este último atributo nos supone una sobrecarga de unos 500 bytes por cada uno de los cursos que no vamos a utilizar para solucionar este caso de negocio. Este es el criterio importante: cómo se adapta nuestra operación a la query que necesitamos responder por lo que decidimos que este diseño supone demasiado sobrepeso en el documento de respuesta y tenemos que buscar una solución alternativa. Este es el criterio importante (cómo se adapta nuestra operación a la query que necesitamos responder). Hay dos opciones. La primera sería añadir un mecanismo por el cual podamos especificar en la URL una proyección, que es una forma elegante de decir que solo quieres parte de la información disponible en cada momento. Esta opción la implementaríamos con parámetros en la querystring de la URL. O bien también puedes crear un nuevo recurso dependiente del anterior que solo incluya la información que necesitamos. Calma, ahora te enseño dos ejemplos: GET /cursos?proyeccion=titulo,actividad GET /cursos/actividad ¿Qué te parece mejor? Pues ésa es la decisión correcta. En mi caso creo que la segunda opción se entiende mejor, es más legible sobre todo si más adelante tenemos que utilizar la querystring para alguna otra cosa. Y seguramente también tiene una semántica más fuerte. Así que optamos por ella. Pero no deja de ser una decisión de diseño, defiéndela como tal. Por coherencia seguimos la misma táctica con las unidades didácticas. Y nuestra API queda así: GET /cursos/actividad GET /cursos/{codigo}/unidades-didacticas/actividad Bien, perfecto. Funcionará. Ahora tenemos que solucionar el extra del que hemos hablado antes: el poder filtrar entre un rango de fechas. Y aquí sí es muy cómodo y natural ampliar la información que proporcionamos en forma de querystring, como parámetros opcionales. Por ejemplo: GET /cursos/actividad?desde={fechaInicial}&hasta={fechaFinal} El formato para especificar fechas más popular es el de ISO-8601. Y vigila, porque ya sabes que en informática las fechas tienen siempre más peligro que una piraña en un bidé: almacena el dato siempre en UTC y solo cuando dibujes pantallas preséntalo en el formato local del usuario. O tendrás poblemas. Serios. Básicamente la UTC (Coordinated Universal Time acronimizado por alguien que llevaba dos cervezas de más) se determina a partir de las oscilaciones de más de 70 relojes atómicos y es en el fondo el valor reconocido internacionalmente como fecha actual independientemente de la zona horaria en la que te encuentres. Bien, filtro solucionado. Un inciso ¿tendría sentido una ruta de este estilo? /cursos/{codigo-curso}/unidades-didacticas/{numero-ul}/actividad Probablemente no: el resultado sería simplemente un número con el número de unidades didácticas completadas y estarías pagando toda la latencia de una petición/respuesta para conseguir una información demasiado precisa. Tardarías lo mismo (o casi) en retornar todos los datos de la unidad didactica que seleccionases (código, título, actividad, etc) y además con toda seguridad ese sería el caso de uso real de la operación: manipular la ficha entera de una unidad didáctica, no solo conocer los estudiantes que la han completado. La ruta quedaría sin el recurso final: /cursos/{codigo-curso}/unidades-didacticas/{numero-ul} Si te parece complicado, piensa en pantallas para humanos: posiblemente crearías una para visualizar la ficha de una unidad didáctica pero no para presentar tan solo la actividad que ha recibido. La mejor manera de incrementar tu productividad es no hacer lo que nadie ha pedido. Pero recuerda que nadie nos ha pedido esta funcionalidad y que la mejor manera de incrementar tu productividad es no hacer lo que nadie ha pedido. Las Respuestas Una vez solucionado el cómo invocamos la operación tenemos que decidir el formato en el que responderemos. Y sé lo que esperas: esperas que te diga que XML es muerte y hay que usar JSON. Y lo cierto es que XML es muerte pero si tu usuario (¡el consumidor del API!) trabaja con XML es tu responsabilidad darle esa opción: que sea él quien con por ejemplo la cabecera Accept de HTTP te indique qué prefiere. La enorme mayoría de frameworks del mundo permiten generar los dos formatos automáticamente así que ante todo mucha calma. Por cierto, una cabecera HTTP es… no, espera, mejor échale un vistazo a este vídeo que describe HTTP para entender los detalles de este protocolo. Lo que te enseño ahora es un ejemplo del posible resultado para ambas APIs para la petición /cursos/actividad?desde=2016-11-01T00:00:00-00:00&hasta=2000-10-31T23:59:59-00:00 [ { codigo :  cultura , titulo :  Cultura DevOps , unidadesDidacticasCompletadas : 2580, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z }, { codigo :  apirest , titulo :  Diseño de APIs , unidadesDidacticasCompletadas : 2200, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z }, { codigo :  spoiler , titulo :  No way , unidadesDidacticasCompletadas : 0, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z } ] El hecho de repetir el rango de fechas para cada curso es una decisión de diseño, de nuevo. El objetivo es facilitar la vida al desarrollador que utilice la API al devolverle objetos muy simples como respuestas en lugar de obligarle a crear una composición en la que un objeto Curso contenga instancias de tipo Actividad. Una vez hayamos publicado esta versión de la API estamos firmando un contrato: no vamos a poder cambiar el nombre y el tipo de ninguno de sus atributos. Y sobre todo recuerda que una vez hayamos publicado esta versión de la API estamos firmando un contrato: no vamos a poder cambiar el nombre y el tipo de ninguno de sus atributos. Añadir nueva información puede ser aceptable pero a menos que quieras mantener varios proyectos que implementen distintas versiones del web service (ya te contaré cómo hacerlo si resulta inevitable) los nombres y tipos que hayas decidido aquí están para quedarse. Y si no me crees echa un vistazo a la cantidad de atributos repetidos (con distinto formato) en un tuit cualquiera. Por ejemplo, la propiedad geo está duplicada en place (en distintos formatos) y debería ir asociada a location. Pero los chiquitos que crearon el contrato se han portado bien y han resistido el impulso de refactorizarlo. anatomía de un tuit, por raffi krikoriansource: imgur.com Pero ¿se te ocurre otro par de formatos que podrían ser útiles en nuestro caso? Venga, para un momento y piensa un poco en ello. Luego sigue leyendo. Yeeeeees. Estamos hablando de números, estadísticas. Y el product owner nos ha dicho que quiere dibujarlos, representarlos. Así que ¿por qué no ofreces la posibilidad de pedir un dibujo? Ya sabes, image/png, image/jpg… lo que sea. No es tan difícil, de nuevo tienes una lista enorme de librerías que te ayudan. De esta manera le estás facilitando enormente el trabajo de hacer una primera integración entre su producto y tu API. Y por otro lado si hay número de por medio una forma muy potente de añadir todo tipo de funcionalidades a tu aplicación es dejando que el usuario final (el profesor, en este caso) la implemente. En forma de hoja de cálculo, por ejemplo. Hagamos que nuestro web service sea también capaz de retornar ficheros tipo text/csv y que los magos de las rejillas monten sus historias sin tener que pedirnos ayuda. excel magicsource: imgur.com Como ahora mismo tú eres mi usuario y quiero que puedas jugar rápidamente con el microservicio he añadido también el código necesario para que te responda si invocas la url desde el navegador. En el fondo se trata simplemente de aceptar también text/html como un posible formato de respuesta. Técnica y estéticamente impecable, que no te vengan con historias de que un web service solo debe retornar JSON. El mismo razonamiento puedes hacer a la hora de recibir información en la petición. En nuestro caso no ha hecho falta pero mientras más flexibilidad aportes, mejor. Aunque reconozco que muchas veces es más costosa de implementar esta parte así que si tú también terminas llegando a un compromiso no te sientas demasiado mal. La Implementación En este post no voy a dar muchos detalles sobre ella, no es el objetivo que tengo aquí. En cuanto pueda montaré una serie de entradas especiales centradas específicamente en el desarrollo y como ya escuchaste en el capítulo anterior se basará en Spring Boot: este framework me tiene el corazón robado, bribón. Aquí tienes el repositorio de código fuente y en este otro link encontrarás el ejecutable ya compilado. Elige el camino con el que estés más cómodo para probarlo pero seguramente este último te será más sencillo si no has programado antes en java: solo tienes que instalar el kit de desarollo y desde línea de comando: cd <carpeta_en_la_que_tienes_el_jar> java -jar controlactividad-0.0.1-SNAPSHOT.jar Aparecerán unos bonitos mensajes (incluyendo el aviso de que el servidor de aplicaciones está listo para recibir peticiones) y dado que son consultas y por lo tanto utilizan el método GET de HTTP puedes probarlas desde tu navegador: http://localhost:8080/cursos/actividad?desde=2016-11-01T00:00:00-00:00&hasta=2000-10-31T23:59:59-00:00 http://localhost:8080/cursos/introduccion/actividad Verás también que si cambias los parámetros ¡obtienes exactamente el mismo resultado! Eso es porque solo está implementada la capa del Controlador, es decir, la que permite interaccionar con el exterior de la aplicación y que es la que define la API. Las reglas de negocio, la base de datos y el resto de componentes están simulados y nos dedicaremos a ellas más adelante. Es más, si pruebas la segunda dirección a fecha de hoy no te funcionará porque no la he implementado todavía: no aporta mucho a lo que ya hemos explicado. Querrás comprobar también si los otros formatos de respuesta funcionan y para eso tienes que ser capaz de enviar cabeceras HTTP. Desde el navegador puedes hacerlo con extensiones como el súper conocido Postman para Chrome o el Rest-easy para Firefox. En el vídeo en el que te hablaré de HTTP te enseño a usarlos. Si (como yo) eres un romántico o una romántica en realidad terminarás usando the good old cUrl. En El Siguiente Capítulo Recuerda: tengo un plan. Y el plan incluye empezar a hablar sobre tests tan rápido como sea posible porque son la única manera de asegurar la calidad de tu código. Nos dedicaremos a ello semana que viene mientras gestionamos los posibles errores de la API y alguna operación adicional. También hablaremos de documentación automática, algo crítico a la hora de facilitar la vida a tus usuarios. Y de HATEOAS y paginación. No, eso no va a caber. Lo dejaremos para la siguiente entrega. Pero ¡seguiremos implementando nuestro microservicio! ¡Ah! Y si no tienes clara alguna de las ideas que han ido saliendo (por ejemplo qué es JSON), dímelo. Tengo un plan, pero si no te gusta aquí tengo otros ;-) jv pd: ¿Adivinas de quién es la música de la entradilla? Yes, de Marcus. No me digas que no sonríes cuando la oyes. ppd: La imagen del post ilustra perfectamente lo que quiero hacer una vez pase la próxima semana y es de Ben GAllager. pppd: Como casi siempre te dejo una tira de Dilbert. Por cierto, la de esta semana es espectacular. ppppd: Simon Fodden escribió hace tiempo una interesante artículo sobre la anatomía de un tuit utilizando para ello el gráfico que has visto antes de Raffi Krikorian."
    },

    {
        "id": 70,
        "autor": "Roberto Canales Mora",
        "pagina": "adictosaltrabajo",
        "fecha": "23/09/2015",
        "titulo": "Creando servicios RESTful con NetBeans 8",
        "link": "https://www.adictosaltrabajo.com/2015/09/23/creando-servicios-restful-con-netbeans-8/",
        "contenido": "En este tutorial vamos a ver cómo utilizar el asistente de NetBeans 8 para crear servicios RESTful fácilmente Hace tiempo que no tocaba código y como tengo que impartir unos cursos para directivos de Gobierno SOA me he puesto a mirar como crear ejemplos sencillos y rápidos de servicios. Aunque en mi contexto utilizamos más Eclipse, a mi siempre me ha gustado lo intuitivo de NetBeans. En este caso voy a enseñar como crear servicios RESTful usando los asistentes de NetBeans 8, bueno, hasta donde se puede. Equipo iMac (Retina 5K, 27 pulgadas, finales de 2014) 4 GHz Intel Core i7 16 GB 1600 MHz DDR3 AMD Radeon R9 M295X 4096 MB Antes de empezar voy a ver la versión que tengo en mi Mac de Java. Shell java -version 1 java -version Nos descargamos NetBeans, en Bundle para JEE: Arrancamos Creamos un nuevo proyecto Elegimos el tipo aplicación Web Voy a hacer un ejemplo de Pizza por lo que creo el proyecto con ese nombre Elegimos en servidor de aplicaciones que viene por defecto No elegimos ningún framework Y damos a «Play» para probar que la aplicación funciona. De momento solo tiene una página con un literal. Ahora vamos a añadir un fichero Elegimos RESTful WebService from patterns. Es lo más sencillo y luego ya tocaremos. Elegimos el nombre del recurso a gestionar y de la clase contenedora El proyecto por defecto no trae un Web.xml por lo que lo creamos a partir del mismo asistente. Le metemos el servlet mapping de jersey. Curiosamente hay un pequeño problema, que el código generado es de la versión 1 y no 2, por lo que hay que buscar las librería de la versión 1 (por internet), descargarlas y añadirlas a mano (dar al botón derecho en el proyecto para que aparezcan las propiedades) No es difícil de encontrar Lo descargamos, descomprimimos y añadimos. Ahora ya tenemos un proyecto con este aspecto. Si lo ejecutamos saldrá la pagina de antes. Para ver algo debemos meter en el navegador la URL http://localhost:8080/PizzasAutentia/ (en mi caso) Inicialmente fallará porque no hay un código mínimo y se lanza una excepción por defecto Java throw new UnsupportedOperationException(); 1 throw new UnsupportedOperationException(); Añadimos una linea solo para ver que funciona. Java public Pizza getXml() { return “lo que sea”; } 1 2 3 public Pizza getXml() { return “lo que sea”; } Yo he metido una respuesta en un pseudo xml Como uso Firefox, instalo el pluggin RESTClient. https://addons.mozilla.org/es/firefox/addon/restclient/ Ahora puedo controlar mejor que es lo que mando y llega Vemos ejemplo de respuesta 200 Voy a hacer un poco de limpia, y solo dejo la clase PizzaRecursos, que nos sobra para hacer mapping y juguetear un poco con Jersey. Java @GET @Produces( application/xml ) public String getXml() { //TODO return proper representation object return  <datos>Ejemplo Colección</datos> ; // throw new UnsupportedOperationException(); } /** * POST method for creating an instance of PizzaRecurso * @param content representation for the new resource * @return an HTTP response with content of the created resource */ @POST public Response postXml(String content) { System.out.println( por aqui ); return Response.ok().build(); // return Response.created(context.getAbsolutePath()).build(); } /** * Sub-resource locator method for {id} */ @Path( {id} ) public String getPizzaRecurso(@PathParam( id ) String id) { System.out.println( reclamamos elemento ); return  Complicando los mappings ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @GET @Produces( application/xml ) public String getXml() { //TODO return proper representation object return  <datos>Ejemplo Colección</datos> ; // throw new UnsupportedOperationException(); } /** * POST method for creating an instance of PizzaRecurso * @param content representation for the new resource * @return an HTTP response with content of the created resource */ @POST public Response postXml(String content) { System.out.println( por aqui ); return Response.ok().build(); // return Response.created(context.getAbsolutePath()).build(); } /** * Sub-resource locator method for {id} */ @Path( {id} ) public String getPizzaRecurso(@PathParam( id ) String id) { System.out.println( reclamamos elemento ); return  Complicando los mappings ; } Este es el aspecto Ahora que funciona, vamos a crear una clase y hacer el mapping directo a XML. Creamos la clase Pizza A manita (ya por no andar capturando más pantallas) creamos atributos, constructor por defecto, constructor deseado y lo anotamos como @XmlRootElement No olvidar: import javax.xml.bind.annotation.*; Java /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package PizzaAutentiaPkg; import javax.xml.bind.annotation.*; /** * * @author rcanales */ @XmlRootElement public class Pizza { private int     id; private String  nombre; private String  desc; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public Pizza() { // costructor por defecto id      = 0; nombre  =  defecto ; desc    =  defecto ; } public Pizza(int pid, String pnombre, String pdesc) { this.id      = pid; this.nombre  = pnombre; this.desc    = pdesc; } @Override public String toString() { return new StringBuffer(  id:  ). append(id). append(  nombre:  ). append(nombre). append(  desc:  ). append(desc).toString(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package PizzaAutentiaPkg; import javax.xml.bind.annotation.*; /** * * @author rcanales */ @XmlRootElement public class Pizza { private int     id; private String  nombre; private String  desc; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public Pizza() { // costructor por defecto id      = 0; nombre  =  defecto ; desc    =  defecto ; } public Pizza(int pid, String pnombre, String pdesc) { this.id      = pid; this.nombre  = pnombre; this.desc    = pdesc; } @Override public String toString() { return new StringBuffer(  id:  ). append(id). append(  nombre:  ). append(nombre). append(  desc:  ). append(desc).toString(); } } Aquí un poco más bonito Modificamos el método get para decir que produce XML y que retorna un objeto de tipo Pizza. Java @GET @Produces( application/xml ) public Pizza getXml() { //TODO return proper representation object return new Pizza(1,  Carbonara ,  Nuestra más afamada ); // throw new UnsupportedOperationException(); } 1 2 3 4 5 6 7 8 @GET @Produces( application/xml ) public Pizza getXml() { //TODO return proper representation object return new Pizza(1,  Carbonara ,  Nuestra más afamada ); // throw new UnsupportedOperationException(); } Y la magia está hecha."
    },

    {
        "id": 71,
        "autor": "Cecilio Álvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "14/06/2013",
        "titulo": "Introducción a Servicios REST",
        "link": "https://www.arquitecturajava.com/servicios-rest/",
        "contenido": "Cada día necesitamos mas usar servicios web REST . Estos servicios se diferencian de una forma importante de los servicios web SOAP con los que hemos trabajado . REST (Representational State Transfer) es un estilo de arquitectura para desarrollar servicios. Los servicios web que siguen este estilo deben cumplir con las siguientes premisas. Cliente/Servidor : Como servicios web son cliente servidor y definen un interface de comunicación entre ambos separando completamente las responsabilidades entre ambas partes. Sin estado : Son servicios web que no mantienen  estado asociado al cliente .Cada petición que se realiza a ellos es completamente independiente de la siguiente . Todas las llamadas al mismo servicio serán idénticas. Cache : El contenido de los servicios web REST ha se puede cachear de tal forma que una vez realizada la primera petición al servicio el resto puedan apoyarse en la cache si fuera necesario. Servicios Uniformes :Todos lo servicios REST compartirán una forma de invocación y métodos uniforme utilizando los metodos GET,POST,PUT ,DELETE Arquitectura en Capas: Todos los servicios REST estan orientados hacia la escalabilidad y un cliente REST no será capaz de distinguir entre si esta realizando una petición directamente al servidor , o se lo esta devolviendo un sistema de caches intermedio o por ejemplo existe un balanceador que se encarga de redirigirlo a otro servidor. Una  vez vista una introducción al concepto de servicio REST en los siguientes POST nos encargaremos de construir uno usando los standards de la plataforma JEE."
    },

    {
        "id": 72,
        "autor": "Arteco",
        "pagina": "arteco-consulting",
        "fecha": "01/02/2020",
        "titulo": "Cómo crear una aplicación con SpringBoot Initializr",
        "link": "https://www.arteco-consulting.com/tu-primera-aplicacion-con-spring-boot/",
        "contenido": "Por parte de los desarrolladores de Spring, se tiene a disposición una herramienta web online denominada Spring Initializr donde por medio de unos parámetros de configuración genera automáticamente un proyecto Maven o Gradle, según se elija, en un archivo comprimido Zip conteniendo la carpeta con la estructura de la aplicación para ser importada directamente desde el editor de programación como Eclipse IDE, Netbeans IDE o Intellij. Se puede acceder mediante el enlace a la dirección: https://start.spring.io/ El asistente web solicita una serie de datos necesarios para poder ejecutar la plantilla que construye los primeros archivos del programa. Para todos ellos aporta una configuración por defecto que conviene cambiar, como el nombre de la aplicación, o el package que se usará en las clases generadas. A continuación se explica qué parámetros hay y para qué sirven: Project: Permite elegir la herramienta de construcción de la aplicación. En Java las dos herramientas más usadas son Maven y Gradle. Recomendamos Maven al ser la más expendida. Language: Lenguaje de programación que se va a utilizar en la aplicación. Los tres tipos están soportados por la máquina virtual JVM. Java es la opción más extendida y tiene mejor soporte de los editores de programación. Spring Boot: Versión del Spring Boot a usar. Siempre que se pueda se optará por la última estable, compuesta únicamente por números. Project Metadata, Group: Se refiere al descriptor de Maven groupId, utilizado para clasificar el proyecto en los repositorios de binarios. Normalmente se suele usar una referencia similar a la de los packages de las clases. Por ejemplo, com.arteco.web para disponer todas las aplicaciones web en el mismo directorio. Project Metadata, Artifact: Se refiere al otro descriptor de Maven artifactId, y por tanto para indicar el nombre del proyecto y del binario resultante. La combinación de groupId y artifactId (más la versión) identifican inequívocamente a un binario dentro de cualquier organización. Packaging: Indica qué tipo de binario se debe construir. Si la aplicación se ejecutará por sí sola se seleccionará JAR, éste contiene todas las dependencias dentro de él y se podrá ejecutar con java -jar binario-<version>.jar. Si por el contrario, la aplicación se ejecutará en un servidor J2EE existente o en un Tomcat ya desplegado se deberá escoger WAR. Java: Se selecciona la versión de Java a usar. En este caso, se recomienda usar la versión de Java más antigua para garantizar la compatibilidad con otras librerías o proyectos que se quieran incluir, así será más probable encontrar documentación existente que siga siendo válida. Reduce el riesgo de toparse con funcionalidades no muy maduras. Dependencies: Buscador de dependencias con los starters de Spring boot disponibles. Las dependencias más habituales son: Spring Web se deberá escoger cuando se desee hacer una aplicación web o microservicios, siempre que se requiera una comunicación http y por tanto el uso de Spring MVC. Thymeleaf Incorpora el motor de plantillas para HTML dinámico, sucesor de los anteriores JSP (Java Server Page). Spring Data JPA necesario para utilizar la capa estándar de acceso a base de datos SQL denominada Java Persistence Api. Spring Security Permite incorporar controles de acceso en base a usuarios y roles sobre URLs de la aplicación. También habilita el control de ejecución de métodos de servicio en base a roles según los estándares J2EE. Lombok Aporta utilidades que facilitan la programación como la creación de @Getters y @Setters automáticamente para las clases que forman parte del conjunto de mensajes. Flyway Librería que permite aplicar scripts de cambios de base de datos de manera controlada cuando arranca la aplicación. Estos scripts se denominan migraciones y están sujetos a un control de versiones para garantizar que se aplican en el orden correcto. Mysql/Postgresql Incluye el JAR que contiene el driver JDBC necesario para configurar la capa de JPA según la base de datos a usar. Otras… El asistente permite seleccionar entre más de 50 dependencias e integraciones de herramientas open source dentro de los proyectos realizados con Spring. Una vez seleccionados los parámetros que se quieren, haciendo click en el botón «Generate-Ctrl+» se descargará un archivo zip con el nombre del Artifact que contendrá la carpeta con la estructura de la aplicación lista para importar desde el IDE. Recursos generados por SpringBoot Initializr Para realizar la importación, bastará con importar o abrir el fichero pom.xml que viene dentro del comprimido. Los editores crearán y configurarán el classpath y las librerías que se indican en él para que estén disponibles para el programador. El contenido del fichero tendrá la siguiente forma: . ├── HELP.md ├── mvnw ├── mvnw.cmd ├── pom.xml └── src ├── main │   ├── java │   │   └── org │   │       └── eadp │   │           └── spring │   │               └── SpringAppApplication.java │   └── resources │       ├── application.properties │       ├── static │       └── templates └── test └── java └── org └── eadp └── spring └── SpringAppApplicationTests.java De los ficheros incluidos, el más importante es MyWebAppApplication.java que corresponde con el punto de entrada a la ejecución del programa. Aquí es donde se aloja el método public static void main(String[] arg) que es el que inicializa toda la aplicación de Spring Boot. Durante el arranque del framework, Spring revista el resto de directorios o paquetes que cuelgan de método main en búsqueda de clases marcadas con alguna anotación que permite el registro de componentes como: @Service, @Component, @Repository y demás anotaciones de Spring y de Spring MVC como @Controller o @RestController. Fíjese que el paquete utilizado es el com.eadp.web, esta opción puede especificarse en el asistente Spring Initializr. El siguiente fichero más importante es application.properties que es donde se aloja toda la configuración de los componentes de Spring Boot, cómo que encoding usar (utf-8), si debe usar caché en las plantillas, qué nombre y clave de acceso son los de por defecto, etc… En el enlace de configuraciones y propiedades comunes de spring boot hay una referencia de todas las existentes y sus valores iniciales. El siguiente fichero es MyWebAppApplicationTests.java donde se aloja el primer test de ejemplo que genera Initializr por nosotros. Ahí, el usuario debe añadir los test que considere oportunos para aplicar en la medida de lo posible desarrollo orientado a test o TDD. Los otros directorios son static que es donde se alojan los recursos estáticos que la aplicación debe servir sin procesar. Por ejemplo en esta carpeta se incluyen los ficheros CSS, Javascript, imágenes o fuentes que se referencian desde el HTML. Si el fichero alojado en este directorio está en una sub-carpeta de static, como puede ser static/css/main.css. Spring Boot lo publicará automáticamente en la url http://localhost:8080/css/main.css. Así que no debe haber información sensible que cuelgue del directorio static porque entonces será accesible abiertamente. Y por último la carpeta templates almacena los ficheros que permiten generar HTML dinámicamente con algún motor de plantillas soportado por Spring como Thymeleaf o Freemarker. Cómo añadir funcionalidad al proyecto El proyecto creado es muy simple, si tratamos de arrancar el método main de la clase MyWebAppApplication, veremos cómo Spring inicializa toda la aplicación y se pone a la escucha del puerto 8080, pero si dirigimos el navegador a esa URL no aparecerá ningún contenido. Así que veamos cómo podemos hacer para imprimir algunos datos mediante html dinámico. Para que las siguientes líneas sirvan debemos asegurarnos de haber escogido al menos las dependencias de Spring Web y Thymeleaf, dejando el resto de opciones como se indican en las líneas superiores. Generamos el proyecto de nuevo, de no ser así y crearemos el primer controlador que permitirá añadir código Java y una plantilla Thymeleaf que generará los primeros documentos HTML dinámicos. Con el proyecto ya importado en el editor vamos a crear un primer controlador que será el encargado de ejecutar código Java dada una URL. En éste crearemos una variable que podrá ser impresa en la plantilla mediante el traspaso del dato vía el modelo. // contenido del fichero: src/main/java/org/eadp/spring/controller/MyController.java package org.eadp.spring; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import java.time.LocalDateTime; @Controller public class MyController { @GetMapping( / ) public String index(Model model) { model.addAttribute( tstamp , LocalDateTime.now()); return  index ; } } El controlador registra un método en «/», la raíz del sitio, de tal manera que cuando la aplicación esté arrancada y lista para escuchar peticiones http, normalmente por el puerto 8080, el método index será ejecutado cuando se solicite la URL de inicio http://localhost:8080/. En ese momento, el método será ejecutado añadiendo la hora actual a una variable con nombre tstamp que se guarda en model, objeto que se pasa a la vista, para que pueda construir el html dinámicamente. En este caso, mostrando la hora en la que se invocó ese método. Por otro lado, nada más ejecutarse el método del controlador, Spring pasará el control a la vista con nombre index correspondiente al fichero index.html de la carpeta de templates, tal y como indica el return «index», en el que no hace falta indicar la extensión .html. Para completar el círculo y ver los resultado necesitamos crear la vista index.html con el siguiente contenido: // contenido del fichero: src/main/resources/templates/index.html <!doctype html> <html lang= es  xmlns:th= http://www.thymeleaf.org > <head> <title>My First Spring Boot App</title> <style> html { font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif; color: #404040; background-color: #d3d3d3; } body{ padding: 5em; } </style> </head> <body> <h1>Hello from Spring Boot!</h1> <p> This page is served at <span th:text= __$_{__tstamp} ></span> </p> </body> </html> Y listos! Ahora ya podemos arrancar de nuevo la aplicación y hacer la petición a http://localhost:8080/. Dando como resultado la impresión de la hora en la que se ejecutó el controlador."
    },

    {
        "id": 73,
        "autor": "Natalia Roales González",
        "pagina": "adictosaltrabajo",
        "fecha": "21/12/2016",
        "titulo": "Aplicaciones web con Spring Boot capa a capa",
        "link": "https://www.adictosaltrabajo.com/2016/12/22/aplicaciones-web-con-spring-boot-capa-a-capa/",
        "contenido": "En este tutorial vamos a aprender a desarrollar una aplicación web con los recursos que nos brinda Spring Web. Índice de contenidos 1. Introducción 2. Entorno 3. Creando el proyecto 4. Definiendo la clase principal 5. Empaquetando el proyecto y arrancando el servidor 6. Desarrollando la capa controlador 7. Desarrollando la capa de servicio 8. Desarrollando la capa de repositorio 9. Desarrollando la capa de acceso a datos 10. Todo listo, ¡invoquemos al servicio! 11. Conclusiones 12. Referencias 1. Introducción Muchos de vosotros habréis oído hablar de Spring Boot. Para los más despitadillos, os diré que se trata de un proyecto creado a partir de Spring, el cual nos permite desarrollar y arrancar de forma muy rápida aplicaciones basadas en Spring. Hoy os voy a demostrar que realmente esto es así, y para ello vamos a desarrollar una aplicación web muy sencillita, paso a paso. La aplicación consistirá en un pequeño servicio que nos muestra un mensaje de bienvenida al ser invocado. Bueno, ¡pues comencemos a programar! 😀 2. Entorno Este tutorial ha sido realizado en un entorno con las siguientes características: Hardware: MacBook Pro Retina 15’ (2,5 GHz Intel Core i7, 16 GB DDR3) Sistema Operativo: OS X El Capitan 10.11.5 Entorno de desarrollo: IntelliJ IDEA Ultimate 2016.1 Java 1.8 3. Creando el proyecto En primer lugar, creamos un proyecto maven. Para indicar que queremos utilizar Spring Web con Spring Boot, añadimos lo siguiente al fichero pom.xml: XHTML <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.4.1.RELEASE</version> </parent> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> 1 2 3 4 5 6 7 8 9 10 11 12 <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.4.1.RELEASE</version> </parent> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> De este modo, el proyecto que acabamos de crear extiende del proyecto padre spring-boot-starter-parent, e incluye las dependencias agrupadas en el starter spring-boot-starter-web. Un starter es un conjunto de dependencias que nos ayudan a cubrir las necesidades de un tipo de proyecto concreto. Por ejemplo, el starter que estamos utilizando sirve para cubrir las necesidades de un proyecto web. Más adelante utilizaremos otros starters, entre ellos el que nos ayuda a integrar MyBatis en la aplicación. Podemos definir en qué versión de Java desarrollaremos nuestra aplicación, añadiendo lo siguiente al fichero pom.xml: XHTML <properties> <java.version>1.8</java.version> </properties> 1 2 3 <properties> <java.version>1.8</java.version> </properties> En este caso, la versión que vamos a emplear será la 1.8. Otra cosa importante es la definición de una buena estructura de paquetes. Un buen ejemplo puede ser el siguiente: paqueteria Esta estructura de paquetes agrupa las clases en cuatro paquetes principales: mapper para la capa de acceso a datos, repository para la capa de repositorio, service para la capa de servicio, y web para la capa controlador. No hay que seguir este ejemplo al pie de la letra ni mucho menos, es más, puede que la estructura de paquetes de otros proyectos sea muy distinta pero totalmente válida. Lo que pretendo mostraros es que debe existir una estructura de paquetes ordenada para que la aplicación sea mantenible y para que la responsabilidad de las clases quede bien clara. 4. Definiendo la clase principal Toda aplicación en java debe contener una clase principal con un método main. Dicho método, en caso de implementar una aplicación con Spring, deberá llamar al método run de la clase SpringApplication. A continuación, definimos de una forma muy fácil la clase principal de nuestra aplicación. Java @Configuration @EnableAutoConfiguration @ComponentScan public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 1 2 3 4 5 6 7 8 9 @Configuration @EnableAutoConfiguration @ComponentScan public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } La etiqueta @Configuration, indica que la clase en la que se encuentra contiene la configuración principal del proyecto. La anotación @EnableAutoConfiguration indica que se aplicará la configuración automática del starter que hemos utilizado. Solo debe añadirse en un sitio, y es muy frecuente situarla en la clase main. En tercer lugar, la etiqueta @ComponentScan, ayuda a localizar elementos etiquetados con otras anotaciones cuando sean necesarios. Para no llenar nuestra clase de anotaciones, podemos sustituir las etiquetas @Configuration, @EnableAutoConfiguration y @ComponentScan por @SpringBootApplication, que engloba al resto. Java @SpringBootApplication public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 1 2 3 4 5 6 7 @SpringBootApplication public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 5. Empaquetando el proyecto y arrancando el servidor Tras haber definido la clase principal del proyecto, podemos proceder a empaquetarlo y arrancar el servidor con nuestra aplicación. Si hemos añadido correctamente las dependencias al fichero pom.xml no debería haber ningún problema de empaquetado, y maven no nos devolvería ningún error en tiempo de compilación. Para salir de dudas, vamos a ejecutar el siguiente comando en el directorio raíz del proyecto: Shell $ mvn clean package 1 $ mvn clean package Si todo va bien, tras ejecutar esta instrucción, se generarán los ficheros .class a partir de las clases .java y se empaquetará el proyecto en un fichero .jar. Podemos ver también qué dependencias han sido incluidas en el proyecto, es decir, qué dependencias engloban tanto los starters añadidos como el proyecto padre. Esto es posible con el siguiente comando: Shell $ mvn dependency:tree 1 $ mvn dependency:tree Por otro lado, los proyectos de tipo Spring Boot integran un servidor de aplicaciones, por lo que arrancar una aplicación Spring Boot es muy fácil. En el directorio raíz del proyecto ejecutamos el siguiente comando: Shell $ mvn spring-boot:run 1 $ mvn spring-boot:run Si no se produce ningún error en tiempo de ejecución, el servidor estaría levantado y listo para recibir peticiones. 6. Desarrollando la capa controlador Definamos ahora el comportamiento de la aplicación implementando el resto de clases. Vamos a comenzar por la capa de más alto nivel, la de los controladores, donde expondremos los servicios de la aplicación. El servicio que vamos a crear tendrá un comportamiento muy simple. Recuperará de base de datos un mensaje de bienvenida cuyo contenido variará en función del idioma del usuario, recibiendo como parámetro el mismo nombre de usuario. El comportamiento del controlador será aún más sencillo, ya que lo único que hará será llamar a la capa de servicio y devolver lo que ésta nos retorne. Comenzaremos por el desarrollo del test que valide el controlador. Nuestro controlador se llamará SampleController, así que el test del controlador se llamará SampleControllerTest y estará en el mismo paquete que SampleController pero en el directorio test. Necesitaremos incluir una serie de dependencias englobadas en el starter spring-boot-starter-test: XHTML <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> 1 2 3 4 5 <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> El contenido de la clase de test será el siguiente: Java public class SampleControllerTest { private SampleController sampleController; private SampleService sampleService; @Before public void init(){ sampleService = mock(SampleService.class); sampleController = new SampleController(sampleService); } @Test public void sampleControllerShouldCallService() { String userName =  nroales ; String expectedMessage =  message ; when(sampleService.welcome(userName)).thenReturn(expectedMessage); String message = sampleController.welcome(userName); verify(sampleService).welcome(userName); assertTrue(message.equals(expectedMessage)); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class SampleControllerTest { private SampleController sampleController; private SampleService sampleService; @Before public void init(){ sampleService = mock(SampleService.class); sampleController = new SampleController(sampleService); } @Test public void sampleControllerShouldCallService() { String userName =  nroales ; String expectedMessage =  message ; when(sampleService.welcome(userName)).thenReturn(expectedMessage); String message = sampleController.welcome(userName); verify(sampleService).welcome(userName); assertTrue(message.equals(expectedMessage)); } } Hemos declarado un atributo de la clase SampleService, ya que lo que vamos a probar es que el controlador invoque a la capa de servicio y que devuelva lo mismo, así que debemos crear SampleService para que el test compile. Además, lo mockeamos para simular su comportamiento, pues el objetivo de este test no es probar la capa de servicio. Vamos a hacer que el test pase de rojo a verde con la siguiente implementación de SampleController: Java @Controller public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) @ResponseBody public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Controller public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) @ResponseBody public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } En el fragmento de código anterior aparecen algunas anotaciones. Vamos a ver qué significa cada una de ellas: @Controller: Con esta anotación Spring podrá detectar la clase SampleController cuando realice el escaneo de componentes. @Autowired: A través de esta anotación Spring será capaz de llevar a cabo la inyección de dependencias sobre el atributo marcado. En este caso, estamos inyectando la capa de servicio, y por eso no tenemos que instanciarla. @RequestMapping: Con esta anotación especificamos la ruta desde la que escuchará el servicio, y qué método le corresponde. @ResponseBody: Con ella definimos lo que será el cuerpo de la respuesta del servicio. @PathVariable: Sirve para indicar con qué variable de la url se relaciona el parámetro sobre el que se esté usando la anotación. Podemos también utilizar la etiqueta @RestController en lugar de @Controller, que sustituye al uso de @Controller + @ResponseBody, quedando el controlador de la siguiente forma: Java @RestController public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 7. Desarrollando la capa de servicio Aunque a partir de este punto no aparezcan las clases de test, no quiere decir que no sean necesarias para completar el desarrollo que estamos realizando. Sin embargo, he decidido omitirlas para que el tutorial no se extienda demasiado, pero siempre es recomendable respaldar nuestra aplicación con una batería de pruebas (y más aún hacer TDD). Vamos implementar la capa de servicio. Un método de servicio definirá una operación a nivel de negocio, por ejemplo, dar un mensaje de bienvenida. Los métodos de servicio estarán formados por otras operaciones más pequeñas, las cuales estarán definidas en la capa de repositorio. El mapper, por último, contendrá las operaciones de acceso a datos que serán invocadas por el repositorio. En este caso, el servicio realizará una sola llamada al repositorio, pasándole como parámetro el nombre de usuario. Lo llamaremos SampleService. Java @Service public class SampleService { @Autowired private SampleRepository sampleRepository; public SampleService(SampleRepository sampleRepository) { this.sampleRepository = sampleRepository; } public String welcome(String userName) { return sampleRepository.getMessageByUser(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service public class SampleService { @Autowired private SampleRepository sampleRepository; public SampleService(SampleRepository sampleRepository) { this.sampleRepository = sampleRepository; } public String welcome(String userName) { return sampleRepository.getMessageByUser(userName); } } La anotación @Service funciona de forma parecida a la anotación @Controller, ya que permite que Spring reconozca a SampleService como servicio al escanear los componentes de la aplicación. 8. Desarrollando la capa de repositorio Ahora tenemos que desarrollar el repositorio al que ha invocado el servidor. Por tanto, crearemos la clase SampleRepository e implementaremos el método getMessageByUser. Java @Repository public class SampleRepository { @Autowired private SampleMapper sampleMapper; public SampleRepository(SampleMapper sampleMapper) { this.sampleMapper = sampleMapper; } public String getMessageByUser(String userName) { String language = sampleMapper.getLanguageByUser(userName); return sampleMapper.getMessageByLanguage(language); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Repository public class SampleRepository { @Autowired private SampleMapper sampleMapper; public SampleRepository(SampleMapper sampleMapper) { this.sampleMapper = sampleMapper; } public String getMessageByUser(String userName) { String language = sampleMapper.getLanguageByUser(userName); return sampleMapper.getMessageByLanguage(language); } } Para recuperar el mensaje de bienvenida dado el nombre de usuario tendremos dos métodos en la capa de acceso a datos, siendo uno para recuperar el idioma dado el usuario, y otro para recuperar el mensaje dado el idioma. Desde el repositorio llamamos a los dos. 9. Desarrollando la capa de acceso a datos Ya solo nos queda implementar la capa de acceso a datos. En esta capa es en donde se definen las consultas a base de datos, a través de interfaces denominadas mappers. Vamos a crear el mapper con los dos métodos invocados en el repositorio, que son getLanguageByUser y getMessageByLanguage. Java @Mapper public interface SampleMapper { String getLanguageByUser(@Param( userName ) String userName); String getMessageByLanguage(@Param( language ) String language); } 1 2 3 4 5 6 7 @Mapper public interface SampleMapper { String getLanguageByUser(@Param( userName ) String userName); String getMessageByLanguage(@Param( language ) String language); } Utilizamos la etiqueta @Mapper para indicar que una interfaz es un mapper, y así Spring pueda localizarla. También utilizamos la etiqueta @Param para que MyBatis identifique los campos a la hora de procesar las consultas. Para poder trabajar con MyBatis debemos incluir algunas dependencias, agrupadas dentro del starter mybatis-spring-boot-starter: XHTML <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.1.1</version> </dependency> 1 2 3 4 5 <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.1.1</version> </dependency> También debemos añadir el conector correspondiente a la base de datos que vayamos a utilizar. Podemos hacerlo incluyendo su dependencia maven en el pom.xml. En caso de utilizar una base de datos MySQL añadimos la siguiente dependencia: XHTML <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.6</version> </dependency> 1 2 3 4 5 <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.6</version> </dependency> Y en el fichero application.properties, localizado en el directorio resources, añadiremos la información de nuestra base de datos, siendo testdb el nombre de la base: Shell spring.datasource.url=jdbc:mysql://localhost:3306/testdb spring.datasource.username=user spring.datasource.password=pass spring.datasource.driver-class-name=com.mysql.jdbc.Driver 1 2 3 4 spring.datasource.url=jdbc:mysql://localhost:3306/testdb spring.datasource.username=user spring.datasource.password=pass spring.datasource.driver-class-name=com.mysql.jdbc.Driver Una vez tenemos todo lo necesario para trabajar con MyBatis, definimos cada uno de los dos métodos del mapper. Dentro de la carpeta resources, creamos una estructura de directorios idéntica a la estructura de paquetes donde se encuentra SampleMapper.java, y creamos el fichero SampleMapper.xml. Tendrá el siguiente contenido: XHTML <mapper namespace= com.autentia.demo.mapper.SampleMapper > <select id= getLanguageByUser  resultType= String > SELECT USL_LANGUAGE FROM USER_LANGUAGE WHERE USL_USER = #{userName} </select> <select id= getMessageByLanguage  resultType= String > SELECT MSG_DESCRIPTION FROM MESSAGES WHERE MSG_MESSAGE =  welcome  AND MSG_LANGUAGE = #{language} </select> </mapper> 1 2 3 4 5 6 7 8 9 10 11 <mapper namespace= com.autentia.demo.mapper.SampleMapper > <select id= getLanguageByUser  resultType= String > SELECT USL_LANGUAGE FROM USER_LANGUAGE WHERE USL_USER = #{userName} </select> <select id= getMessageByLanguage  resultType= String > SELECT MSG_DESCRIPTION FROM MESSAGES WHERE MSG_MESSAGE =  welcome  AND MSG_LANGUAGE = #{language} </select> </mapper> La primera query recupera de la tabla USER_LANGUAGE el campo USL_LANGUAGE dado el valor del campo USL_USER, obteniéndose el idioma asociado al usuario userName. La segunda query, recupera el campo MSG_DESCRIPTION de la tabla MESSAGES dado el valor del campo MSG_LANGUAGE para MSG_MESSAGE igual a “welcome”, obteniéndose el mensaje de bienvenida en el idioma del usuario. Aunque parezca obvio, vuestras consultas deberán concordar con el diseño de la base de datos. Lo que aparece dentro de #{userName} y #{language} son los identificadores que hemos designado a los parámetros de entrada con las anotaciones @Param. 10. Todo listo, ¡invoquemos al servicio! Es el momento de la verdad… ¡Vamos a invocar a nuestro servicio! Ya sabéis, para ello levantamos el servidor con el siguiente comando: Shell $ mvn spring-boot:run 1 $ mvn spring-boot:run Una vez haya arrancado el servidor procedemos a invocar al servicio, y para ello accedemos a la url http://localhost:8080/welcome/userName. Tenemos que sustituir userName por el nombre de usuario que hayamos guardado en nuestra base de datos. Como respuesta, veremos en el navegador el mensaje de bienvenida que hayamos definido. 11. Conclusiones Gracias a Spring Boot nos acabamos de marcar en un momento una aplicación totalmente funcional. Hemos comenzado creando un proyecto maven e indicando en el pom.xml que el proyecto es de tipo Spring Boot, heredando de spring-boot-starter-parent el proyecto creado. Después hemos elegido el starter que más se ajusta a las necesidades de nuestro tipo de proyecto, en este caso spring-boot-starter-web, y lo hemos añadido como dependencia. Luego hemos creado la clase principal de la aplicación, implementando posteriormente las clases e interfaces que definen su comportamiento, y por último hemos arrancado el servidor. El tiempo que hemos perdido en la configuración del proyecto es mínimo, y solo nos hemos tenido que preocupar de implementar los métodos que definan el comportamiento de los servicios. Tampoco hemos perdido tiempo en montar el servidor de aplicaciones, ya que Spring Boot cuenta con un Tomcat embebido. Ya no tenéis excusa para no desarrollar proyectos web en Java. ¿Habéis visto qué fácil y rápido es tener una aplicación Java web funcional desde cero? Os animo a que lo probéis"
    },

    {
        "id": 74,
        "autor": "Rosa",
        "pagina": "rosamarfil",
        "fecha": "16/08/2019",
        "titulo": "Crear una aplicación web con Spring Boot",
        "link": "https://rosamarfil.es/tutoriales/programacion/spring-boot-api-rest-2-crear-una-aplicacion-web-con-spring-boot/",
        "contenido": "En este tutorial aprenderás a instalar Spring Boot y crear una aplicación web con Spring Boot desde cero. El proyecto estará basado en servicios web REST (o comúnmente microservicios). ¿Qué es Spring Boot? Es un framework o herramienta que ayuda a construir aplicaciones basadas principalmente en microservicios de una forma más ágil. Instalar Spring Boot Existen dos maneras: Instalado Spring Boot Starter (que es un Eclipse con Spring Boot integrado). Se puede descargar desde su página oficial: https://spring.io/tools. Accediendo a la página https://start.spring.io y generando el proyecto para descargarlo en tu PC. Instalando Spring Tools Suite en Eclipse (Se instala desde Eclipse, como un plugin). Yo, en este caso optaré por la tercera opción e instalaré Spring Tools Suite en Eclipse, con java JDK 8. Para ello: Abre Eclipse, dirígete a Help -> Eclipse Marketplace… Introduce «sts» en el cuadro de texto para realizar la búsqueda y presiona Enter. Visualiza la opción Spring Tools 4 – for Spring Boot (aka Spring Tool Suite 4). Pulsa sobre el botón Install. install-spring-boot Instalar Spring Boot en Eclipse La instalación tardará unos minutos y Eclipse te pedirá que lo reinicies. Un vez reiniciado Eclipse observa que aparece un nuevo botón  (Boot Dashboard) en la barra de menú superior. Crear proyecto Dirígete a File -> New -> Project y elige Spring Boot -> Spring Boot Starter. Presiona Next. A continuación, completa los datos para el proyecto y presiona Next: new-spring-boot-project Crear un proyecto Spring Boot A continuación, activa las casillas Spring Web Services y Spring Web Starter. Pulsa Finish: spring-boot-dependencies-Crear aplicación web con Spring Boot Según las casillas que activemos, se crearán sus dependencias en el fichero pom.xml. Observa que no hay ningún error a la hora de la creación del proyecto. Prueba una ejecución de la aplicación (ejecutando el proyecto como Spring Boot App) y observando una salida por consola como la siguiente: Crear aplicación web con Spring Boot Picar los servicios En mi caso he creado un servicio que devuelve una lista de usuarios. UserServiceRest.java En esta clase lo importante son las anotaciones que hemos añadido y de forma sencilla para que entendáis que significa cada una os explico: @RestController -> Indica que será una clase que va a publicar servicios REST. @RequestMapping(value= /users , method=RequestMethod.GET) -> se indica el nombre del método accesible desde el navegador. En este caso users. Y también se indica el tipo de método, en este caso de tipo GET. Código de la clase UserServiceRest.java: package es.springboot.rosamarfil.services; import java.util.ArrayList; import java.util.List; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import es.springboot.rosamarfil.model.User; @RestController public class UserServiceRest { /** * Lista de ejemplo de usuarios */ private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; @RequestMapping(value= /users , method=RequestMethod.GET) public List<User>  getUsers(){ return listaUsuarios; } } User.java package es.springboot.rosamarfil.model; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } Probar servicio REST Después de picar el escueto código, arranca tu aplicación Spring Boot y muestra el resultado en el navegador introduciendo en la barra de direcciones: http://localhost:8080/users El resultado será: Crear aplicación web con Spring Boot Como ves, con este pequeño tutorial has aprendido a crear una aplicación web con Spring Boot y publicar en local un servicio REST. Evidentemente, un proyecto real tendría muchas más capas y sería más complejo, pero el concepto de Web Services REST con Spring Boot es el que te he explicado. Espero que te haya sido de utilidad. Gracias por leerme y comparte si te ha gustado. Nos vemos en el próximo tutorial."
    },

    {
        "id": 75,
        "autor": "Iván Salas",
        "pagina": "programandoointentandolo",
        "fecha": "25/10/2018",
        "titulo": "TUTORIAL SPRING BOOT – CREANDO NUESTRA PRIMERA APLICACIÓN",
        "link": "https://programandoointentandolo.com/2018/10/tutorial-spring-boot-creando-nuestra-primera-aplicacion.html",
        "contenido": "HomeJavaSpringSpring BootTutorial Spring Boot – Creando nuestra primera aplicación TUTORIAL SPRING BOOT – CREANDO NUESTRA PRIMERA APLICACIÓNSpring Boot  25 octubre, 2018  0  Iván Salas reset css En este tutorial vamos a ver lo rápido y sencillo que es crear un proyecto utilizando Spring Boot, ya que no nos vamos a tener que preocupar de gestionar las dependencias que necesitaremos (al menos las más comunes), ni hacer las típicas configuraciones iniciales que hacemos al empezar un proyecto de Spring y ni tan siquiera nos vamos a tener que preocupar de configurar un servidor para correr nuestra aplicación. Vamos que nos permite centrarnos en el desarrollo gracias a todas las cosas que Spring Boot hace por nosotros y que nos van a permitir crear y desplegar nuestras aplicaciones de una forma muy sencilla. El proyecto que vamos a crear en este tutorial lo voy a usar de base para ir entrando más en profundidad en posteriores post tanto en Spring Boot como en otros temas relacionados de forma que la idea es tener al final una aplicación sencilla pero que nos permita tener una visión completa de Spring, por eso en este post nos vamos a centrar en cómo crear nuestra primera aplicación con Spring Boot, analizar su estructura, explicar los puntos básicos y arrancarla, ni más ni menos. 1. CREAR UN PROYECTO CON SPRING BOOT Vamos a ver cómo crear un proyecto con Spring Boot desde 0 usando el String Tool Suite que es un entorno de desarrollo basado en eclipse con todo lo que necesitamos para hacer desarrollos con Spring o bien podemos usar un eclipse «normal» y instalarle el Spring Tools desde el Eclipse Marketplace, podríamos usar el IDE que más nos guste pero alguno había que elegir para hacer el tutorial… Para crear un proyecto nuevo proyecto de Spring nos vamos a File/New/Spring Starter Proyect, si no aparece elegimos Proyect… y lo buscamos dentro de Spring Boot y siguiente. Crear nuevo proyecto con Spring Boot En esta primera pantalla podemos decidir si queremos usar maven o gradle, la versión de java que queremos usar, la forma en la que queremos que se empaquete el proyecto, el lenguaje de programación que vamos a usar y los típicos datos del proyecto, nombre, package, … Ponemos los datos del proyecto y nos quedamos con maven, con la última versión de la jdk, nos vamos a quedar también con el jar porque no necesitamos otra cosa y como lenguaje pues elegimos Java aunque quizás algún día me anime a hacerlo también con Kotlin. Pulsamos en Next > para que nos aparezca la pantalla para seleccionar las dependencias que sabemos que va a utilizar nuestro proyecto. Seleccionar dependencias nuevo proyecto Spring Boot Las buscamos y las seleccionamos y cuando tengamos todas las que necesitamos le damos a Finish, si se nos olvida alguna no pasa nada, siempre podremos incluirlas a mano en el pom.xml pero desde aquí es más simple porque con unos clics ya tenemos configuradas todas las dependencias sin necesidad de estar copiándolas de otros proyectos que tengamos o peor de estar buscándolas una a una. Y así de fácil tenemos nuestro proyecto listo para empezar. 2. ESTRUCTURA DEL PROYECTO La estructura del proyecto va a depender de las elecciones que hiciésemos a la hora de crear el proyecto, por ejemplo, si hubiésemos elegido empaquetarlo como .war tendríamos la carpeta webapp y si además quitásemos Thymeleaf y lo seguimos dejando como un proyecto web tendríamos una clase adicional (ServletInitializer), pero básicamente podemos decir que la estructura del proyecto será la típica de un proyecto de Spring. Estructura de proyecto Spring Boot Dentro de nuestro package principal tenemos una clase con el nombre del proyecto + Application que es la que nos proporciona Spring Boot para arrancar nuestra aplicación. package com.programandoointentandolo.tsb; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class TutorialSpringBootApplication { public static void main(String[] args) { SpringApplication.run(TutorialSpringBootApplication.class, args); } } Como vemos esta clase es muy sencilla ya que solo contiene el método main dentro del que se llama a SpringApplication.run() y una anotación @SpringBootApplication que es equivalente a usar las anotaciones @Configuration, @EnableAutoConfiguration y @ComponentScan con sus configuraciones por defecto. @Configuration: Esta anotación se utiliza para indicar que la clase puede contener beans que serán registrados al iniciar la aplicación. @EnableAutoConfiguration: Con esta anotación se le indica a Spring que se encargue de configurar todas las dependencias que tengamos en el proyecto. @ComponentScan: Permite que se escaneen todos los @Component que se encuentre dentro del paquete en el que se define, se puede configurar para que busque en los paquetes que queramos. El siguiente archivo que vemos en el proyecto es el application.properties que es el archivo que utilizaremos para configurar nuestra aplicación, por lo tanto aquí es donde vamos a configurar nuestra conexión de base de datos y el resto de configuraciones que necesitemos, porque aunque Spring Boot nos evita tener que indicar todas las típicas configuraciones en las que solo nos limitaríamos a dejar los valores por defecto siempre existe la posibilidad de que necesitemos cambiarlas, o simplemente como en el caso de las referentes a la base de datos que no tengamos más remedio que indicarlas manualmente. En este enlace de la documentación pues revisar las propiedades más comunes. Para nuestro ejemplo vamos a usar una base de datos MySql y como durante el tutorial es muy probable que nuestras clases cambien y nos obliguen a cambiar nuestro modelo de BD vamos a dejar que Spring Boot nos cree las tablas a partir de nuestras clases cuando arranquemos la aplicación y que las borre cuando la paremos para poder centrarnos en lo que estamos haciendo y no tener que preocuparnos por dejar datos inconsistentes. Por lo que nuestro application.properties será el siguiente ya que la BD se va a llamar pruebas, va a estar en localhost:8889 y tanto el usuario como la password van a ser root. aplicacion.nombre=Tutorial Spring Boot server.port=9876 spring.datasource.url=jdbc:mysql://localhost:8889/pruebas?useSSL=false spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect spring.jpa.hibernate.ddl-auto=create-drop logging.level.org.hibernate.SQL=debug Esas 3 propiedades son las que es posible que tengas que cambiar para poder usar tu BD, en cuanto al resto he puesto una propiedad inventada aplicacion.nombre para que se vea que también es posible indicar nuestras propias variables de configuración, con server.port podemos indicar el puerto en el que se arrancará la aplicación por si no nos gusta el puerto por defecto, luego tenemos las propiedades referentes a la conexión de BD y la que hace nuestra base de datos se limpie con cada ejecución spring.jpa.hibernate.ddl-auto=create-drop. Los archivos .properties son sencillos sobre todo cuando son pequeños pero si crecen un poco y se van metiendo las propiedades desordenadas pueden ser dificiles de leer, por eso vamos a sustituir el application.properties que Spring Boot nos ha creado por un application.yml porque Spring Boot soporta también el formato YAML perfectamente y el resultado es más legible. A continuación tenemos el .yml correspondiente al application.properties anterior. aplicacion: nombre: Tutorial Spring Boot server: port: 9876 spring: datasource: url: jdbc:mysql://localhost:8889/pruebas?useSSL=false username: root password: root driver-class-name: com.mysql.jdbc.Driver jpa: database-platform: org.hibernate.dialect.MySQL57Dialect hibernate: ddl-auto: create-drop logging: level: org: hibernate: SQL: debug Comparando uno y otro vemos que las propiedades son las mismas y lo que cambia es su representación, mientras que en el .yml se sigue una estructura de árbol en el .properties cada propiedad contiene toda su ruta completa, y si nos fijamos vemos que el .yml lo que hace es que sustituye el «.» de separación del .properties por «:» y comienza una nueva rama y así sucesivamente hasta que llega al nombre de la propiedad donde ya si que indica su valor. A Spring Boot le da igual que usemos uno u otro formato y no vamos a tener que hacer ningún tipo de configuración adicional para que use el application.yml, en cualquier caso lo que hará cuando vaya a arrancar la aplicación será leer nuestro application.yml o application.properties para inyectar los valores de las propiedades que definamos en las clases de configuración correspondientes para que se arranque correctamente configurada. El último archivo que nos queda por ver es el test que nos crea que como es natural esta vacío… pero ya vemos que tiene 2 anotaciones, @RunWith(SpringRunner.class) para que el tets use el runner de Spring y @SpringBootTest que lo que hace es buscar la clase anotada con @SpringBootApplication y usarla para cargar el contexto completo de la aplicación para hacer el test por lo que por lo general no vamos a usarla ya que normalmente no vamos a necesitar cargar toda la aplicación a no ser que queramos hacer una prueba completa de todas las capas de muestra aplicación. package com.programandoointentandolo.tsb; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class TutorialSpringBootApplicationTests { @Test public void contextLoads() { } } Pero como no todo puede ser perfecto si estamos usando en nuestro proyecto una jdk posterior a la 8 como en nuestro caso que estamos usando la 10 e intentamos ejecutar el test nos va a saltar una excepción, para solucionarlo solo tenemos que añadir una demencia al pom.xml, porque esta librería ya no está incluida dentro de la jdk, bueno en realidad si lo sigue estando hasta la próxima versión pero para que nos funcione tendríamos que añadir el comando –add-modules java.xml.bind pero no es una solución muy limpia y menos sabiendo que con la siguiente versión ya no nos va a funcionar. <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency> 3. ARRANCANDO NUESTRO EJEMPLO CON SPRING BOOT Una vez que ya tenemos el proyecto creado y hemos echado un vistazo a lo que nos vamos a encontrar los proyectos de Spring Boot ya estamos listos para crear un proyecto sencillo y probar nuestra primera aplicación usando Spring Boot. Para no alargar esto innecesariamente no voy a incluir aquí el código de los controllers, services, … ya que no es el propósito de este post y ya lo iremos viendo y desarrollando más en profundidad de forma separada para que sea más fácil de seguir. Bueno, pues vamos a ver como probar nuestra aplicación, para arrancarla desde nuestro IDE podemos hacer click derecho sobre nuestro proyecto y después elegimos Run As y Spring Boot App. Arrancar aplicacion Spring Boot También podemos hacerlo desde el Boot Dashboard, que es una vista muy similar a Servers pero en este caso para las aplicaciones de Spring Boot Vista Boot Dashboard Abrimos la url en nuestro navegador y voila, ya tenemos nuestra aplicación funcionando. Aplicacion Spring Boot + Thymeleaf + Bootstrap Desplegar nuestra aplicación desde el STS es fácil, pero ¿y desplegarla sin él? pues la verdad es que es increíblemente fácil, solo tenemos que coger el jar que se habrá generado en la carpeta target del proyecto y ejecutarlo con java -jar tutorial-spring-boot-0.0.1-SNAPSHOT.jar y aplicación desplegada. Arrancando aplicacion Spring Boot desde la consola El código completo del de este ejemplo esta en mi repositorio de github tutorial-spring-boot pero como el proyecto va a ir evolucionando a medida que vayamos viendo más cosas puede que el código no sea exactamente el mismo, pero para eso con cada nuevo post creare una release para que se pueda consultar como se encontraba el proyecto en ese momento y sea sencillo encontrar el estado correspondiente o para descargar directamente el código correspondiente al post, el enlace correspondiente a esta release esta aquí."
    },

    {
        "id": 76,
        "autor": "Acodigo",
        "pagina": "acodigo",
        "fecha": "01/04/2017",
        "titulo": "Spring Boot : Crear una Aplicación Web",
        "link": "http://acodigo.blogspot.com/2017/04/spring-boot-crear-una-aplicacion-web.html",
        "contenido": "Spring Boot es un sub-proyecto Spring que simplifica y agiliza el proceso de creación y desarrollo de aplicaciones web o de escritorio que utilicen el Framework Spring, la configuración requerida para iniciar una aplicación, de cualquier tipo, es mínima y automática, Spring Boot se auto-configura analizando el classpath, además se elimina por completo la necesidad de tener archivos de configuración XML, a pesar de ello el mecanismo de configuración se mantiene bastante flexible, permitiéndonos personalizar la configuración siempre que lo necesitemos. Nos es necesario tener alguna herramienta especial para crear nuestras aplicaciones, es posible utilizar la mayoría de los IDEs como: NetBeans, Eclipse, IntelliJ, etc., tampoco es un requisito, pero si una buena opción utilizar una herramienta que nos facilite la administración de las dependencias, en este serie de cursos usaremos Maven, debe ser la versión 3.2 o superior, obviamente también requerimos el JDK la versión 1.6 en adelante. La manera mas sencilla de crear el proyecto inicial es dirigirse a la web: https://start.spring.io aquí seleccionarás el tipo de proyecto y le versión a utilizar, en la sección Project Metadata introduces la información correspondiente a tu proyecto, en la sección Dependencies deberás seleccionar las dependencias requeridas por tu proyecto, por ejemplo, para crear una aplicación web agregamos Web, para acceso a datos JPA, puedes agregar todos los que sean necesarios, para finalizar presiona Generate Project para descargar el proyecto en un archivo comprimido ZIP. spring boot starter Presionando en el enlace que se encuentra en la parte inferior, que dice: “Switch to the full version”, expandirás la ventana y se mostrará más detalladamente las opciones de configuración. Para abrir el proyecto con NetBeans 8 nos vamos al menú File | Open Project... y localizamos la carpeta descomprimida del proyecto que acabamos de generar. Lo primero que debemos ver es el archivo pom.xml, lo abrimos, clic derecho sobre el proyecto y seleccionamos Open POM, veremos: <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.5.1.RELEASE</version> <relativePath/> <!-- lookup parent from repository --> </parent> Con esto heredamos las funcionalidades que nos permitirán administrar las dependencias de nuestro proyecto de una manera fácil. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-jdbc</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-thymeleaf</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> Para iniciar un proyecto de manera rápida contamos con los spring-boot-starter-*, estos nos permiten administrar un grupo de dependencias para un proyecto en especifico, por ejemplo: spring-boot-started-web contiene todas las dependencias necesarias para crear una aplicación web MVC, spring-boot-starter-jdbc añade las dependencias requeridas para realizar el acceso a datos con la API JDBC, spring-boot-starter-thymeleaf nos proporciona las dependencias que requiere el motor de plantillas Thymeleaf el cual usaremos para generar nuestras vistas, existen muchos más, para todo tipo de proyectos. <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> Este plugin maven será el encargado de empaquetar la aplicación en el correspondiente archivo jar, este contiene todo los necesario para ejecutarse con el comando java -jar. spring boot tutorial Esta es la estructura de nuestro proyecto inicial, si vemos la clase IntroduccionApplication encontraremos el método main(String[] args) este es el punto de inicio de nuestra aplicación, el método SpringApplication.run() es el encargado de iniciar la aplicación, como argumento le indicamos la clase de configuración y los argumentos de comandos, la clase de configuración es la propia clase IntroduccionApplication la misma usa la anotación @SpringBootApplication la cual es equivalente a utilizar las anotaciones: @Configuration, @EnableAutoConfiguration y @ComponentScan, estas anotaciones hacen lo siguiente: @Configuration: Indica que esta es una clase usada para configurar el contenedor Spring. @ComponentScan: Escanea los paquetes de nuestro proyecto en busca de los componentes que hayamos creado, ellos son,  las clases que utilizan las siguientes anotaciones: @Component, @Service, @Controller, @Repository. @EnableAutoConfiguration: Habilita la configuración automática, esta herramienta analiza el classpath y el archivo application.properties para configurar nuestra aplicación en base a las librerías y valores de configuración encontrados, por ejemplo: al encontrar el motor de bases de datos H2 la aplicación se configura para utilizar este motor de datos, al encontrar Thymeleaf se crearan los beans necesarios para utilizar este motor de plantillas para generar las vistas de nuestra aplicación web. Si lo deseamos podemos personalizar la aplicación, para ello creamos una instancia de la clase SpringApplication y cambiamos el comportamiento deseado, por ejemplo, para deshabilitar el banner usamos Banner.Mode.OFF. import org.springframework.boot.Banner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class IntroduccionApplication { public static void main(String[] args) { SpringApplication app = new SpringApplication(IntroduccionApplication.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); } } En el constructor usamos indicamos la clase de configuración, con el método app.run(args) iniciamos ala ejecución de la aplicación. Si deseas crea una aplicación de escritorio no web debes desactivar los componente web, lo hacen del siguiente modo: app.setWebEnvironment(false); Nuestro primer controlador Crearemos nuestro primer controlador que llamaremos HomeController y lo ubicaremos en el paquete carmelo.spring.web es importante que los controladores se ubiquen en un paquete dentro del paquete que contiene la clase principal para que puedan ser detectados correctamente. package carmelo.springboot.web; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HelloController { @RequestMapping( /hello ) public String showHello(Model model){ model.addAttribute( saludo ,  Mi primera aplicacion web Spring Boot ); return  hello ; } } Este controlador responde a la petición HTTP localhost:8080/hello, añade un atributo al modelo y retorna el nombre lógico de la vista, hello, para más detalles puedes ver: Spring MVC Controladores. Las vistas será generadas con motor de plantillas Thymeleaf, según nuestro controlador requerimos el archivo src/main/resources/templates/hello.html. <!DOCTYPE html> <html xmlns:th= http://www.thymeleaf.org > <head> <meta charset= UTF-8 /> <title>Spring Boot</title> </head> <body> <p th:text= ${saludo}  /> </body> </html> También vamos a añadir el archivo src/main/resources/static/index.html esta es la página que se muestra al agregar a localhost:8080/ de modo que en esta página solo añadiremos un enlace que nos lleve a localhost:8080/hello para ver nuestro controlador funcionando. <!DOCTYPE html> <html> <head> <title>Spring Boot</title> <meta charset= UTF-8 > </head> <body> <a href= /hello >Go Home</a> </body> </html> spring boot web Con esto tenemos nuestra primera aplicación web Spring Boot lista. Si deseamos cambiar la ubicación y la extensión de las plantillas editamos el archivo de propiedades application.properties para agregar las siguientes configuraciones: spring.thymeleaf.prefix=classpath:/views/ spring.thymeleaf.suffix=.html La primera indica las carpetas donde se encuentran las plantillas y la segunda la extensión de las mismas, con este ejemplo nuestra vista será src/main/resources/views/hello.html. Ejecutar una aplicación Spring Boot Spring Boot trabaja con servidor integrado, por defecto Apache Tomcat, para ejecutar nuestra aplicación, en NetBeans IDE solo presionamos Run, si todo está correcto podemos ir al navegar y deberemos ver nuestra aplicación. spring boot run Una aplicación web Spring Boot puede ejecutarse desde la consola de comandos sin problemas, de la siguiente manera: java -jar target/introduccion-0.0.1-SNAPSHOT.jar image Nuestra aplicación en el navegador: image También es posible ejecutar una aplicación usando el Spring Boot Maven Plugin con el siguiente comando: mvn spring-boot:run Debemos tener presente que si una instancia de la aplicación está ejecutándose e intentamos iniciar otra instancia se producirá un error ya que el puerto estará en uso, es posible cambiar el puerto mediante el archivo application.properties añadiendo server.port=8178 donde 8178 es el nuevo puerto. En este tutorial hemos visto la simplicidad que nos aporta Spring Boot a la hora de crear aplicaciones web MVC, no requerimos configuración XML, el DispatcherServlet, ViewResolver, y todo los requerido para crear una aplicación web fue configurado de manera automática, no fue necesario desplegar la aplicación en un servidor externo, estos son algunos de los beneficios obtenidos al utilizar esta herramienta, en próximos tutoriales veremos mas características interesantes."
    },

    {
        "id": 77,
        "autor": "Javadesde0",
        "pagina": "javadesde0",
        "fecha": "23/06/2019",
        "titulo": "Creando un proyecto de Spring Boot",
        "link": "https://javadesde0.com/creando-un-proyecto-de-spring-boot/",
        "contenido": "Para crear un proyecto de Spring, tenemos varias opciones. Las 2 más populares son: Crear un proyecto desde Spring Boot Initializer la herramienta web que nos proporciona Pivotal. Crear el proyecto desde el IDE mediante al Command Line Tool (CLI), en nuestro caso el IDE elegido será Spring Tool Suite 4. En mi opinión, la más sencilla es desde el propio Spring Tool Suite 4, ya que nos carga el proyecto automáticamente en el explorador de proyectos del IDE. Y así, ya podemos trabajar directamente con él. Creando un proyecto de Spring mediante a Spring Boot Initializer Para crear un proyecto desde la web, visitaremos la web https://start.spring.io/ La configuración que utilizaremos será mediante a Maven, utilizando Java, y Spring Boot 2.1.6 (quizás esta versión cambie estés realizando este tutorial). Si desplegamos el Options, podemos ver que podemos seleccionar la versión de Java. Nosotros utilizaremos la 8. Si bajamos un poco más, podemos ver el apartado de dependencias. En nuestro caso, vamos a añadir spring Web Started. La podemos buscar desde el buscador, o bien ir al icono de alado, donde nos aparecerá un listado con dependencias y seleccionarla. Y finalmente, pulsamos en generar proyecto. Finalmente, se nos descargará el proyecto en archivo .zip, El cual vamos a descomprimir en el mismo directorio de descargas donde se nos ha descargado el proyecto Cargando un proyecto de Spring Boot Ahora, vamos a cargar un proyecto de maven, esto nos vale para cualquier proyecto, no solamente para los que creamos desde https://start.spring.io/ . Para realizar la carga, vamos a Project Explorer > Botón derecho > Import… Seleccionamos la opción de proyecto de Maven existente: Seleccionamos el directorio donde se encuentra (si habéis seguido las indicaciones estará en descargas). Y una vez seleccionado, podemos ver como se realiza la importación y la descarga de dependencias. Finalmente, y una vez concluida la descarga de dependencias, ya tenemos nuestro proyecto cargado en Spring Tool Suite con nuestro fichero pom.xml Creando un proyecto Maven mediante a Spring Tool Suite 4 Anteriormente si habéis seguido el tutorial paso a paso hasta aquí, hemos creado un proyecto, por lo que no podemos repetir el mismo nombre. Ya que nos generaría un error. Llegados a este punto, tenemos dos opciones, eliminar el proyecto o ponerle otro nombre diferente. En mi caso, voy a borrar el proyecto. Eliminando un proyecto de Spring Boot Si no marcamos el delete project contents on disk, realmente estamos únicamente eliminando el proyecto del explorador de proyectos del IDE. Pero aún existiría el directorio. Bien, tras ver como realizamos un proyecto desde la web de https://start.spring.io/ vamos a ver como realizarlo con Spring Tool Suite. Esta manera, para mí es la más rápida y sencilla, aunque mejor que decirlo por aquí es que lo comprobareis vosotros mismos. Abrimos nuestro IDE y vamos a File > New > Project Seleccionamos Spring Starter Project Y añadimos la información del proyecto: Y finalmente, añadimos las dependencias y pulsamos sobre finalizar. Una vez finalizada la creación, como en la creación anterior, realizará la importación y descargará dependencias. Y ya tenemos el proyecto listo para trabajar sobre el: Pom resultante de ambos proyectos Si observamos el pom que se nos a creado en el proyecto, destaca principalmente el ver la versión de Java con al que estamos trabajando, en nuestro caso la 1.8. También podemos apreciar que pese a que hemos marcado una sola dependencia, tenemos dos. Esto es debido a que automáticamente, al incluir la dependencia spring-boot-starter-web , también se nos incluye la dependencia de testing (spring-boot-starter-test)."
    },

    {
        "id": 78,
        "autor": "Cecilio Álvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "11/05/2020",
        "titulo": "Spring @Autowired y la inyección de dependencias",
        "link": "https://www.arquitecturajava.com/spring-autowired-y-la-inyeccion-de-dependencias/",
        "contenido": "Spring @Autowired es una de las anotaciones más habituales cuando trabajamos con Spring Framework ya que se trata de la anotación que permite inyectar unas dependencias con otras dentro de Spring . Spring @Autowired y su funcionamiento Normalmente estamos acostumbrados a usar @AutoWired a nivel de la propiedad que deseamos inyectar. Spring funciona como una mega factoria de objetos. Cada clase se registra para instanciar objetos con alguna de las anotaciones @Controller ,@Service ,@repository o @RestController. Spring inyeccion dependencia Una vez que los objetos estan creados la anotación Spring @Autowired se encarga de construir las ligazones entre los distintos elementos Spring @Autowired Por ejemplo este caso es habitual cuando tenemos un servicio y un repositorio. Vamos a verlo usando Spring Boot package com.arquitecturajava.wired; import java.util.ArrayList; import java.util.List; import org.springframework.stereotype.Component; import org.springframework.stereotype.Repository; @Repository public class LibroRepository { public List<Libro> buscarTodos() { List<Libro> lista= new ArrayList<Libro>(); lista.add(new Libro ( 1 , java , pedro )); lista.add(new Libro ( 2 , python , gema )); return lista; } } Como podemos ver tenemos el LibroRepository como primer componente y le queremos enlazar desde un Servicio. package com.arquitecturajava.wired; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class LibroRestService { @Autowired LibroRepository repositorio; @RequestMapping( /libros ) public List<Libro> buscarTodos() { return repositorio.buscarTodos(); } } Ahora tenemos los dos elementos enlazados y un ServicioREST publicado por lo tanto si ejecutamos la aplicación de Spring Boot dispondremos de una Url con un listado de Libros disponible Spring @Autowrired rest Spring Testing y Wiring Hoy por hoy las metodologías de TDD cada día se usan más y aunque este uso de la anotacion @Autowired es el más habitual suele ser más práctico y cómodo para el manejo de test realizar un @Autowired a nivel de constructores por lo tanto el código quedaría así: package com.arquitecturajava.wired; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class LibroRestService { LibroRepository repositorio; @Autowired public LibroRestService(LibroRepository repositorio) { this.repositorio=repositorio; } @RequestMapping( /libros ) public List<Libro> buscarTodos() { return repositorio.buscarTodos(); } } De esta manera el código queda más limpio , flexible y más sencillo de usar cuando utilicemos Test Driven Development."
    },

    {
        "id": 79,
        "autor": "Iván Salas",
        "pagina": "programandoointentandolo",
        "fecha": "22/05/2013",
        "titulo": "INYECCIÓN DE DEPENDENCIAS EN SPRING",
        "link": "https://programandoointentandolo.com/2013/05/inyeccion-de-dependencias-en-spring.html",
        "contenido": "La inyección de dependencias es quizás la característica más destacable del core de Spring Framework, que consiste que en lugar de que cada clase tenga que instanciar los objetos que necesite, sea Spring el que inyecte esos objetos, lo que quiere decir que es Spring el que creara los objetos y cuando una clase necesite usarlos se le pasaran (como cuando le pasas un parámetro a un método). La inyección de dependencias es una forma distinta de diseñar aplicaciones, si estas empezando con Spring (como yo) ya habrás visto que en muchos sitios usan los términos inyección de dependencia (DI) e inversión de control (IoC) de forma indistinta y aunque no son sinónimos, sino que más bien la inyección de dependencia sería una forma de inversión de control. Pero probablemente te preguntaras en que consiste la inyección de dependencia y que ventajas tiene su uso, pues aquí voy a intentar explicar lo que yo he entendido con unos ejemplos para verlo de una forma más intuitiva, que para ver definiciones ya hay muchos libros. La DI consiste en que en lugar de que sean las clases las encargadas de crear (instanciar) los objetos que van a usar (sus atributos), los objetos se inyectaran mediante los métodos setters o mediante el constructor en el momento en el que se cree la clase y cuando se quiera usar la clase e cuestión ya estará lista, en cambio sin usar DI la clase necesita crear los objetos que necesita cada vez que se use. En Spring hay un Contendor DI que es el encargado de inyectar a cada objeto los objetos que necesita (de los que depende) según se le indique ya sea en un archivo de configuración XML o mediante anotaciones. Con esta pequeña explicación te puedes hacer una idea de en que consiste la inyección de dependencia, vamos ahora a ver cual es el sentido de su uso. La que nos ofrece la inyección de dependencias es desacoplamiento y también que los objetos son instanciados en el Contenedor DI y se inyectan donde sea necesario de forma que pueden ser reutilizados. Un ejemplo típico para ver su utilidad es el de una clase que necesita una conexión a base de datos, sin DI si varios usuarios necesitan usar esta clase se tendrán que crear múltiples conexiones a la base de datos con la consiguiente posible perdida de rendimiento, pero usando la inyección de dependencia las dependencias de la clase (sus atributos), son instanciados una única vez cuando se despliega la aplicación y se comparten por todas las instancias de modo que una única conexión a base de datos es compartida por múltiples peticiones. En este caso esta bien que sea una única instancia pero habrá casos en los que no nos interesará esta opción que es la que se usa por defecto por lo que Spring nos da la opción por si queremos que nuestros objetos no usen el patrón singleton. Y en lo referente al desacoplamiento como no es necesario instanciar en una clase los objetos que necesita sino que son inyectados si la clase que necesita cambia no es necesario modificar nada en la clase que hacia uso de ella. Y en lo referente al desacoplamiento al no tener que instanciar las dependencias si alguna cambia no hay que modificar nada pues esa clase no estará instanciada en ningún sitio de nuestra clase (Clase c = new clase();). Vamos a ver unos ejemplos de como se hace la DI mediante settters, mediante el constructor y con el uso de anotaciones para no tener que escribir nada en el xml. EJEMPLO DE INYECCIÓN DE DEPENDENCIA MEDIANTE SETTTERS Para que se vean bien las cosas vamos a crear una aplicación de escritorio, en una aplicación web la aplicación es la misma pero como hay más archivos de configuración es más fácil equivocarse aunque como digo la inyección de dependencia se hace exactamente igual, salvo que para una aplicación de escritorio hay que indicarle en el Main donde se encuentra el archivo en el que están declarados los beans y en una aplicación web se hace en el web.xml. En este primer ejemplo vamos a usar una clase Libro que entre sus atributos tendrá uno de la clase Autor y en el Main mostraremos los datos del libro. package com.blogspot.programandoointentandolo; public class Libro { private String titulo; private Autor autor; private String genero; private String editorial; private int edicion; private int paginas; // Getters y Setters } package com.blogspot.programandoointentandolo; public class Autor { private String nombre; private String apellido; // Getters y Setters } La clase Libro es un simple POJO y como vamos a inyectar las dependencias mediante setters pues lógicamente deberá disponer de ellos (lo mismo para Autor) y en el Main para hacer uso de la ID primero debemos de cargar el xml en el que estarán definidos los beans y luego obtenemos el que nos interesa (libro). package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.BeanFactory; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { BeanFactory factory = new ClassPathXmlApplicationContext( META-INF/spring/app-context.xml ); Libro libro = (Libro) factory.getBean( libro ); System.out.println( -   + libro.getTitulo()); System.out.println( -   + libro.getAutor().getNombre() +     + libro.getAutor().getApellido()); System.out.println( -   + libro.getEditorial()); System.out.println( -   + libro.getGenero()); System.out.println( -   + libro.getEdicion()); System.out.println( -   + libro.getPaginas()); } } Vamos con el app-context.xml que será donde definamos los beans para poder inyectarlos donde lo necesitemos: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <bean id= libro  class= com.blogspot.programandoointentandolo.Libro > <property name= titulo  value= Aprendiendo Spring /> <property name= autor  ref= autor /> <property name= genero  value= Aventuras /> <property name= edicion  value= 2 /> <property name= paginas  value= 257 /> </bean> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <property name= nombre  value= Luis  /> <property name= apellido  value= Perez  /> </bean> </beans> Viendo el código anterior te puedes hacer una idea bastante buena de que es lo que hace sin ninguna explicación pero vamos a explicarlo. En primer lugar las clases se definen con la etiqueta <bean> y se deben de indicar el atributo class que indica donde esta la clase de la que será el bean y si se quiere usar en otro lugar el atributo id que nos servirá como identificador del bean. Dentro de cada bean se pueden indicar las propiedades que se quieren inyectar con la etiqueta property, el atributo name hace referencia al nombre del atributo que se quiere inyectar, por ejemplo el primero es para inyectar el titulo, y después puede tener un atributo value si le queremos inyectar un String, int,… y el atributo ref que lo usaremos cuando queramos inyectar otro bean, es el caso de autor, y en el atributo ref debemos de poner el id del bean que queremos inyectarle, en este caso también es autor. Y con esto cuando ejecutemos la aplicación veremos como se nos imprimen los valores que hemos introducido en xml sin haber tenido que instanciar en ningún momento ningún objeto ni de la clase Libro ni de la clase Autor. Pues así de sencilla es la inyección de dependencia. EJEMPLO DE INYECCIÓN DE DEPENDENCIA MEDIANTE EL CONSTRUCTOR Además de poder inyectar mediante métodos setters también se puede inyectar mediante constructor aunque es mejor la primera opción. Vamos a ver en este ejemplo como inyectar las propiedades del Autor mediante constructor para lo cual la clase Autor deberá de tener un constructor con los parámetros nombre y apellido y no hace falta que tenga métodos setters. No hace falta modificar otra cosa del resto del código java. Y el xml para poder inyectar mediante constructor en el bean autor es este: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <bean id= libro  class= com.blogspot.programandoointentandolo.Libro > <property name= titulo  value= Aprendiendo Spring /> <property name= autor  ref= autor /> <property name= genero  value= Aventuras /> <property name= edicion  value= 2 /> <property name= paginas  value= 257 /> </bean> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <constructor-arg value= Luis  /> <constructor-arg value= Perez  /> </bean> </beans> Los parámetros del libro los seguimos inyectando mediante setters pero para el autor usaremos el constructor para lo que debemos de cambiar property por constructor-arg y solo le indicamos el value o ref si fuese el caso, pero no hay que indicar el name ya que estos atributos se pasaran en orden al constructor por lo que debemos de tener cuidado de ponerlos en el orden correcto. EJEMPLO DE INYECCIÓN DE DEPENDENCIA CON ANOTACIONES De las dos formas anteriores era necesario indicar en el archivo de configuración que beans podían ser inyectados en otros y sobre los que se querían inyectar. Mediante las anotaciones podemos hacer ambas cosas o solo una si se quiere, por ejemplo podemos declarar los beans en el xml y usar anotaciones para inyectarlos en lugar de usar <property name=»autor» ref=»autor»>. Antes de empezar voy a poner una lista de las anotaciones que voy a comentar: @Component:Sustituye la declaración del bean en el xml. @Autowired:Sustituye la declaración de los atributos del bean en el xml. @Qualifier(«nombreBean»):Sirve para indicar que clase es la que se debe inyectar. @Required:Indica si el atributo es obligatorio. @Service, @Repository y @Controller:Son estereotipos de @Component y se usan para indicar que la clase sera un servicio (@Service), una clase de acceso a datos (@repository) o un controlador (@Controller). @PostConstruct:Ejecuta el metodo con esta anotación despues de crear el objeto. @PreDestroy:Ejecuta el metodo con esta anotación antes de destruir el objeto. @Scope:Sirve para indicar el ambito en el que se encontrara el bean. Las anotaciones de la lista anterior son propias de Spring pero también se pueden usar anotaciones propias del standar Java EE como las 2 siguientes: @Inject:Se puede usar en lugar de @Autowired. @Resource(«nombreBean»):Sustituye el uso de las anotaciones @Autowired y @Qualifier(«nombreBean») de forma que es necesaria una sola anotación. @AUTOWIRED Para empezar vamos a ver la anotación @Autowired que nos permite no tener que definir la propiedad que se quiere inyectar en el xml dentro del bean. La anotación @Autowired se puede poner encima del atributo que se quiere inyectar, encima del método setter de dicho método o también encima del constructor y dependiendo de donde se ponga la inyección se haría por atributo, por setter o por constructor como es lógico. Respecto al código que teníamos sin usar anotaciones hay que modificar la clase Libro añadiendo la anotación @Autowired de cualquiera de las 3 formas que decía, en este ejemplo anotamos el atributo. import org.springframework.beans.factory.annotation.Autowired; public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired private Autor autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; // Setters y getters } Y en el xml quedaría así: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <!-- Habilita el uso de anotaciones --> <context:annotation-config /> <bean id= libro  class= com.blogspot.programandoointentandolo.Libro /> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <constructor-arg value= Luis  /> <constructor-arg value= Perez  /> </bean> </beans> El bean autor sigue igual ya que no hemos hecho ninguna anotación en el, pero en el bean libro ahora no hay ningún atributo ya que ahora hemos usado la anotación @Autowired para inyectar el autor, y el resto de campos que son simples strings e ints simplemente están inicializados en la clase aunque en un ejemplo más «serio» pues se le darían valores con los setters por ejemplo aunque para el caso de ver como funcionan las anotaciones eso no aporta nada. Además de que en el bean libro ya no están los atributos para poder usar la anotación @Autowired es necesario incluir <context:annotation-config /> para indicar que vamos a usar esta anotación. @COMPONENT Esta anotación nos evita la necesidad de declarar el bean en el xml, vamos a anotar las clases Libro y Autor con @Component y de este modo ya no tendremos ningún bean en el xml, de modo que el xml solo tendrá que contener la siguiente línea en la que le indicamos el paquete apartir del que se buscaran las clases anotadas con @Component o cualquiera de sus estereotipos y también sustituye a <context:annotation-config /> que usemos por si solo queríamos usar @Autowired. <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <!-- Habilita el uso de anotaciones --> <context:component-scan base-package= com.blogspot.programandoointentandolo  /> </beans> Y en lo referente a las clases Autor y Libro quedarian de la siguiente forma: package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component public class Autor { private String nombre =  Luis ; private String apellido =  Perez ; public Autor(){} // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired private Autor autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } Además de anotar la clase con @Component tambien hay que añadir un constructor sin parámetros, en el caso de que tuviésemos alguno con parámetros ya que al usar la anotación @Component el objeto se crea con este constructor y sino lo tenemos no compilará. @QUALIFIER Con esta anotación podemos indicar el id del bean que se quiere inyectar, esta anotación se usa cuando el atributo que vamos a inyectar es una interfaz de la que hay varias implementaciones y entonces será mediante esta anotación con la que le diremos cual es la clase que queremos inyectar. También se puede usar por ejemplo si en el xml declaramos varios beans que aunque sean de la misma clase (tengan el mismo atributo class) tengan un id distinto. Aunque en los ejemplos que he puesto no he puesto ninguna interfaz pues no aporta nada a la explicación lo normal será que las clases que se inyectan sean interfaces para hacer el código más desacoplado y facilitar las posibles futuras modificaciones. Por ejemplo si en lugar de la clase autor directamente tuviésemos una interfaz AutorInterfaz y dos clases AutorDesconocido y AutorConocido package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component( autordesconocido ) public class AutorDesconocido implements AutorInterfaz{ private String nombre =  Luis ; private String apellido =  Perez ; // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component( autorconocido ) public class AutorConocido implements AutorInterfaz{ private String nombre =  Antonio ; private String apellido =  Fernandez ; // Setters y getters } Como en @Qualifier hemos indicado autorconocido se inyectara la clase AutorConocido pero si quisiésemos cambiar para que se inyectara AutorDesconocido o cualquier otra clase que implementase AutorInterfaz solo tendríamos que indicar en @Qualifier el nombre del bean que queremos inyectar. @REQUIRED Esta anotación creo que esta bastante claro para que se usa, si queremos que un campo sea obligatorio lo anotaremos con @Required. Para que el autor fuese obligatoria la clase Libro sería así: package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } @POSTCONSTRUCT Y @PREDESTROY Estas son anotaciones para métodos y las usaremos si queremos que se ejecute un método justo después de que se haya creado la clase (objeto de la clase) o antes de que se destruya. import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} @PostConstruct public void saludar(){ System.out.println( Hola ); } @PreDestroy public void despedirse(){ System.out.println( Adios ); } // Setters y getters } @SCOPE Con esta anotación indicamos cuando se crearan instancias de la clase con esta anotación y en que ámbito. Si no se usa la anotación @Scope (valor por defecto) el scope es singleton. Los posibles valores son: singleton: Se crea una unica instancia del bean para toda la aplicación. prototype: Se crea una nueva instacia del bean cada vez. request: Se crea una nueva instacia del bean para cada petición HTTP request. session: Se crea una nueva instacia del bean por sesión HTTP. globalSession: Se crea una nueva instacia del para cada sesión HTTP global. Las 3 ultimas aunque supongo que se ve por el nombre solo son para aplicaciones web mientras que las dos primeras pueden usarse en cualquier tipo de aplicación Spring. Y para finalizar si quisiésemos que se crease una instancia de la clase Libro cada vez usaríamos @Scope(«prototype»). import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; @Component @Scope( prototype ) public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} @PostConstruct public void saludar(){ System.out.println( Hola ); } @PreDestroy public void despedirse(){ System.out.println( Adios ); } // Setters y getters } Después de ver como hacer las inyecciones de dependencias con anotaciones probablemente te preguntaras si es mejor o peor usar anotaciones. Desde el punto de vista de que es más fácil y más rápido esta claro que ganan las anotaciones y desde el punto de vista de tener todo centralizado mejor usar el xml porque con las anotaciones esta repartido por toda la aplicación por lo que para modificar algo sería necesario buscarlo, modificarlo y recompilarlo mientras que con el xml todo esta en el mismo sitio y con cambiar el xml esta todo listo sin hacer nada más. Entonces podríamos decir que las anotaciones son ideales durante la fase de desarrollo porque el código esta cambiando constantemente y cuanto más rápido sea hacer un cambio mejor y una vez que la aplicación ya sea «estable» se sustituyen las anotaciones y de este modo tenemos las ventajas de ambas opciones en los momentos en las que los necesitamos, aunque no se si tiene demasiado sentido hacer esto"
    },

    {
        "id": 80,
        "autor": "Rubén Pahino",
        "pagina": "campusmvp",
        "fecha": "31/03/2020",
        "titulo": "¿Qué son Spring framework y Spring Boot? Tu primer programa Java con este framework",
        "link": "https://www.campusmvp.es/recursos/post/que-son-spring-framework-y-spring-boot-tu-primer-programa-java-con-este-framework.aspx",
        "contenido": "Si desarrollas con Java, o lo has hecho en algún momento de los últimos años, seguramente te suene Spring Framework, aunque sea de oídas. Spring Framework es un framework Open Source que facilita la creación de aplicaciones de todo tipo en Java, Kotlin y Groovy. Si bien es cierto que, por lo que es más conocido es por la inyección de dependencias, Spring Framework está dividido en diversos módulos que podemos utilizar, ofreciéndonos muchas más funcionalidades: Core container: proporciona inyección de dependencias e inversión de control. Web: nos permite crear controladores Web, tanto de vistas MVC como aplicaciones REST. Acceso a datos: abstracciones sobre JDBC, ORMs como Hibernate, sistemas OXM (Object XML Mappers), JSM y transacciones. Programación orientada a Aspectos (AOP): ofrece el soporte para aspectos. Instrumentación: proporciona soporte para la instrumentación de clases. Pruebas de código: contiene un framework de testing, con soporte para JUnit y TestNG y todo lo necesario para probar los mecanismos de Spring. Estos módulos son opcionales, por lo que podemos utilizar los que necesitemos sin tener que llenar nuestro classpath con clases que no vamos a usar. Esquema que ilustra los diferentes módulos de Spring, obtenido de la documentación oficial Razones para usar Spring Aunque no sea una característica única de Spring, el uso de inyección de dependencias facilita la programación contra interfaz, permitiendo a los distintos componentes depender únicamente de interfaces y produciendo así un código menos acoplado. No solo eso, también permite implementar el patrón singleton de una forma extremadamente sencilla (por defecto, las dependencias que inyectamos son singletons). Hay cientos de tecnologías que Spring permite integrar. Desde bibliotecas que implementan opentracing hasta las que nos generan métricas para nuestra aplicación, pasando por serialización/deserialización a JSON y XML, seguridad con OAuth2 o programación reactiva entre otras. En general, Spring aumenta la productividad y reduce la fricción al ofrecernos abstracciones sobre implementaciones de tecnologías concretas. Un ejemplo claro es el de spring-data, que nos permite definir el acceso a base de datos con interfaces Java. Esto lo consigue parseando el nombre de los métodos y generando la consulta con la sintaxis específica para el driver que utilicemos. Por ejemplo, cambiar nuestra aplicación de MySQL a PostgreSQL es tan sencillo como cambiar el driver: Spring se encarga de la sintaxis de forma transparente. A pesar de  la magia de Spring  🧙🏻‍♂️, como muchos lo llaman, Spring nos permite desactivar estos  comportamientos mágicos  en caso de ser necesario, por lo que podemos tomar el control cuando necesitemos más granularidad. Siguiendo con el ejemplo de spring-data, este control sería necesario si tenemos que realizar consultas mucho más complejas que un SELECT * BY name. En esos casos, entre otras opciones, podemos anotar nuestro método con @Query y escribir la consulta que deseemos. Ya no hay magia 😉 Por lo general, Spring no obliga a implementar ni extender nada, lo que nos permite escribir código que es  agnóstico  del framework. De esta forma, desarrolladores con cero o muy poco conocimiento de Spring pueden realizar su trabajo sin mayores complicaciones. Spring es de código abierto y tiene una gran comunidad detrás. Si encuentras un bug, echas en falta una funcionalidad o lo que sea, siempre puedes abrir un ticket o contribuir por tu cuenta. ¿Pero no íbamos a hablar de Spring Boot? Hasta ahora he hablado de Spring Framework en general, pero el título de esta entrada menciona Spring Boot, así que voy a presentarlo. Si bien es cierto que Spring Framework es muy potente, la configuración inicial y la preparación de las aplicaciones para producción son tareas bastante tediosas. Spring Boot simplifica el proceso al máximo gracias a sus dos principales mecanismos. Contenedor de aplicaciones integrado Spring Boot permite compilar nuestras aplicaciones Web como un archivo .jar que podemos ejecutar como una aplicación Java normal (como alternativa a un archivo .war, que desplegaríamos en un servidor de aplicaciones como Tomcat). Esto lo consigue integrando el servidor de aplicaciones en el propio .jar y levantándolo cuando arrancamos la aplicación. De esta forma, podemos distribuir nuestras aplicaciones de una forma mucho más sencilla, al poder configurar el servidor junto con la aplicación. Esto también es muy útil en arquitecturas de microservicios, puesto que permite distribuir nuestras aplicaciones como imágenes Docker que podemos escalar horizontalmente (algo muy complicado con un .war). Nota: Spring boot permite distribuir tu aplicación como un jar, no lo impone. Si prefieres desplegar tu aplicación en un servidor de aplicaciones tradicional, Spring Boot te deja compilar el código como un .war que no incluya ningún servidor de aplicaciones integrado. Starters Spring Boot nos proporciona una serie de dependencias, llamadas starters, que podemos añadir a nuestro proyecto dependiendo de lo que necesitemos: crear un controlador REST, acceder a una base de datos usando JDBC, conectar con una cola de mensajes Apache ActiveMQ, etc. Una vez añadimos un starter, éste nos proporciona todas las dependencias que necesitamos, tanto de Spring como de terceros. Además, los starters vienen configurados con valores por defecto, que pretenden minimizar la necesidad de configuración a la hora de desarrollar. Un buen ejemplo es el de spring-boot-starter-actuator: una vez que añadimos la dependencia, nuestra aplicación empezará a generar métricas tanto de la JVM como de la aplicación en sí (latencias, errores, etc). Al igual que con Spring Framework, cualquier configuración puede ser modificada de ser necesario: desde el puerto en el que la aplicación escucha peticiones, hasta el banner que sale por consola al arrancar la aplicación. Hola Mundo con Spring Boot Para demostrar lo fácil que es empezar a usar Spring Boot, vamos a ver el código necesario para crear nuestro primer  Hola mundo : @SpringBootApplication @RestController public class Application { @GetMapping( /hello ) public String hello() { return  Hello Bootiful! ; } } Sencillo, ¿verdad? Aprende con nosotros a sacarle todo el partido a Spring Framework y Spring Boot. Un poco más abajo te explico en un vídeo práctico cómo llegar a este código y qué significa. Bonus tip: Spring Initializr Captura de Spring Initializr El equipo de Spring también ha creado Spring Initializr, una herramienta web que puedes utilizar para autogenerar el esqueleto de tu aplicación Spring Boot. Se trata de un inicializador muy útil, ya que genera el pom.xml (o build.gradle), el main de la aplicación, y un test que comprueba que la aplicación arranca correctamente."
    },

    {
        "id": 81,
        "autor": "Cleventy",
        "pagina": "cleventy",
        "fecha": "8/07/2020",
        "titulo": "Capa controlador de un proyecto Spring Boot",
        "link": "https://cleventy.com/capa-controlador-de-un-proyecto-spring-boot/",
        "contenido": "Este artículo continua la serie iniciada en el primer artículo. En este artículo vamos a presentar la implementación de la capa controlador de la aplicación. Entendemos como controlador a la capa de una aplicación que responde a eventos e invoca peticiones a la capa modelo. En nuestro ejemplo, los controladores están bajo el paquete controller y tienen las siguientes características: Están anotados con @Controller (o @RestController) Atienden peticiones bajo una ruta definida en la anotación @RequestMapping Su nombre termina en Controller Suelen tener inyectados (con anotación @Autowired) el servicio relacionado al que acceden Responden a diferentes métodos HTTP definidos por la anotación @GetMapping Diferenciamos, dependiendo de la naturaleza de los eventos, entre Controlador Web y Controlador API. Controlador Web Responde a eventos lanzados por el usuario desde la web. Un ejemplo es el controlador web de administración de usuarios. En él hay un único método que lo que hace es obtener todos los usuarios y devolverlos a una vista. Esta comunicación se realiza a través del enlace de propiedades en el objeto del modelo (org.springframework.ui.Model). Para lanzar este invocación basta con lanzar una petición GET a la página de administración de usuarios, o, en otras palabras más sencillas, acceder a dicha URL desde el navegador. Controlador API Define un API Rest y por lo tanto responde a diferentes tipos de peticiones. Útil para comunicar e integrar nuestra aplicación con otros sistemas como por ejemplo una aplicación móvil. Un ejemplo (análogo al anterior) sería el controlador API de administración de usuarios. En él hay poco más que un CRUD completo de Usuario, permitiendo, por lo tanto, crear, leer, actualizar y borrar usuarios. Algunas de sus características son: A diferencia de los controladores web, estos están anotados por @RestController. Devuelven una objeto genérico de respuesta (org.springframework.http.ResponseEntity) que contiene, a su vez, más información propia de la petición. Admite diferentes tipos de parámetros: @RequestParam: por ejemplo, el parámetro page en /api/admin/users?page=1 @PathVariable: por ejemplo, el identificador de usuario 3 en /api/admin/users/3/sendwelcomeemail @RequestBody: por ejemplo, el cuerpo de la petición POST de creación de usuario /api/admin/users Para explotar/visualizar estos datos es bueno verlo con un ejemplo. Podemos verlo con Postman o directamente con una petición cURL. Podemos importar la petición cURL directamente en Postman o ejecutar en la consola la siguiente petición para obtener los usuarios: curl --location --request GET 'http://localhost:8080/application-4.0.5/api/admin/users'  --header 'Content-Type: application/json'  --header 'Accept: '  --header 'Authorization: Bearer <my_token>' </my_token> Otro ejemplo de petición, esta sin autenticación, sería, por ejemplo, esta: curl --location --request GET 'http://localhost:8080/application-4.0.5/api/version'  --header 'Content-Type: application/json'"
    },

    {
        "id": 82,
        "autor": "Cecilio Álvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "24/07/2015",
        "titulo": "Spring REST Service con @RestController",
        "link": "https://www.arquitecturajava.com/spring-rest-service-con-restcontroller/",
        "contenido": "Crear un Spring REST Service es ahora muy sencillo a través del uso de la anotación @RestController que Spring 4 soporta. En primer lugar se configura el fichero de pom.xml de Maven con las siguientes dependencias. <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>4.1.7.RELEASE</version> </dependency> <dependency> <groupId>javax.servlet</groupId> <artifactId>jstl</artifactId> <version>1.2</version> <scope>provided</scope> </dependency> <dependency> <groupId>javax.servlet</groupId> <artifactId>servlet-api</artifactId> <version>2.5</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-validator</artifactId> <version>5.1.3.Final</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-core</artifactId> <version>2.4.2</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.4.2</version> </dependency> </dependencies> El siguiente paso es configurar el Servlet Dispatcher en el web.xml que es el que nos permite mapear todas las urls de los controladores de Spring. <web-app xmlns= http://java.sun.com/xml/ns/javaee  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd version= 3.0 > <servlet> <servlet-name>ServletSpring</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/config/applicationContext.xml</param-value> </init-param> </servlet> <servlet-mapping> <servlet-name>ServletSpring</servlet-name> <url-pattern>*.html</url-pattern> <url-pattern>*.json</url-pattern> </servlet-mapping> </web-app> El último paso a nivel de configuración es definir el fichero applicationContext.xml: <beans xmlns= http://www.springframework.org/schema/beans xmlns:context= http://www.springframework.org/schema/context xmlns:mvc= http://www.springframework.org/schema/mvc  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:p= http://www.springframework.org/schema/p xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc12 http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd > <mvc:annotation-driven /> <context:component-scan base-package= com.arquitecturajava.controller  /> </beans> Realizada la configuración será suficiente con crear una clase que use la anotación @RestController y automaticamente se publicara como un  Spring REST Service. springrestservicepublicacion package com.arquitecturajava.controller; import java.util.ArrayList; import java.util.List; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import com.arquitecturajava.negocio.Persona; @RestController public class ControladorREST { @RequestMapping(value =  /personas , method = RequestMethod.GET) public List < Persona > listaPersonas() { List < Persona > lista = new ArrayList < Persona > (); Persona p = new Persona(); p.setNombre( angel ); p.setEdad(20); lista.add(p); Persona p1 = new Persona(); p1.setNombre( gema ); p1.setEdad(30); lista.add(p1); return lista; } } Acabamos de crear un servicio REST que nos devuelve una Persona en una url determinada , concretamente en /personas recordemos que para las url REST normalmente se utilizan los plurales. Cursos asociados Curso de Spring Boot Curso de Spring WebFlux Curso de Java 8 Ya solo queda realizar una petición web a la URL en donde se ha mapeado el Spring REST Service: spring rest service Conclusiones Spring 4 introduce novedades que hacen la vida más sencilla a los desarrolladores"
    },

    {
        "id": 83,
        "autor": "Cristian Ruiz",
        "pagina": "cristianruizblog",
        "fecha": "29/09/2018",
        "titulo": "Spring Boot 2 + MVC Parte 1| Usando JSP?",
        "link": "http://cristianruizblog.com/spring-boot-mvc-parte-1-usando-jsp/",
        "contenido": "Que es MVC? Es la solucion al problema de como conectar el CLIENTE con el SERVIDOR, en este caso en una aplicacion web de manera rapida, organizada y sencilla. Con Spring Boot Framework se puede implementar el patron de diseño Modelo – Vista – Controlador mejor conovido como MVC, donde la capa llamada vista (archivos HTML o JSP) que normalmente es el cliente en nuestra aplicacion web se comunica con la capa de negocio (Archivos Java llamados Controladores) que seria el servidor, por medio de Modelos (Archivos Java mejor conocidos como Plain Old Java Object). Para comprender como se comunica una aplicacion web que implementa el patron de diseño MVC analisa la siguiente imagen: El cliente hace un request al despachador de servlets y este llama al encargado de mapeo url, identifica a que controller y que metodo estas queriendo acceder y le devuelve esa informacion al despachador para invocar ese metodo. En la declaracion del metodo puedes poner tu model(POJO) Y si los atributos del request son iguales a los atributos de tu POJO, la implementacion de Spring Boot MVC asignara esos valores automaticamente, permitiendote utilizar esa informacion para tu logica de negocio y persistencia. Una vez terminado el proceso anterior vas a querer mostrar algun tipo de mensaje o pagina web, aqui es donde entra el view. Debes indicarle a Spring Boot cual es la siguiente pagina y que informacion deseas enviar. Spring Boot creara un view(response) en base a esa informacion y se lo devolvera al cliente. Manos a la obra. Paso a Paso: En el siguiente video te mostrare paso a paso como crear una aplicacion WEB, con arquitectura MVC, ademas podras encontrar el codigo en github para poder compararlo con el tuyo. github: Repositorio github Crear Proyecto: Asegurate de utilizar el initializr de spring boot Selecciona el tipo de packaging war Selecciona la dependencia WEB Finish (Si necesitas ayuda creando proyecto con SpringBoot revisa mi tutorial Spring Boot – Que es? y como se come? Configuracion para que interprete archivos JSP: Crear la estructura de carpetas src/main/webapp/WEB-INF/jsp Crear los archivos jsp que necesite tu proyecto Agrega estas dos atributos en el archivos application.properties : spring.mvc.view.prefix: /WEB-INF/jsp/ spring.mvc.view.suffix: .jsp Alterar ruta de ubicacion para JSP Agrega la siguiente dendencia al archivo application.properties Dependencia necesaria para compilar JSP en Spring Boot Ok, ya tu proyecto esta listo para ejecutar archivos JSP, procede a crear los puntos de acceso o controladores: crea una clase Java y en la declaracion de la clase agrega la notacion @Controller hay diferentes maneras de crear metodos dependiendo del proposito: Para renderizar un JSP, declara un metodo que retorne un String (el nombre del jsp) Agrega la anotacion @GetMapping y dentro de su constructor agrega la ruta en la url por la cualquieras acceder a ese JSP Ejemplo de un Controller simple donde redireccionas a otra pagina. Si quieres mas ejemplo de como enviar y recibir datos desde y hacia un jsp mira el video que hay mas arriba. No uses mas JSP y da un paso alfrente y se mas productivo creando codigo mas limpio y entendible para otros, usando Thymeleaf. No olvides de ver la segunda parte de este tutorial. Spring Boot + MVC Parte 2| Usando Thymeleaf Para cerrar : Spring Boot es muy popular para la creacion de Paginas y Servicios Web, poco a poco explicare mas a fondo las capacidades y caracteristicas unicas de SPRING BOOT. Espero este post responda tus dudas y si tienes alguna sugerencia y/o aporte por favor dejalo en los comentarios."
    },

    {
        "id": 84,
        "autor": "Gary Briceño",
        "pagina": "clubdetecnologia",
        "fecha": "30/10/2018",
        "titulo": "10 Conceptos de POO en Java",
        "link": "https://www.clubdetecnologia.net/blog/2018/10-conceptos-de-poo-en-java/",
        "contenido": "Cómo probablemente sepa, los conceptos de programación orientada a objetos son muy importantes. Sin una idea de los conceptos de la POO, no estará en la capacidad de diseñar sistemas utilizando el modelo de POO ya que este simplifica el desarrollo de software y mantenimiento. En este artículo, se van a explicar 10 conceptos importantes de la POO con ejemplos.[/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 1. Abstracción Intención: La abstracción significa ocultar detalles de nivel interior o exponer solo los detalles esenciales y relevantes a los usuarios. Ejemplo real: Un automóvil abstrae los detalles internos y expone al conductor solo a detalles que son relevantes para la interacción del conductor con el automóvil. Por ejemplo, cuando recibimos una llamada telefónica, no conocemos el proceso interno. En Java, se usa la clase abstracta y la interfaz para lograr la abstracción. Nunca compramos un “dispositivo”, pero siempre compramos algo más específico: iPhone, Nokia 3310, etc. Aquí estos ejemplos son concretos, el dispositivo es algo abstracto. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 2. Encapsulación Intención: La encapsulación se refiere a la combinación de datos y funciones asociadas como una sola unidad. En la POO, los datos y las funciones que operan con estos datos se combinan para tomar una sola unidad, lo que se conoce como una clase. Ejemplo: Cápsula: Se envuelven diferentes medicamentos. Una clase de Java es el ejemplo de una encapsulación. Un bean Java es la clase totalmente encapsulada porque todos los miembros de datos son privados aquí. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 3. Herencia Intención: La herencia es una relación entre una super clase y sus sub clases. En consecuencia, este es un proceso donde un objeto adquiere los miembros de otro; además, el mismo puede formar parte de él. Explicación: La herencia es un mecanismo de reutilización en la programación orientada a objetos en el que se explotan las propiedades comunes de varios objetos para establecer relaciones entre sí. Las propiedades abstractas y comunes se proporcionan en la superclase, que esta disponible para las subclases más especializadas. Cuando decimos que la clase B se hereda de otra clase A, se hace referencia a la clase B como una clase derivada (o subclase), y la clase A se llama una clase base (o superclase). Por herencia, la clase derivada recibe el comportamiento de la clase base para que todos los métodos y variables de miembros visibles de la clase base estén disponibles en la clase derivada. Aparte del comportamiento heredado, la clase derivada especializa su comportamiento al agregar o anular el comportamiento de la clase base.[/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 4. Polimorfismo Intención: El polimorfismo nos permite realizar una misma acción de diferentes maneras El polimorfismo le permite definir una interfaz y tener múltiples implementaciones Podemos crear funciones o variables de referencia que se comportan de manera diferente en diferentes contextos programáticos. El polimorfismo significa muchas formas. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 5. Asociación Intención Representa una relación entre dos o más objetos donde todos los objetos tienen su propio ciclo de vida y no hay ningún propietario. El nombre de una asociación especifica la naturaleza de la relación entre los objetos. La asociación es una relación entre dos clases separadas que se establece a través de sus objetos. La asociación puede ser uno a uno, uno a muchos, muchos a uno y muchos a muchos. En la programación orientada a objetos, un objeto se comunica con otro objeto para usar la funcionalidad y los servicios proporcionados por ese objeto. Hay dos formas de asociación: Composición Agregación [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 6. Composición Intención La composición es una asociación que representa una parte de una relación completa donde una parte no puede existir sin un todo. Si se elimina un entero, entonces se eliminan todas las partes. Tiene una relación más fuerte. Puntos clave: Representa una parte de la relación. En composición, ambas entidades dependen una de la otra. Cuando hay una composición entre dos entidades, el objeto compuesto no puede existir sin la otra entidad. Por ejemplo, si el pedido tiene artículos de línea A-A, un pedido es un artículo completo y los artículos de línea son partes. Si se elimina un pedido, se deben eliminar todas las líneas correspondientes a ese pedido. Favorecer la composición sobre la herencia. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 7. Agregación Intención La agregación es una asociación que representa parte de una relación completa donde una parte puede existir sin un todo. Tiene una relación más débil. Es una forma especializada de asociación donde todos los objetos tienen su propio ciclo de vida, pero existe la propiedad. Esto representa una relación de “parte completa” o “parte de parte”. Tomemos un ejemplo de la relación entre el Departamento y el Maestro. Un profesor puede pertenecer a múltiples departamentos. Por lo tanto, el profesor es parte de múltiples departamentos. Pero si eliminamos un Departamento, el objeto Maestro no será destruido. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 8. Delegación Intención: Entregar la responsabilidad de una tarea particular a otra clase o método. Es una técnica en la que un objeto expresa cierto comportamiento hacia el exterior, pero en realidad, es responsabilidad de los delegados implementar ese comportamiento en un objeto asociado. Aplicabilidad: Utilice la delegación para lograr lo siguiente: Reducir el acoplamiento de métodos a su clase. Componentes que se comportan de manera idéntica pero se dan cuenta de que esta situación puede cambiar en el futuro. Si necesita utilizar la funcionalidad en otra clase pero no desea cambiar esa funcionalidad, utilice la delegación en lugar de la herencia. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 9. Acoplamiento Intención: Acoplamiento se refiere al grado en que una clase sabe acerca de otra clase. Si una clase usa otra clase, eso es acoplamiento. Esto incluye bajas dependencias entre “artefactos” (clases, módulos, componentes). No debe haber una dependencia demasiado grande entre los módulos; incluso si hay una dependencia, debería ser a través de las interfaces y debería ser mínima. Puntos clave: Al crear una aplicación compleja en Java, la lógica de una clase llamará a la lógica de otra clase para proporcionar el mismo servicio a los clientes. Si una clase está llamando a otra lógica de clase, entonces se llama colaboración. Cuando una clase está colaborando con otra clase, entonces existe un acoplamiento estrecho entre las dos clases. Si una clase quiere llamar a la lógica de una segunda clase, entonces la primera clase necesita un objeto de una segunda clase. Significa que la primera clase crea un objeto de una segunda clase. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 10. Cohesión Intención: El término cohesión se usa para indicar el grado en que una clase tiene una responsabilidad única y bien enfocada. La cohesión es una medida de cómo los métodos de una clase o un módulo están relacionados de manera significativa y significativa, y de cuán enfocados están en proporcionar un propósito bien definido al sistema. Explicación: En el diseño orientado a objetos, la cohesión se refiere a cómo se diseña una sola clase. La cohesión es el principio orientado a objetos que está más estrechamente asociado con asegurarse de que una clase esté diseñada con un propósito único y bien enfocado. Cuanto más enfocada está una clase, más cohesiva es esa clase. Las ventajas de la alta cohesión son que estas clases son mucho más fáciles de mantener (y cambian con menos frecuencia) que las clases con baja cohesión. Otro beneficio de la alta cohesión es que las clases con un propósito bien enfocado tienden a ser más reutilizables que otras clases."
    },

    {
        "id": 85,
        "autor": "Eduardo Ismael García Pérez",
        "pagina": "codigofacilito",
        "fecha": "27/01/2020",
        "titulo": "Diferencia Entre Clases Abstractas E Interfaces En Java",
        "link": "https://codigofacilito.com/articulos/clases-abstractas-interfaces-java",
        "contenido": "Hace un par de días en CódigoFacilito nos llegó una pregunta muy puntual acerca de Java, una pregunta que muy probablemente en algún momento te hayas hecho ¿Cúal es la diferencia entre una clases abstracta y una interfaz? 🤔 Al ser conceptos muy parecidos de programación orientada a objetos sin duda estos temas pueden ser difíciles de comprender y puede que a más de uno le haya causado uno que otro dolor de cabeza, 😲es por ello que en esta ocasión me gustaría que explicaremos en detalle qué es una clase abstracta, qué es una interfaz, en qué caso son buenos utilizarlos y por su puesto, cual es la diferencia entre uno y otro. Bien, una vez dicho todo esto comencemos. source: imgur.com CLASES ABSTRACTAS Comencemos hablando de clases abstractas. Habrá ocasiones en las cuales necesitemos crear una clase padre donde únicamente coloquemos la estructura de una abstracción, una estructura muy general, dejando que sean las clases hijas quienes definan los detalles. En estos casos haremos uso de las clases abstractas. Una clase abstracta es practicamente identica a una clase convencional; las clases abstractas pueden poseer atributos, métodos, constructores, etc ... La principal diferencia entre una clases convencional y una clase abstracta es que la clase abstracta debe poseer por lo menos un método abstracto. Ok, pero ahora, ¿ Qué es un método abstracto? Verás, un método abstracto no es más que un método vacío, un método el cual no posee cuerpo, por ende no puede realizar ninguna acción. La utilidad de un método abstracto es definir qué se debe hacer pero no el cómo se debe hacer. Veamos un ejemplo para que nos quede más en claro. public class Figura { private int numeroLados; public Figura() { this.numeroLados = 0; } public float area() { return 0f; } } En este caso la clase posee una atributo, un constructor y un método, a partir de esta clase podré generar la n cantidad de figuras que necesite, ya sean cuadrados, rectangulos, triangulos, circulos etc... Dentro de la clase encontramos el método área, método que se encuentra pensado para obtener el área de cualquier figura, sin embargo cómo sabemos todas las figuras poseen su propia fórmula matemática para calcular su área. Si yo comienzo a heredar de la clase Figura todas las clases hijas tendrían que sobre escribir el método área e implementar su propia formula para así poder calcular su área. En estos casos, en los casos la clase hija siempre deba que sobreescribir el método lo que podemos hacer es convertir al método convencional en un método abstracto, un método que defina qué hacer, pero no cómo se deba hacer. 😃 public abstract float area(); Ahora que el método área es un método abstracto la clase se convierte en una clase abstracta. public abstract class Figura { Es importante mencionar que las clases abstractas pueden ser heredadas por la n cantidad de clases que necesitemos, pero no pueden ser instanciadas. Para heredar de una clase abstracta basta con utilizar la palabra reservada extends. public class Triangulo extends Figura { Al nosotros heredar de una clase abstracta es obligatorio implementar todos sus métodos abstractos, es decir debemos definir comportamiento, definir cómo se va a realizar la tarea. INTERFACES Ahora hablaremos de interfaces. A pesar que es un tema un poco complejo si nosotros hemos comprendido el tema de clases abstractas y el por que de ellas, el tema de interfaces será un tema muy sencillo. Veamos. A diferencia de otros lenguajes de programación, en Java no es posible la herencia múltiple, nuestras clases únicamente podrán heredar de una y solo una clase. Si conceptualizamos esto una representación pudiese ser la siguiente. source: imgur.com El nivel de jerarquía es descendente. Esto sin duda funciona, sin embargo, si queremos representar conceptos de la vida real necesitaremos una jerarquía mucho más compleja, algo como esto. source: imgur.com Para que podamos diagramar nuestro proyecto de esta forma, teniendo en cuenta que únicamente es posible heredar de una clase, entonces haremos uso de interfaces. Podemos definir a una interfaz como una colección de métodos abstractos y propiedades constantes en las que se especifica que se debe de hacer pero no como, serán las clases hijas quienes definan el comportamiento. A diferencia de una clase abstracta, una interface no puede hacer nada por sí sola, es prácticamente un contrato, en donde las clases que la implementen deben, obligatoriamente, definir el comportamiento de todos los métodos abstractos, contestando a la pregunta ¿Cómo se debe hacer? Veamos un ejemplo de una interfaz. public interface Canino { public abstract void aullar(); public abstract void ladrar(); } Cómo podemos observar en la interfaz solo encontraremos métodos abstractos, método vacíos. Para poder implementar la interfaz basta con utilizar la palabra reservada implements. public class Perro implements Canino { Si bien es cierto que en versiones actuales de Java podemos encontrar los métodos default en las interfaces, métodos que nos permite definir comportamientos, en esencia las interfaces serán contratos que indicarán que es lo que se debe hacer sin proveer ninguna funcionalidad. Otra diferencia entre una clase abstracta y una interface recae en su implementación ya que una clase hija solo podrá heredar de una clase abstracta, por otro lado podrá hacer uso de la n cantidad de interfaces que necesite. public class Perro extends Canino implementes Mascota CONCLUSIÓN En conclusión un método abstracto no es más que un método vacío el cual resuelve la pregunta ¿Qué se debe hacer? pero no el ¿Cómo se deba hacer? ya que serán las clases hijas quienes definan el comportamiento. Los métodos abstractos podemos encontrarlos en dos entidades, las clases abstractas y las interfaces. Una clase abstracta no es más que una clase común la cual posee atributos, métodos, constructores y por lo menos un método abstracto. Una clase abstracta no puede ser instanciada, solo heredada. Cómo Java no permite la herencia múltiple habrá ocasiones en las cuales debamos utilizar interfaces, las cuales podemos verlas como contratos, contratos donde está muy bien establecido que debe hacer la clase que la implementa."
    },

    {
        "id": 86,
        "autor": "Alex Rodríguez",
        "pagina": "aprenderaprogramar",
        "fecha": "0/0/0",
        "titulo": "Clases y métodos abstractos en Java. Abstract class. Clases del api. Ejemplos código y ejercicios. ",
        "link": "https://www.aprenderaprogramar.com/index.php?option=com_content&view=article&id=668:clases-y-metodos-abstractos-en-java-abstract-class-clases-del-api-ejemplos-codigo-y-ejercicios-cu00695b&catid=68&Itemid=188",
        "contenido": "CLASES Y MÉTODOS ABSTRACTOS EN JAVA. Supongamos un esquema de herencia que consta de la clase Profesor de la que heredan ProfesorInterino y ProfesorTitular. Es posible que todo profesor haya de ser o bien ProfesorInterino o bien ProfesorTitular, es decir, que no vayan a existir instancias de la clase Profesor. Entonces, ¿qué sentido tendría tener una clase Profesor? El sentido está en que una superclase permite unificar campos y métodos de las subclases, evitando la repetición de código y unificando procesos. Ahora bien, una clase de la que no se tiene intención de crear objetos, sino que únicamente sirve para unificar datos u operaciones de subclases, puede declararse de forma especial en Java: como clase abstracta. La declaración de que una clase es abstracta se hace con la sintaxis public abstract class NombreDeLaClase { … }. Por ejemplo public abstract class Profesor. Cuando utilizamos esta sintaxis, no resulta posible instanciar la clase, es decir, no resulta posible crear objetos de ese tipo. Sin embargo, sigue funcionando como superclase de forma similar a como lo haría una superclase “normal”. La diferencia principal radica en que no se pueden crear objetos de esta clase. Declarar una clase abstracta es distinto a tener una clase de la que no se crean objetos. En una clase abstracta, no existe la posibilidad. En una clase normal, existe la posibilidad de crearlos aunque no lo hagamos. El hecho de que no creemos instancias de una clase no es suficiente para que Java considere que una clase es abstracta. Para lograr esto hemos de declarar explícitamente la clase como abstracta mediante la sintaxis que hemos indicado. Si una clase no se declara usando abstract se cataloga como “clase concreta”. En inglés abstract significa “resumen”, por eso en algunos textos en castellano a las clases abstractas se les llama resúmenes. Una clase abstracta para Java es una clase de la que nunca se van a crear instancias: simplemente va a servir como superclase a otras clases. No se puede usar la palabra clave new aplicada a clases abstractas. En el menú contextual de la clase en BlueJ simplemente no aparece, y si intentamos crear objetos en el código nos saltará un error. A su vez, las clases abstractas suelen contener métodos abstractos: la situación es la misma. Para que un método se considere abstracto ha de incluir en su signatura la palabra clave abstract. Además un método abstracto tiene estas peculiaridades: a) No tiene cuerpo (llaves): sólo consta de signatura con paréntesis. b) Su signatura termina con un punto y coma. c) Sólo puede existir dentro de una clase abstracta. De esta forma se evita que haya métodos que no se puedan ejecutar dentro de clases concretas. Visto de otra manera, si una clase incluye un método abstracto, forzosamente la clase será una clase abstracta. d) Los métodos abstractos forzosamente habrán de estar sobreescritos en las subclases. Si una subclase no implementa un método abstracto de la superclase tiene un método no ejecutable, lo que la fuerza a ser una subclase abstracta. Para que la subclase sea concreta habrá de implementar métodos sobreescritos para todos los métodos abstractos de sus superclases. Un método abstracto para Java es un método que nunca va a ser ejecutado porque no tiene cuerpo. Simplemente, un método abstracto referencia a otros métodos de las subclases. ¿Qué utilidad tiene un método abstracto? Podemos ver un método abstracto como una palanca que fuerza dos cosas: la primera, que no se puedan crear objetos de una clase. La segunda, que todas las subclases sobreescriban el método declarado como abstracto. Sintaxis tipo: abstract public/private/protected TipodeRetorno/void ( parámetros        …   ); Por ejemplo: abstract public void generarNomina (int diasCotizados, boolean plusAntiguedad); Que un método sea abstracto tiene otra implicación adicional: que podamos invocar el método abstracto sobre una variable de la superclase que apunta a un objeto de una subclase de modo que el método que se ejecute sea el correspondiente al tipo dinámico de la variable. En cierta manera, podríamos verlo como un método sobreescrito para que Java comprenda que debe buscar dinámicamente el método adecuado según la subclase a la que apunte la variable. ¿Es necesario que una clase que tiene uno o más métodos abstractos se defina como abstracta? Sí, si declaramos un método abstracto el compilador nos obliga a declarar la clase como abstracta porque si no lo hiciéramos así tendríamos un método de una clase concreta no ejecutable, y eso no es admitido por Java. ¿Una clase se puede declarar como abstracta y no contener métodos abstractos? Sí, una clase puede ser declarada como abstracta y no contener métodos abstractos. En algunos casos la clase abstracta simplemente sirve para efectuar operaciones comunes a subclases sin necesidad de métodos abstractos. En otros casos sí se usarán los métodos abstractos para referenciar operaciones en la clase abstracta al contenido de la sobreescritura en las subclases. ¿Una clase que hereda de una clase abstracta puede ser no abstracta? Sí, de hecho esta es una de las razones de ser de las clases abstractas. Una clase abstracta no puede ser instanciada, pero pueden crearse subclases concretas sobre la base de una clase abstracta, y crear instancias de estas subclases. Para ello hay que heredar de la clase abstracta y anular los métodos abstractos, es decir, implementarlos. Vamos a ver un ejemplo basado en el siguiente esquema: clase abstracta java En este diagrama de clases vemos cómo hemos definido una clase abstracta denominada Profesor. BlueJ la identifica señalando <<abstract>> en la parte superior del icono de la clase. Sin embargo, hereda de la clase Persona que no es abstracta, lo cual significa que puede haber instancias de Persona pero no de Profesor. El test que hemos diseñado se basa en lo siguiente: ProfesorTitular y ProfesorInterino son subclases de la clase abstracta Profesor. ListinProfesores sirve para crear un ArrayList de profesores que pueden ser tanto interinos como titulares y realizar operaciones con esos conjuntos. El listín se basa en el tipo estático Profesor, pero su contenido dinámico siempre será a base de instancias de ProfesorTitular o de ProfesorInterino ya que Profesor es una clase abstracta, no instanciable. En la clase de test creamos profesores interinos y profesores titulares y los vamos añadiendo a un listín. Posteriormente, invocamos el método imprimirListin, que se basa en los métodos toString de las subclases y de sus superclases mediante invocaciones sucesivas a super. Por otro lado, en la clase ListinProfesores hemos definido el método importeTotalNominaProfesorado() que se basa en un bucle que calcula la nómina de todos los profesores que haya en el listín (sean interinos o titulares) mediante el uso de un método abstracto: importeNomina(). Este método está definido como abstract public float importeNomina (); dentro de la clase abstracta profesor, e implementado en las clases ProfesorInterino y ProfesorTitular. El aspecto central de este ejemplo es comprobar cómo una clase abstracta como Profesor nos permite realizar operaciones conjuntas sobre varias clases, ahorrando código y ganando en claridad para nuestros programas. Escribe este código: public class Persona { //Código de la clase Persona ejemplo aprenderaprogramar.com private String nombre; private String apellidos; private int edad; public Persona() { nombre =   ; apellidos =   ; edad = 0; } public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad; } public String getNombre() { return nombre;  } public String getApellidos() { return apellidos;  } public int getEdad() { return edad;  } public String toString() {   Integer datoEdad = edad; return  -Nombre:  .concat(nombre).concat(  -Apellidos:  ).concat(apellidos).concat(  -Edad:  ).concat(datoEdad.toString() ); } } //Cierre de la clase En la clase Persona transformamos edad en un Integer para poder aplicarle el método toString(). De otra manera no podemos hacerlo por ser edad un tipo primitivo. Escribe este código: public abstract class Profesor extends Persona { // Campo de la clase ejemplo aprenderaprogramar.com private String IdProfesor; // Constructores public Profesor () { super();         IdProfesor =  Unknown ;   } public Profesor (String nombre, String apellidos, int edad, String id) { super(nombre, apellidos, edad);   IdProfesor = id; } // Métodos public void setIdProfesor (String IdProfesor) { this.IdProfesor = IdProfesor;   } public String getIdProfesor () { return IdProfesor;   } public void mostrarDatos() { System.out.println ( Datos Profesor. Profesor de nombre:   + getNombre() +     + getApellidos() +   con Id de profesor:   + getIdProfesor() );   } public String toString () { return super.toString().concat(  -IdProfesor:  ).concat(IdProfesor); } abstract public float importeNomina ();  // Método abstracto } //Cierre de la clase Hemos declarado la clase Profesor como abstracta. De hecho, tenemos un método abstracto (definido como abstract y sin cuerpo), lo cual de facto nos obliga a declarar la clase como abstracta. El método sobreescrito toString llama al método toString de la superclase y lo concatena con nuevas cadenas. Como clases que heredan de Profesor tenemos a ProfesorTitular y ProfesorInterino: public class ProfesorTitular extends Profesor { // Constructor ejemplo aprenderaprogramar.com public ProfesorTitular(String nombre, String apellidos, int edad, String id) { super(nombre, apellidos, edad, id); } public float importeNomina () { return 30f * 43.20f; }  //Método abstracto sobreescrito en esta clase } //Cierre de la clase import java.util.Calendar; public class ProfesorInterino extends Profesor { // Campo de la clase ejemplo aprenderaprogramar.com private Calendar fechaComienzoInterinidad; // Constructores public ProfesorInterino (Calendar fechaInicioInterinidad) { super();      fechaComienzoInterinidad = fechaInicioInterinidad; } public ProfesorInterino (String nombre, String apellidos, int edad, String id, Calendar fechaInicioInterinidad) { super(nombre, apellidos, edad, id); fechaComienzoInterinidad = fechaInicioInterinidad; } public Calendar getFechaComienzoInterinidad () { return fechaComienzoInterinidad; } //Método public String toString () { // Sobreescritura del método return super.toString().concat (  Fecha comienzo interinidad:  ).concat (fechaComienzoInterinidad.getTime().toString()); } public float importeNomina () { return 30f * 35.60f ; } //Método abstracto sobreescrito en esta clase } //Cierre de la clase import java.util.ArrayList; import java.util.Iterator; public class ListinProfesores { private ArrayList <Profesor> listinProfesores; //Campo de la clase public ListinProfesores () {  listinProfesores = new ArrayList <Profesor> ();  } //Constructor public void addProfesor (Profesor profesor) {  listinProfesores.add(profesor);  } //Método public void imprimirListin() {  //Método String tmpStr1 =   ; //String temporal que usamos como auxiliar System.out.println ( Se procede a mostrar los datos de los profesores existentes en el listín \n ); for (Profesor tmp: listinProfesores) {          System.out.println (tmp.toString () ); if (tmp instanceof ProfesorInterino) { tmpStr1 =  Interino ;} else { tmpStr1 =  Titular ; } System.out.println( -Tipo de este profesor: +tmpStr1+  -Nómina de este profesor:  +(tmp.importeNomina())+  \n );} } //Cierre método imprimirListin public float importeTotalNominaProfesorado() { float importeTotal = 0f; //Variable temporal que usamos como auxiliar Iterator<Profesor> it = listinProfesores.iterator(); while (it.hasNext() ) { importeTotal = importeTotal + it.next().importeNomina(); } return importeTotal; } //Cierre del método importeTotalNominaProfesorado } //Cierre de la clase ejemplo aprenderaprogramar.com ProfesorTitular y ProfesorInterino se han definido como clases concretas que heredan de la clase abstracta Profesor. Ambas clases redefinen (obligatoriamente han de hacerlo) el método abstracto importeNomina() de la superclase. El método sobreescrito toString() de la clase ProfesorInterino llama al método toString() de la superclase y lo concatena con nuevas cadenas. El cálculo de importeNomina en ambas clases es una trivialidad: hemos incluido un cálculo sin mayor interés excepto que el de ver el funcionamiento de la implementación de métodos abstractos. ProfesorTitular lo hemos dejado con escaso contenido porque aquí lo usamos solo a modo de ejemplo de uso de clases abstractas y herencia. Su único cometido es mostrar que existe otra subclase de Profesor. Por otro lado, en la clase ListinProfesores tenemos un ejemplo de uso de instanceof para determinar qué tipo (ProfesorInterino o ProfesorTitular) es el que porta una variable Profesor. Iteramos con clase declarada Profesor y clases dinámicas ProfesorTitular y ProfesorInterino. Dinámicamente se determina de qué tipo es cada objeto y al invocar el método abstracto importeNomina() Java determina si debe utilizar el método propio de un subtipo u otro. En imprimirListin llegamos incluso a mostrar por pantalla de qué tipo es cada objeto usando la sentencia instanceof para determinarlo. Escribe y ejecuta el código del test: import java.util.Calendar; //Ejemplo aprenderaprogramar.com public class TestAbstract { public static void main (String [ ] Args) { Calendar fecha1 = Calendar.getInstance(); fecha1.set(2019,10,22); //Los meses van de 0 a 11, luego 10 representa noviembre ProfesorInterino pi1 = new ProfesorInterino( José ,  Hernández López , 45,  45221887-K , fecha1); ProfesorInterino pi2 = new ProfesorInterino( Andrés ,  Moltó Parra , 87,  72332634-L , fecha1); ProfesorInterino pi3 = new ProfesorInterino ( José ,  Ríos Mesa , 76,  34998128-M , fecha1); ProfesorTitular pt1 = new ProfesorTitular ( Juan ,  Pérez Pérez , 23,  73-K ); ProfesorTitular pt2 = new ProfesorTitular ( Alberto ,  Centa Mota , 49,  88-L ); ProfesorTitular pt3 = new ProfesorTitular ( Alberto ,  Centa Mota , 49,  81-F ); ListinProfesores listinProfesorado = new ListinProfesores (); listinProfesorado.addProfesor (pi1); listinProfesorado.addProfesor(pi2); listinProfesorado.addProfesor (pi3); listinProfesorado.addProfesor (pt1); listinProfesorado.addProfesor(pt2); listinProfesorado.addProfesor (pt3); listinProfesorado.imprimirListin(); System.out.println ( El importe de las nóminas del profesorado que consta en el listín es   + listinProfesorado.importeTotalNominaProfesorado()+   euros ); }  }   //Cierre del main y cierre de la clase Comprueba el resultado de ejecución. El resultado del test nos muestra que operamos exitosamente sobre las dos clases usando abstracción: Se procede a mostrar los datos de los profesores existentes en el listín -Nombre: José -Apellidos: Hdez López -Edad: 45 -IdProfesor: 45221887-K Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -Nómina de este profesor: 1068.0 -Nombre: Andrés -Apellidos: Mltó Parra -Edad: 87 -IdProfesor: 72332634-L Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -Nómina de este profesor: 1068.0 -Nombre: José -Apellidos: Ríos Mesa -Edad: 76 -IdProfesor: 34998128-M Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -Nómina de este profesor: 1068.0 -Nombre: Juan -Apellidos: Pérez Pérez -Edad: 23 -IdProfesor: 73-K -Tipo de este profesor: Titular -Nómina de este profesor: 1296.0 -Nombre: Alberto -Apellidos: Centa Mota -Edad: 49 -IdProfesor: 88-L -Tipo de este profesor: Titular -Nómina de este profesor: 1296.0 -Nombre: Alberto -Apellidos: Centa Mota -Edad: 49 -IdProfesor: 81-F -Tipo de este profesor: Titular -Nómina de este profesor: 1296.0 El importe de las nóminas del profesorado que consta en el listín es 7092.0 euros CLASES ABSTRACTAS EN EL API DE JAVA Java utiliza clases abstractas en el API de la misma forma que podemos nosotros usarlas en nuestros programas. Por ejemplo, la clase AbstractList del paquete java.util es una clase abstracta con tres subclases: clases abstractas api java Como vemos, entre las subclases dos de ellas son concretas mientras que una todavía es abstracta. En una clase como AbstractList algunos métodos son abstractos, lo que obliga a que el método esté sobreescrito en las subclases, mientras que otros métodos no son abstractos. Sobre un objeto de una subclase, llamar a un método puede dar lugar a: a) La ejecución del método tal y como esté definido en la subclase. b) La búsqueda del método ascendiendo por las superclases hasta que se encuentra y puede ser ejecutado. Es lo que ocurrirá por ejemplo con toString() si no está definido en la subclase."
    },

    {
        "id": 87,
        "autor": "arkaitzgarro",
        "pagina": "arkaitzgarro",
        "fecha": "0/0/0",
        "titulo": "CAPÍTULO 18 INTERFACES",
        "link": "https://www.arkaitzgarro.com/java/capitulo-18.html",
        "contenido": "Una interfaz es una especie de plantilla para la construcción de clases. Normalmente una interfaz se compone de un conjunto de declaraciones de cabeceras de métodos (sin implementar, de forma similar a un método abstracto) que especifican un protocolo de comportamiento para una o varias clases. Además, una clase puede implementar una o varias interfaces: en ese caso, la clase debe proporcionar la declaración y definición de todos los métodos de cada una de las interfaces o bien declararse como clase abstract. Por otro lado, una interfaz puede emplearse también para declarar constantes que luego puedan ser utilizadas por otras clases. Una interfaz puede parecer similar a una clase abstracta, pero existen una serie de diferencias entre una interfaz y una clase abstracta: Todos los métodos de una interfaz se declaran implícitamente como abstractos y públicos. Una clase abstracta no puede implementar los métodos declarados como abstractos, una interfaz no puede implementar ningún método (ya que todos son abstractos). Una interfaz no declara variables de instancia. Una clase puede implementar varias interfaces, pero sólo puede tener una clase ascendiente directa. Una clase abstracta pertenece a una jerarquía de clases mientras que una interfaz no pertenece a una jerarquía de clases. En consecuencia, clases sin relación de herencia pueden implementar la misma interfaz. 18.1 DECLARACIÓN DE UNA INTERFAZ La declaración de una interfaz es similar a una clase, aunque emplea la palabra reservada interface en lugar de class y no incluye ni la declaración de variables de instancia ni la implementación del cuerpo de los métodos (sólo las cabeceras). La sintaxis de declaración de una interfaz es la siguiente: public interface IdentificadorInterfaz { // Cuerpo de la interfaz ... } Una interfaz declarada como public debe ser definida en un archivo con el mismo nombre de la interfaz y con extensión .java. Las cabeceras de los métodos declarados en el cuerpo de la interfaz se separan entre sí por caracteres de punto y coma y todos son declarados implícitamente como public y abstract (se pueden omitir). Por su parte, todas las constantes incluidas en una interfaz se declaran implícitamente como public, static y final (también se pueden omitir) y es necesario inicializarlas en la misma sentencia de declaración. Por ejemplo, la interfaz Modificacion declara la cabecera de un único método: /** * Declaracion de la interfaz Modificacion */ public interface Modificacion { void incremento(int a); } que se almacena en el archivo fuente Modificacion.java y que, al compilarse: $>javac Modificacion.java genera un archivo Modificacion.class. Al no corresponder a una clase que implementa un método main, este archivo no puede ejecutarse con el intérprete de Java. Segundo ejemplo: la interfaz constantes declara dos constantes reales con el siguiente código fuente: /** * Declaracion de la interfaz Constantes */ public interface Constantes { double VALOR_MAXIMO = 10000000.0; double VALOR_MINIMO = -0.01; } que se almacena en el archivo fuente Constantes.java y que, al compilarse, genera un archivo Constantes.class Tercer ejemplo: la interfaz Numerico declara una constante real y dos cabeceras de métodos con el siguiente código fuente: /** * Declaracion de la interfaz Numerico */ public interface Numerico { double EPSILON = 0.000001; void establecePrecision(float p); void estableceMaximo(float m); } que se almacena en el archivo fuente Numerico.java y que, al compilarse, genera un archivo Numerico.class. 18.2 IMPLEMENTACIÓN DE UNA INTERFAZ EN UNA CLASE Para declarar una clase que implemente una interfaz es necesario utilizar la palabra reservada implements en la cabecera de declaración de la clase. Las cabeceras de los métodos (identificador y número y tipo de parámetros) deben aparecer en la clase tal y como aparecen en la interfaz implementada. Por ejemplo, la clase Acumulador implementa la interfaz Modificacion y por lo tanto debe declarar un método incremento: /** * Declaracion de la clase Acumulador */ public class Acumulador implements Modificacion { private int valor; public Acumulador (int i) { this.valor = i; } public int daValor () { return this.valor; } public void incremento (int a) { this.valor += a; } } Esta cabecera con la palabra implements... implica la obligación de la clase Acumulador de definir el método incremento declarado en la interfaz Modificacion. El siguiente código muestra un ejemplo de uso de la clase Acumulador. /** * Demostracion de la clase Acumulador */ public class PruebaAcumulador { public static void main (String [] args) { Acumulador p = new Acumulador(25); p.incremento(12); System.out.println(p.daValor()); } } La compilación y posterior ejecución del código anterior origina la siguiente salida por pantalla: $>javac PruebaAcumulador.java $>java PruebaAcumulador 37 La clase Acumulador tendría también la posibilidad de utilizar directamente las constantes declaradas en la interfaz si las hubiera. Para poder emplear una constante declarada en una interfaz, las clases que no implementen esa interfaz deben anteponer el identificador de la interfaz al de la constante. 18.3 JERARQUÍA ENTRE INTERFACES La jerarquía entre interfaces permite la herencia simple y múltiple. Es decir, tanto la declaración de una clase, como la de una interfaz pueden incluir la implementación de otras interfaces. Los identificadores de las interfaces se separan por comas. Por ejemplo, la interfaz Una implementa otras dos interfaces: Dos y Tres. public interface Una implements Dos, Tres { // Cuerpo de la interfaz ... } Las clases que implementan la interfaz Una también lo hacen con Dos y Tres. Otro ejemplo: pueden construirse dos interfaces, Constantes y Variaciones, y una clase, Factura, que las implementa: // Declaracion de la interfaz Constantes public interface Constantes { double valorMaximo = 10000000.0; double valorMinimo = -0.01; } // Declaracion de la interfaz Variaciones public interface Variaciones { void asignaValor(double x); void rebaja(double t); } // Declaracion de la clase Factura public class Factura implements Constantes, Variaciones { private double totalSinIVA; public final static double IVA = 0.16; public double sinIVA() { return this.totalSinIVA; } public double conIVA() { return this.totalSinIVA * (1+IVA); } public void asignaValor(double x) { if (this.valorMinimo<x) this.totalSinIVA=x; else this.totalSinIVA=0; } public void rebaja(double t) { this.totalSinIVA *= (1-t/100); } public static void main (String [] args) { factura a = new Factura(); a.asignaValor(250.0); System.out.println( El precio sin IVA es:   + a.sinIVA()); System.out.println( El precio con IVA es:   + a.conIVA()); System.out.println( Rebajado durante el mes de mayo un 20% ); a.rebaja(20); System.out.println( Rebajado sin IVA es:   + a.sinIVA()); System.out.println( Rebajado con IVA es:   + a.conIVA()); } } Si una interfaz implementa otra, incluye todas sus constantes y declaraciones de métodos, aunque puede redefinir tanto constantes como métodos. Importante: Es peligroso modificar una interfaz ya que las clases dependientes dejan de funcionar hasta que éstas implementen los nuevos métodos. Una clase puede simultáneamente descender de otra clase e implementar una o varias interfaces. En este caso la seccion implements se coloca a continuación de extends en la cabecera de declaración de la clase. Por ejemplo: public class ClaseDescendiente extends ClaseAscendiente implements Interfaz { ... } 18.4 UTILIZACIÓN DE UNA INTERFAZ COMO UN TIPO DE DATO Al declarar una interfaz, se declara un nuevo tipo de referencia. Pueden emplearse identificadores de interfaz en cualquier lugar donde se pueda utilizar el identificador de un tipo de dato (o de una clase). El objetivo es garantizar la sustituibilidad por cualquier instancia de una clase que la implemente. Por ejemplo, puede emplearse como tipo de un parámetro de un método: public class Calculos { public void asignacion(Variaciones x); { ... } } Sólo una instancia de una clase que implemente la interfaz puede asignarse al parámetro cuyo tipo corresponde al identificador de la interfaz. Esta facultad se puede aprovechar dentro la propia interfaz. Por ejemplo: public interface Comparable { // La instancia que llama a esMayor (this) y el parametro otra // deben ser de la misma clase o de clases que implementen esta interfaz // La funcion devuelve 1, 0, -1 si this es mayor, igual o menor que otra public int esMayor(Comparable otra); } En algún caso puede ser útil declarar una interfaz vacía como, por ejemplo: public interface Marcador { } Esta declaración es totalmente válida ya que no es obligatorio incluir dentro de una interfaz la declaración de una constante o la cabecera de un método. La utilidad de estas interfaces reside en la posibilidad de ser empleadas como tipos de dato para especificar clases sin necesidad de obligar a éstas a implementar algún método en concreto. Una interfaz no es una clase pero se considera un tipo en Java y puede ser utilizado como tal."
    },

    {
        "id": 88,
        "autor": "Alex Walton ",
        "pagina": "javadesdecero",
        "fecha": "7/05/2020",
        "titulo": "Interfaces en Java con Ejemplos",
        "link": "https://javadesdecero.es/intermedio/interfaces-ejemplos/",
        "contenido": "En la programación orientada a objetos, a veces es útil definir qué debe hacer una clase, pero no cómo lo hará. Ya has visto un ejemplo de esto: el método abstract. Un método abstracto define la firma de un método pero no proporciona ninguna implementación. Una subclase debe proporcionar su propia implementación de cada método abstracto definido por su superclase. Por lo tanto, un método abstracto especifica la interfaz para el método pero no la implementación. Si bien las clases y métodos abstractos son útiles, es posible llevar este concepto un paso más allá. En Java, puede separar por completo la interfaz de una clase de su implementación utilizando la palabra clave . Table de Contenido 1. Qué es una interface en Java 2. interface en el nuevo JDK 3. Implementación de interfaces 4. Uso de referencias a interface 5. Variables en interfaces 6. Las interfaces pueden ser extendidas 1. Qué es una interface en Java Una interfaz () es sintácticamente similar a una clase abstracta, en la que puede especificar uno o más métodos que no tienen cuerpo ({}). Esos métodos deben ser implementados por una clase para que se definan sus acciones. Por lo tanto, una interfaz especifica qué se debe hacer, pero no cómo hacerlo. Una vez que se define una interfaz, cualquier cantidad de clases puede implementarla. Además, una clase puede implementar cualquier cantidad de interfaces. Para implementar una interfaz, una clase debe proporcionar cuerpos (implementaciones) para los métodos descritos por la interfaz. Cada clase es libre de determinar los detalles de su propia implementación. Dos clases pueden implementar la misma interfaz de diferentes maneras, pero cada clase aún admite el mismo conjunto de métodos. Por lo tanto, el código que tiene conocimiento de la interfaz puede usar objetos de cualquier clase, ya que la interfaz con esos objetos es la misma. ×Al proporcionar la palabra clave interface, Java le permite utilizar completamente el aspecto de “una interfaz, múltiples métodos” del polimorfismo. 2. interface en el nuevo JDK Antes de continuar, se necesita hacer un punto importante. JDK 8 agregó una función a interface que hizo un cambio significativo en sus capacidades. Antes de JDK 8, una interfaz no podía definir ninguna implementación de ningún tipo. Por lo tanto, antes de JDK 8, una interfaz podría definir solo el qué, pero no el cómo, como se acaba de describir. JDK 8 cambió esto. Hoy, es posible agregar una implementación predeterminada a un método de interfaz. Además, ahora se admiten los métodos de interfaz estática y, a partir de JDK 9, una interfaz también puede incluir métodos privados. Por lo tanto, ahora es posible que la interfaz especifique algún comportamiento. Sin embargo, tales métodos constituyen lo que son, en esencia, características de uso especial, y la intención original detrás de la interfaz aún permanece. Por lo tanto, como regla general, con frecuencia creará y utilizará interfaces en las que no se utilizarán estas nuevas funciones. Por esta razón, comenzaremos discutiendo la interfaz en su forma tradicional. Las nuevas funciones de la interfaz se describen más adelante. Aquí hay una forma general simplificada de una interfaz tradicional: acceso interface nombre { tipo-retorno metodo-nombre1(lista-parametros); tipo-retorno metodo-nombre2(lista-parametros); tipo var1 = valor; tipo var2 = valor; // ... tipo-retorno metodo-nombreN(lista-parametros); tipo varN = valor; } Para una interfaz de nivel superior, acceso es public o no se usa. Cuando no se incluye ningún modificador de acceso, los resultados de acceso predeterminados y la interfaz solo están disponibles para otros miembros de su paquete. Si se declara como public, la interfaz puede ser utilizada por cualquier otro código. (Cuando una interfaz se declara public,, debe estar en un archivo del mismo nombre.) nombre es el nombre de la interfaz y puede ser cualquier identificador válido. En la forma tradicional de una interfaz, los métodos se declaran utilizando solo su tipo de devolución y firma. Son, esencialmente, métodos abstractos. Por lo tanto, cada clase que incluye dicha interfaz debe implementar todos sus métodos. En una interfaz, los métodos son implícitamente públicos. Las variables declaradas en una interfaz no son variables de instancia. En cambio, son implícitamente public, final, y static, y deben inicializarse. Por lo tanto, son esencialmente constantes. Aquí hay un ejemplo de una definición de interfaz. Especifica la interfaz a una clase que genera una serie de números. public interface Series { int getSiguiente(); //Retorna el siguiente número de la serie void reiniciar(); //Reinicia void setComenzar(int x); //Establece un valor inicial } Esta interfaz se declara pública para que pueda ser implementada por código en cualquier paquete. 3. Implementación de interfaces Una vez que se ha definido una interfaz, una o más clases pueden implementar esa interfaz. Para implementar una interfaz, incluya la cláusula  en una definición de clase y luego cree los métodos requeridos por la interfaz. La forma general de una clase que incluye la cláusula de implements se ve así: class nombreclase extends superclase implements interface { // cuerpo-clase } Para implementar más de una interfaz, las interfaces se separan con una coma. ×Por supuesto, la cláusula extends es opcional. Los métodos que implementan una interfaz deben declararse públicos. Además, la firma de tipo del método de implementación debe coincidir exactamente con la firma de tipo especificada en la definición de la interfaz. Aquí hay un ejemplo que implementa la interfaz de Series mostrada anteriormente. Crea una clase llamada DeDos, que genera una serie de números, cada uno mayor que el anterior. class DeDos implements Series { int iniciar; int valor; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=2; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } Observe que los métodos getSiguiente(), reiniciar() y setComenzar() se declaran utilizando el especificador de acceso público (). Esto es necesario. Siempre que implemente un método definido por una interfaz, debe implementarse como público porque todos los miembros de una interfaz son implícitamente públicos. Aquí hay una clase que demuestra DeDos: class SeriesDemo { public static void main(String[] args) { DeDos ob=new DeDos(); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); System.out.println( \nReiniciando ); ob.reiniciar(); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); System.out.println( \nIniciando en 100 ); ob.setComenzar(100); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); } } Salida: Siguiente valor es: 2 Siguiente valor es: 4 Siguiente valor es: 6 Siguiente valor es: 8 Siguiente valor es: 10 Reiniciando Siguiente valor es: 2 Siguiente valor es: 4 Siguiente valor es: 6 Siguiente valor es: 8 Siguiente valor es: 10 Iniciando en 100 Siguiente valor es: 102 Siguiente valor es: 104 Siguiente valor es: 106 Siguiente valor es: 108 Siguiente valor es: 110 Es permitido y común para las clases que implementan interfaces definir miembros adicionales propios. Por ejemplo, la siguiente versión de DeDos agrega el método getAnterior(), que devuelve el valor anterior: class DeDos implements Series { int iniciar; int valor; int anterior; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { anterior=valor; valor+=2; return valor; } public void reiniciar() { valor=iniciar; anterior=valor-2; } public void setComenzar(int x) { iniciar=x; valor=x; anterior=x-2; } //Añadiendo un método que no está definido en Series int getAnterior(){ return anterior; } } Observe que la adición de getAnterior() requirió un cambio en las implementaciones de los métodos definidos por Series. Sin embargo, dado que la interfaz con esos métodos permanece igual, el cambio es continuo y no rompe el código preexistente. Esta es una de las ventajas de las interfaces. Como se explicó, cualquier cantidad de clases puede implementar una interfaz. Por ejemplo, aquí hay una clase llamada DeTres que genera una serie que consta de múltiplos de tres: public class DeTres implements Series{ int iniciar; int valor; DeTres(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=3; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } Un punto más: si una clase incluye una interfaz pero no implementa completamente los métodos definidos por esa interfaz, esa clase debe declararse como abstracta (). No se pueden crear objetos de dicha clase, pero se puede usar como una superclase abstracta, lo que permite que las subclases proporcionen la implementación completa. 4. Uso de referencias a interface Es posible que se sorprenda al descubrir que puede declarar una variable de referencia de un tipo de interfaz. En otras palabras, puede crear una variable de referencia de interfaz. Dicha variable puede referirse a cualquier objeto que implemente su interfaz. Cuando llama a un método en un objeto a través de una referencia de interfaz, es la versión del método implementado por el objeto que se ejecuta. Este proceso es similar al uso de una referencia de superclase para acceder a un objeto de subclase. El siguiente ejemplo ilustra este proceso. Utiliza la misma variable de referencia de interfaz para llamar a métodos en objetos de DeDos y DeTres. //Demostración de referencia de interface class DeDos implements Series { int iniciar; int valor; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=2; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } public class DeTres implements Series{ int iniciar; int valor; DeTres(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=3; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } class SeriesDemo { public static void main(String[] args) { DeDos dosOb=new DeDos(); DeTres tresOb=new DeTres(); Series ob; for (int i=0;i<5;i++) { ob = dosOb; System.out.println( Siguiente valor DeDos es:   + ob.getSiguiente()); ob = tresOb; System.out.println( Siguiente valor DeTres es:   + ob.getSiguiente()); } } } Salida: Siguiente valor DeDos es: 2 Siguiente valor DeTres es: 3 Siguiente valor DeDos es: 4 Siguiente valor DeTres es: 6 [...] En main(), ob se declara como una referencia a una interfaz de Series. Esto significa que se puede usar para almacenar referencias a cualquier objeto que implemente Series. En este caso, se utiliza para referirse a dosOb y tresOb, que son objetos de tipo DeDos y DeTres, respectivamente, que implementan Series. Una variable de referencia de interfaz solo tiene conocimiento de los métodos declarados por su declaración de interfaz. Por lo tanto, ob no se podría usar para acceder a otras variables o métodos que puedan ser compatibles con el objeto. 5. Variables en interfaces Como se mencionó, las variables se pueden declarar en una interfaz, pero son implícitamente públicas, estáticas y finales (public, static, y final). A primera vista, podría pensar que habría un uso muy limitado para tales variables, pero ocurre lo contrario. Los programas grandes normalmente hacen uso de varios valores constantes que describen cosas como el tamaño de la matriz, diversos límites, valores especiales y similares. Dado que un programa grande generalmente se mantiene en una cantidad de archivos fuente separados, debe haber una forma conveniente de hacer que estas constantes estén disponibles para cada archivo. En Java, las variables de interfaz ofrecen una solución. Para definir un conjunto de constantes compartidas, cree una interfaz que contenga solo estas constantes, sin ningún método. Cada archivo que necesita acceso a las constantes simplemente “implementa” la interfaz. Esto trae las constantes a la vista. Aquí hay un ejemplo: //Una interfaz que contiene constantes interface Constante { //Definiendo 3 constantes int MIN=0; int MAX=10; String MSJERROR= LIMITE ERROR ; } class ConstanteD implements Constante{ public static void main(String[] args) { int numeros[]=new int; for (int i=MIN; i<11; i++){ if (i>=MAX) System.out.println(MSJERROR); else { numeros=i; System.out.println(numeros+    ); } } } } La técnica de usar una interfaz para definir constantes compartidas es controvertida. Veremos más ejemplos más adelante. 6. Las interfaces pueden ser extendidas Una interfaz puede heredar otra mediante el uso de la palabra clave extends. La sintaxis es la misma que para heredar clases. Cuando una clase implementa una interfaz que hereda otra interfaz, debe proporcionar implementaciones para todos los métodos requeridos por la cadena de herencia de la interfaz. Lo siguiente es un ejemplo: //Una interface puede extender de otra interface A{ void metodo1(); void metodo2(); } //B ahora incluye metodo1() y metodo2() - y añade metodo3() interface B extends A{ void metodo3(); } //Esta clase debe implementar los métodos de A y B class MiClase implements B{ public void metodo1() { System.out.println( Implementación de metodo1(). ); } public void metodo2() { System.out.println( Implementación de metodo2(). ); } public void metodo3() { System.out.println( Implementación de metodo3(). ); } } public class Extender { public static void main(String[] args) { MiClase mc=new MiClase(); mc.metodo1(); mc.metodo2(); mc.metodo3(); } } Salida: Implementación de metodo1(). Implementación de metodo2(). Implementación de metodo3(). Como experimento, puede intentar eliminar la implementación de metodo1() en MiClase. Esto causará un error en tiempo de compilación. Como se dijo anteriormente, cualquier clase que implemente una interfaz debe implementar todos los métodos requeridos por esa interfaz, incluidos los heredados de otras interfaces."
    },

    {
        "id": 89,
        "autor": "Ricardo Moya",
        "pagina": "jarroba",
        "fecha": "8/04/2014",
        "titulo": "Herencia en Java, con ejemplos",
        "link": "https://jarroba.com/herencia-en-la-programacion-orientada-a-objetos-ejemplo-en-java/",
        "contenido": "La Herencia es uno de los 4 pilares de la programación orientada a objetos (POO) junto con la Abstracción, Encapsulación y Polimorfismo. Al principio cuesta un poco entender estos conceptos característicos del paradigma de la POO porque solemos venir de otro paradigma de programación como el paradigma de la programación estructurada (ver la entrada Paradigmas de Programación), pero se ha de decir que la complejidad está en entender este nuevo paradigma y no en otra cosa. En esta entrada vamos a explicar de la mejor manera posible que es la herencia y lo vamos a explicar con un ejemplo. Respecto a la herencia se han dado muchas definiciones como por ejemplo la siguiente:  La herencia es un mecanismo que permite la definición de una clase a partir de la definición de otra ya existente. La herencia permite compartir automáticamente métodos y datos entre clases, subclases y objetos. . Así de primeras esta definición es un poco difícil de digerir para aquellos que estéis empezando con la POO, así que vamos a intentar digerir esta definición con un ejemplo en el que veremos que la herencia no es más que un  Copy-Paste Dinámico  o una forma de  sacar factor común  al código que escribimos. El ejemplo que proponemos es un caso en el que vamos a simular el comportamiento que tendrían los diferentes integrantes de la selección española de futbol; tanto los Futbolistas como el cuerpo técnico (Entrenadores, Masajistas, etc…). Para simular este comportamiento vamos a definir tres clases que van a representaran a objetos Futbolista, Entrenador y Masajista. De cada unos de ellos vamos a necesitar algunos datos que reflejaremos en los atributos y una serie de acciones que reflejaremos en sus métodos. Estos atributos y métodos los mostramos en el siguiente diagrama de clases: NoHerencia_jarroba NOTA: en este diagrama y en adelante no vamos a poner los constructores y métodos getter y setter con el fin de que el diagrama nos quede grande e  intendible  aunque en un buen diagrama de clases deberían aparecer para respetar el principio de encapsulación de la POO Como se puede observar, vemos que en las tres clases tenemos atributos y métodos que son iguales ya que los tres tienen los atributos id, Nombre, Apellidos y Edad; y los tres tienen los métodos de Viajar y Concentrarse: Herencia_jarroba A nivel de código tenemos lo siguiente tras ver el diagrama de clases: public class Futbolista { private int id; private String Nombre; private String Apellidos; private int Edad; private int dorsal; private String demarcacion; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void jugarPartido() { ... } public void entrenar() { ... } } public class Entrenador { private int id; private String Nombre; private String Apellidos; private int Edad; private String idFederacion; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void dirigirPartido() { ... } public void dirigirEntreno() { ... } } public class Masajista { private int id; private String Nombre; private String Apellidos; private int Edad; private String Titulacion; private int aniosExperiencia; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void darMasaje() { ... } } Lo que podemos ver en este punto es que estamos escribiendo mucho código repetido ya que las tres clases tienen métodos y atributos comunes, de ahi y como veremos enseguida, decimos que la herencia consiste en  sacar factor común  para no escribir código de más, por tanto lo que haremos sera crearnos una clase con el  código que es común a las tres clases  (a esta clase se le denomina en la herencia como  Clase Padre o SuperClase ) y el código que es  especifico de cada clase, lo dejaremos en ella, siendo denominadas estas clases como  Clases Hijas , las cuales heredan de la clase padre todos los atributos y métodos públicos o protegidos. Es muy importante decir que las clases hijas no van a heredar nunca los atributos y métodos privados de la clase padre, así que mucho cuidado con esto. En resumen para que veáis la ventaja de la herencia, tenemos ahora una clase padre con 'n' lineas de código y tres clases hijas con 'a', 'b' y 'c' lineas de códigos respectivamente, por tanto si hecháis cuentas, hemos reducido nuestro código en '2n' líneas menos ya que antes teníamos '(n+a)+(n+b)+(n+c)' líneas de código y ahora tras aplicar herencia tenemos 'n+a+b+c' líneas, aunque también es cierto que tenemos una clase más, pero veremos un poco más adelante la ventaja de tener esa clase padre. En resumen, al  sacar factor común  y aplicar herencia, tenemos las siguientes clases: HerenciaV2_jarroba A nivel de código, las clases quedarían implementadas de la siguiente forma: public class SeleccionFutbol { protected int id; protected String Nombre; protected String Apellidos; protected int Edad; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } } public class Futbolista extends SeleccionFutbol { private int dorsal; private String demarcacion; public Futbolista() { super(); } // getter y setter public void jugarPartido() { ... } public void entrenar() { ... } } public class Entrenador extends SeleccionFutbol { private String idFederacion; public Entrenador() { super(); } // getter y setter public void dirigirPartido() { ... } public void dirigirEntreno() { ... } } public class Masajista extends SeleccionFutbol { private String Titulacion; private int aniosExperiencia; public Masajista() { super(); } // getter y setter public void darMasaje() { ... } } Como podéis observar ahora queda un código mucho más limpio, estructurado y con menos líneas de código, lo que lo hace más legible, cosa que es muy importante y lo que todavía lo hace más importante es que es un código reutilizable, lo que significa que ahora si queremos añadir más clases a nuestra aplicación como por ejemplo una clase Médico, Utiller@, Jefe/a de prensa etc. que pertenezcan también al equipo técnico de la selección Española, lo podemos hacer de forma muy sencilla ya que en la clase padre (SeleccionFutbol) tenemos implementado parte de sus datos y de su comportamiento y solo habrá que implementar los atributos y métodos propios de esa clase. ¿Empezáis a ver la utilidad de la herencia?. Ahora si os habéis fijado bien en el código que se ha escrito y sino habéis tenido experiencia con la herencia en Java, habréis podido observar dos palabras reservadas  nuevas  como son  extends ,  protected  y  super . Pues bien, ahora vamos a explicar el significado de ellas: extends: Esta palabra reservada, indica a la clase hija cual va a ser su clase padre, es decir que por ejemplo en la clase Futbolista al poner  public class Futbolista extends SeleccionFutbol  le estamos indicando a la clase 'Futbolista' que su clase padre es la clase 'SeleccionFutbol' o dicho de otra manera para que se entienda mejor, al poner esto estamos haciendo un  copy-paste dinámico  diciendo a la clase 'Futbolista' que se 'copie' todos los atributos y métodos públicos o protegidos de la clase 'SeleccionFutbol'. De aquí viene esa 'definición' que dimos de que la herencia en un 'copy-paste dinámico'. protected:  sirve para indicar un tipo de visibilidad de los atributos y métodos de la clase padre y significa que cuando un atributo es 'protected' o protegido, solo es visible ese atributo o método desde una de las clases hijas y no desde otra clase. super: sirve para llamar al constructor de la clase padre. Quizás en el código que hemos puesto no se ha visto muy bien, pero a continuación lo mostramos de formas más clara, viendo el constructor de los objetos pasándole los atributos: public class SeleccionFutbol { ...... public SeleccionFutbol() { } public SeleccionFutbol(int id, String nombre, String apellidos, int edad) { this.id = id; this.Nombre = nombre; this.Apellidos = apellidos; this.Edad = edad; } ...... public class Futbolista extends SeleccionFutbol { ...... public Futbolista() { super(); } public Futbolista(int id, String nombre, String apellidos, int edad, int dorsal, String demarcacion) { super(id, nombre, apellidos, edad); this.dorsal = dorsal; this.demarcacion = demarcacion; } ...... Hasta aquí todo correcto, pero ahora vamos a ver como trabajamos con estas clases. Para ver este funcionamiento de forma clara y sencilla vamos a trabajar con un objeto de cada clase y vamos a ver como se crean y de que forma ejecutan sus método. Para ello empecemos mostrando el siguiente fragmento de código: public class Main { // ArrayList de objetos SeleccionFutbol. Idenpendientemente de la clase hija a la que pertenezca el objeto public static ArrayList<SeleccionFutbol> integrantes = new ArrayList<SeleccionFutbol>(); public static void main(String[] args) { Entrenador delBosque = new Entrenador(1,  Vicente ,  Del Bosque , 60,  284EZ89 ); Futbolista iniesta = new Futbolista(2,  Andres ,  Iniesta , 29, 6,  Interior Derecho ); Masajista raulMartinez = new Masajista(3,  Raúl ,  Martinez , 41,  Licenciado en Fisioterapia , 18); integrantes.add(delBosque); integrantes.add(iniesta); integrantes.add(raulMartinez); // CONCENTRACION System.out.println( Todos los integrantes comienzan una concentracion. (Todos ejecutan el mismo método) ); for (SeleccionFutbol integrante : integrantes) { System.out.print(integrante.getNombre()+   +integrante.getApellidos()+  ->  ); integrante.Concentrarse(); } // VIAJE System.out.println( nTodos los integrantes viajan para jugar un partido. (Todos ejecutan el mismo método) ); for (SeleccionFutbol integrante : integrantes) { System.out.print(integrante.getNombre()+   +integrante.getApellidos()+  ->  ); integrante.Viajar(); } ...... Lo primero que vemos es que nos creamos un objeto de cada clase, pasándole los atributos al constructor como parámetro y después  sorprendentemente  los metemos en un  ArrayList  de objetos de la clase  SeleccionFutbol  que es la clase padre. Esto evidentemente te lo permite hacer ya que todos los objetos son hijos de la misma clase padre. Luego como veis, recorremos el ArrayList y ejecutamos sus métodos  comunes  como son el 'Concentrarse' y el 'Viajar'. Este código da como salida lo siguiente: Todos los integrantes comienzan una concentracion. (Todos ejecutan el mismo método) Vicente Del Bosque -> Concentrarse Andres Iniesta -> Concentrarse Raúl Martinez -> Concentrarse Todos los integrantes viajan para jugar un partido. (Todos ejecutan el mismo método) Vicente Del Bosque -> Viajar Andres Iniesta -> Viajar Raúl Martinez -> Viajar Como veis al ejecutar todos el mismo método de la clase padre el código puesto funciona correctamente. Posteriormente vamos a ejecutar código especifico de las clases hijas, de ahi que ahora no podamos recorrer el ArrayList y ejecutar el mismo método para todos los objetos ya que ahora esos objetos son únicos de la clases hijas. El código es el siguiente: // ENTRENAMIENTO System.out.println( nEntrenamiento: Solamente el entrenador y el futbolista tiene metodos para entrenar: ); System.out.print(delBosque.getNombre()+   +delBosque.getApellidos()+  ->  ); delBosque.dirigirEntrenamiento(); System.out.print(iniesta.getNombre()+   +iniesta.getApellidos()+  ->  ); iniesta.entrenar(); // MASAJE System.out.println( nMasaje: Solo el masajista tiene el método para dar un masaje: ); System.out.print(raulMartinez.getNombre()+   +raulMartinez.getApellidos()+  ->  ); raulMartinez.darMasaje(); // PARTIDO DE FUTBOL System.out.println( nPartido de Fútbol: Solamente el entrenador y el futbolista tiene metodos para el partido de fútbol: ); System.out.print(delBosque.getNombre()+   +delBosque.getApellidos()+  ->  ); delBosque.dirigirPartido(); System.out.print(iniesta.getNombre()+   +iniesta.getApellidos()+  ->  ); iniesta.jugarPartido(); Como vemos aunque el entrenador y los futbolistas asistan a un entrenamiento, los dos hacen una función diferente en el mismo, por tanto hay que hacer métodos diferente para cada una de las clases. Ya veremos cuando hablemos del polimorfismo que podremos ejecutar el mismo método para clases diferentes y que esos métodos hagan cosas distintas. Como resultado al código mostrado tenemos lo siguiente: Entrenamiento: Solamente el entrenador y el futbolista tiene metodos para entrenar: Vicente Del Bosque -> Dirige un entrenamiento Andres Iniesta -> Entrena Masaje: Solo el masajista tiene el método para dar un masaje: Raúl Martinez -> Da un masaje Partido de Fútbol: Solamente el entrenador y el futbolista tiene metodos para el partido de fútbol: Vicente Del Bosque -> Dirige un partido Andres Iniesta -> Juega un partido CONCLUSIONES Y ACLARACIONES: Esto ha sido todo lo que hemos contado sobre la herencia en esta entrada. El tema de la herencia es un tema que puede ser un poco más complejo de lo que lo hemos contado aquí, ya que solo hemos contado lo que es la herencia simple (ya que Java por el momento es el único tipo de herencia que soporta) y no la herencia múltiple, que es un tipo de herencia en la que una clase hija puede tener varios padres, aunque por el momento si estáis empezando a aprender el concepto de la herencia, con la herencia simple tenéis más que suficiente. Para los que os estéis iniciando en el mundo de la ingeniería informática, habréis podido ver que hemos puesto unos ejemplo mostrando unos diagramas  un poco raros ; pues bien, estos diagramas se llaman diagramas de clases (que los hemos realizado con la herramienta web de www.genmymodel.com) y sirven para representar de forma gráfica los atributos y métodos de las clases y las relaciones entre ellos, utilizando el lenguaje UML del cual intentaremos hablar más adelante en otros tutoriales. Por último decir y aclarar que en esta entrada quizás no hemos utilizado una terminología correcta para explicar la herencia, pero lo hemos explicadode una forma algo distinta a como esta explicada por ahi para que los que empeceis podais entender la herencia desde otro punto de vista."
    },

    {
        "id": 90,
        "autor": "arkaitzgarro",
        "pagina": "arkaitzgarro",
        "fecha": "0/0/0",
        "titulo": "CAPÍTULO 16 HERENCIA",
        "link": "https://www.arkaitzgarro.com/java/capitulo-16.html",
        "contenido": "16.1 DEFINICIÓN DE HERENCIA La herencia es una propiedad que permite la declaración de nuevas clases a partir de otras ya existentes. Esto proporciona una de las ventajas principales de la Programación Orientada a Objetos: la reutilización de código previamente desarrollado ya que permite a una clase más específica incorporar la estructura y comportamiento de una clase más general. Cuando una clase B se construye a partir de otra A mediante la herencia, la clase B hereda todos los atributos, métodos y clases internas de la clase A. Además la clase B puede redefinir los componentes heredados y añadir atributos, métodos y clases internas específicas. Para indicar que la clase B (clase descendiente, derivada, hija o subclase) hereda de la clase A (clase ascendiente, heredada, padre, base o superclase) se emplea la palabra reservada extends en la cabecera de la declaración de la clase descendiente. La sintaxis es la siguiente: public class ClaseB extends ClaseA { // Declaracion de atributos y metodos especificos de ClaseB // y/o redeclaracion de componentes heredados } Por ejemplo, a partir de la clase Precio: /** * Ejemplo de declaracion de la clase Precio */ public class Precio { // Variable de instancia public double euros; // Metodos publicos public double da() { return this.euros; } public void pone(double x) { this.euros = x; } } se construye la clase Producto como descendiente de la clase Precio de la siguiente forma: /** * Ejemplo de declaracion de la clase Producto * clase producto desciende de Precio */ public class Producto extends Precio { // Variable de instancia public int codigo; // Metodos publicos public int daCodigo() { return this.codigo; } public void asignaCodigo(int x) { this.codigo=x; } public void asignaProducto(int cod, double p) { this.asignaCodigo(cod); this.pone(p); } public String toString() { return  Codigo:   + codigo +   ; precio:   + euros +   euros ; } } La clase PruebaClaseProducto trabaja con dos instancias de la clase Producto: /** *  Demostracion de la clase Producto */ public class PruebaClaseProducto { public static void main (String [] args){ Producto p = new Producto(); p.asignaProducto(200201, 15.8); System.out.println(p.toString()); Producto q = new Producto(); q.asignaCodigo(200202); q.pone(34.3); System.out.println(q.toString()); } } Durante la ejecución del código anterior, se generan las instancias, referenciadas por p y q, cada una de las cuales está compuesta por dos atributos: euros, variable de instancia heredada de la clase Precio y codigo, variable de instancia específica de la clase Producto. Representación grafica de las instancias de la clase <code>Producto</code> Figura 16.1 Representación grafica de las instancias de la clase Producto Por otro lado, la ejecución de PruebaClaseProducto produce la siguiente salida por pantalla: $>javac PruebaClaseProducto.java $>java PruebaClaseProductoCodigo: 200201 ; precio: 15.8 euros Codigo: 200202 ; precio: 34.3 euros 16.2 JERARQUÍA DE CLASES Java permite múltiples niveles de herencia pero no la herencia multiple, es decir una clase sólo puede heredar directamente de una clase ascendiente. Por otro lado, una clase puede ser ascendiente de tantas clases descendiente como se desee (un unico padre, multitud de hijos). En la siguiente figura se muestra gráficamente un ejemplo de jerarquía entre diferentes clases relacionadas mediante la herencia. Representación de una jerarquía de clases relacionadas mediante la herencia Figura 16.2 Representación de una jerarquía de clases relacionadas mediante la herencia 16.3 REDEFINICIÓN DE ELEMENTOS HEREDADOS Como se ha comentado anteriormente la clase descendiente puede añadir sus propios atributos y métodos pero también puede sustituir u ocultar los heredados. En concreto: Se puede declarar un nuevo atributo con el mismo identificador que uno heredado, quedando este atributo oculto. Esta técnica no es recomendable. Se puede declarar un nuevo método de instancia con la misma cabecera que el de la clase ascendiente, lo que supone su sobreescritura. Por lo tanto, la sobreescritura o redefinición consiste en que métodos adicionales declarados en la clase descendiente con el mismo nombre, tipo de dato devuelto y número y tipo de parámetros sustituyen a los heredados. Se puede declarar un nuevo método de clase con la misma cabecera que el de la clase ascendiente, lo que hace que éste quede oculto. Por lo tanto, los métodos de clase o estáticos (declarados como static) no pueden ser redefinidos. Un método declarado con el modificador final tampoco puede ser redefinido por una clase derivada. Se puede declarar un constructor de la subclase que llame al de la superclase de forma implícita o de mediante la palabra reservada super. En general puede accederse a los métodos de la clase ascendiente que han sido redefinidos empleando la palabra reservada super delante del identificador del método. Este mecanismo sólo permite acceder al metodo perteneciente a la clase en el nivel inmediatamente superior de la jerarquía de clases. 16.4 LA CLASE OBJECT Independientemente de utilizar la palabra reservada extends en su declaración, todas las clases derivan de una superclase llamada Object. Ésta es la clase raíz de toda la jerarquía de clases de Java. El hecho de que todas las clases deriven implícitamente de la clase Object no se considera herencia múltiple. Jerarquía de clases predefinidas en Java Figura 16.3 Jerarquía de clases predefinidas en Java Como consecuencia de ello, todas las clases tienen algunos métodos heredados de la clase Object. Algunos de los métodos de la clase predefinida <code>Object</code> Figura 16.4 Algunos de los métodos de la clase predefinida Object Es bastante frecuente tener que sobreescribir algunos de estos métodos. Por ejemplo, para verificar si dos instancias son iguales en el sentido de contener la misma información en sus atributos se debería sobreescribir el método equals(). El siguiente código muestra un ejemplo de módificación de la clase Producto para incluir una sobreescritura del método equals(): public class Producto extends Precio { ... public boolean equals(Object a) { if (a instanceof Producto) return (codigo==a.daCodigo()); else return false; } } También es bastante habitual sobreescribir el método toString(). 16.5 HERENCIA Y CONSTRUCTORES La subclase necesita normalmente que se ejecute el constructor de la superclase antes que su propio constructor para inicializar las variables de instancia heredadas. La solución consiste en utilizar la palabra reservada super seguida entre paréntesis de los parámetros correspondiente en el cuerpo del constructor de la subclase. Es decir, incluir la siguiente sentencia como primera línea de código: super(argumentos opcionales); De esta forma la implementación de un constructor de la clase descendiente sólo necesita inicializar directamente las variables de instancia no heredadas. Si no aparece como primera sentencia, el compilador inserta una llamada implícita super(); que inicializa las variables de instancia a cero, false, carácter nulo o null dependiendo de su tipo. Esta llamada en cadena a los constructores de las clases ascendientes llega hasta el origen de la jerarquía de clases, es decir, hasta el constructor de la clase Object. En cualquier caso, la creación de una nueva instancia mediante un constructor debe tener tres fases: Llamada al constructor de la clase ascendiente. Se asignan valores a los atributos. Se ejecuta el resto del constructor. 16.6 CASTING O MOLDES ENTRE OBJETOS CON RELACIÓN DE HERENCIA El casting o moldeo permite el uso de un objeto de una clase en lugar de otro de otras clase con el que haya una relación de herencia. Por ejemplo: Object a = new Producto(); Entonces a es momentáneamente tanto una instancia de la clase Object como Producto (hasta que más adelante se le asigne un objeto que no sea un Producto). A esto se le llama moldeo implícito. Por otro lado, si se escribe: Producto b = a; se obtendrá un error de compilación porque el objeto referenciado por a no es considerado por el compilador como un Producto. Sin embargo se le puede indicar al compilador que a la referencia a se le va a asignar obligatoriamente un Producto. Producto b = (Producto)a; Este moldeo explícito introduce la verificación durante la ejecución de que a la referencia a se le ha asignado un Producto así que el compilador no genera un error. En el caso que durante la ejecución la referencia a no fuera a un Producto, se generaría una excepción. Para asegurar esta situación y evitar el error de ejecución se podría emplear el operador instanceof: if (a instanceof Producto) { Producto b = (Producto)a; } 16.7 CLASES Y MÉTODOS ABSTRACTOS Una clase abstracta es una clase de la que no se pueden crear instancias. Su utilidad consiste en permitir que otras clases deriven de ella. De esta forma, proporciona un modelo de referencia a seguir a la vez que una serie de métodos de utilidad general. Las clases abstractas se declaran empleando la palabra reservada abstract como se muestra a continuación: public abstract class IdClase . . . Una clase abstracta puede componerse de varios atributos y métodos pero debe tener, al menos, un método abstracto (declarado también con la palabra reservada abstract en la cabecera). Los métodos abstractos no se implementan en el código de la clase abstracta pero las clases descendientes de ésta han de implementarlos o volver a declararlos como abstractos (en cuyo caso la subclase también debe declararse como abstracta). En cualquier caso, ha de indicarse el tipo de dato que devuelve y el número y tipo de parámetros. La sintaxis de declaración de un método abstracto es: abstract modificador tipo_retorno idClase(lista_parametros); Si una clase tiene métodos abstractos, entonces también la clase debe declararse como abstracta. Como los métodos de clase (static) no pueden ser redefinidos, un método abstracto no puede ser estático. Tampoco tiene sentido que declarar constructores abstractos ya que un constructor se emplea siempre al crear una instancia (y con las clases abstractas no se crean instancias). Ejemplo de código con la declaración de clase abstracta: /** * Declaracion de la clase abstracta FiguraGeometrica */ public abstract class FiguraGeometrica { // Declaracion de atributos private String nombre; // Declaracion de metodos abstract public double area(); public figuraGeometrica (String nombreFigura ) { this.nombre = nombreFigura; } final public boolean mayorQue (FiguraGeometrica otra) { return this.area()>otra.area(); } final public String toString() return this.nombre +   con area   + this.area(); } } Como ejemplo de utilización de Rectangulo se construye a partir de la clase abstracta FiguraGeometrica: /** * Ejemplo de uso de la declaracion de una clase abstracta * Declaracion de la clase Rectangulo */ public class Rectangulo extends FiguraGeometrica { private double base; private double altura; public Rectangulo (double largo, double ancho) { super( Rectangulo ); this.base = largo; this.altura = ancho; } public double area () { return this.base * this.altura; } } Ejemplo de uso de la clase Rectangulo: /** * Ejemplo de uso de la clase Rectangulo */ public class pruebaRectangulo { public static void main (String [] args ) { Rectangulo r1; r1 = new Rectangulo(12.5, 23.7); System.out.println( Area de r1 =   + r1.area()); Rectangulo r2 = new Rectangulo(8.6, 33.1); System.out.println( Area de r2 =   + r2.toString()); if (r1.mayorQue(r2)) System.out.println( El rectangulo de mayor area es r1 ); else System.out.println( El rectangulo de mayor area es r2 ); } } Salida por pantalla de la ejecución del código anterior: $>java PruebaRectangulo Area de r1 = 296.25 Area de r2 = Rectangulo con area 284.66 El rectangulo de mayor area es r1 16.8 CLASES Y MÉTODOS FINALES Una clase declarada con la palabra reservada final no puede tener clases descendientes. Por ejemplo, la clase predefinida de Java Math está declarada como final. A modo de ejemplo, se desarrolla una clase final MathBis (de operatividad similar a la clase Math estándar de Java) que incluye la declaración de dos métodos que calculan y devuelven respectivamente las siguientes funciones trigonométricas: El código fuente de la clase es: /** * Ejemplo de declaracion de una clase final * Declaracion de la clase MathBis */ public final class MathBis { public static double asinh(double x) { return Math.log(x+Math.sqrt(x*x+1)); } public static double acosh(double x) { return Math.log(x+Math.sqrt(x*x-1)); } } Ejemplo de uso de la clase MathBis: /** * Ejemplo de uso de una clase final * Declaracion de la clase pruebaMathBis */ public class PruebaMathBis { public static void main (String [] args) { for (int i=-5; i<10; i++) { double x = i/5.0; System.out.print( Para x =   + x); System.out.print( : asinh(x) =   +MathBis.asinh(x)); System.out.println( , acosh(x) =   +MathBis.acosh(x)); } } } Por otro lado, un método declarado como final no puede ser redefinido por una clase descendiente. Los métodos que son llamados desde los constructores deberían declararse como final, ya que si un constructor llama a un método que no lo sea, la subclase podría haberla redefinido con resultados indeseables."
    },

    {
        "id": 91,
        "autor": "Alex Rodríguez",
        "pagina": "aprenderaprogramar",
        "fecha": "0/0/0",
        "titulo": "Ejemplo de herencia en Java. Uso de palabras clave extends y super. Constructores con herencia.",
        "link": "https://www.aprenderaprogramar.com/index.php?option=com_content&view=article&id=653:ejemplo-de-herencia-en-java-uso-de-palabras-clave-extends-y-super-constructores-con-herencia-cu00686b&catid=68&Itemid=188#:~:text=Para%20declarar%20la%20herencia%20en,clases%20que%20mostramos%20a%20continuaci%C3%B3n.",
        "contenido": "EJEMPLO DE HERENCIA EN JAVA. EXTENDS Y SUPER. Para declarar la herencia en Java usamos la palabra clave extends. Ejemplo: public class MiClase2 extends Miclase1. Para familiarizarte con la herencia te proponemos que escribas y estudies un pequeño programa donde se hace uso de ella. Escribe el código de las clases que mostramos a continuación. //Código de la clase Persona ejemplo aprenderaprogramar.com public class Persona { private String nombre; private String apellidos; private int edad; //Constructor public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad;                   } //Métodos public String getNombre () { return nombre;  } public String getApellidos () { return apellidos;  } public int getEdad () { return edad;   } } //Cierre de la clase //Código de la clase profesor, subclase de la clase Persona ejemplo aprenderaprogramar.com public class Profesor extends Persona { //Campos específicos de la subclase. private String IdProfesor; //Constructor de la subclase: incluimos como parámetros al menos los del constructor de la superclase public Profesor (String nombre, String apellidos, int edad) { super(nombre, apellidos, edad); IdProfesor =  Unknown ;   } //Cierre del constructor //Métodos específicos de la subclase public void setIdProfesor (String IdProfesor) { this.IdProfesor = IdProfesor;   } public String getIdProfesor () { return IdProfesor;   } public void mostrarNombreApellidosYCarnet() { // nombre =  Paco ; Si tratáramos de acceder directamente a un campo privado de la superclase, salta un error // Sí podemos acceder a variables de instancia a través de los métodos de acceso públicos de la superclase System.out.println ( Profesor de nombre:   + getNombre() +     +  getApellidos() + con Id de profesor:   + getIdProfesor() ); } } //Cierre de la clase //Código de test aprenderaprogramar.com public class TestHerencia1 { public static void main (String [ ] Args) { Profesor profesor1 = new Profesor ( Juan ,  Hernández García , 33); profesor1.setIdProfesor( Prof 22-387-11 ); profesor1.mostrarNombreApellidosYCarnet();} } //Cierre de la clase El diagrama de clases y el resultado del test son del tipo que mostramos a continuación: herencia, java Profesor de nombre: Juan Hernández García con Id de profesor: Prof 22-387-11 Los aspectos a destacar del código son: a) La clase persona es una clase “normal” definida tal y como lo venimos haciendo habitualmente mientras que la clase Profesor es una subclase de Persona con ciertas peculiaridades. b) Los objetos de la subclase van a tener campos nombre, apellidos y edad (heredados de Persona) y un campo específico IdProfesor. El constructor de una subclase ha de llevar obligatoriamente como parámetros al menos los mismos parámetros que el constructor de la superclase. c) El constructor de la subclase invoca al constructor de la superclase. Para ello se incluye, obligatoriamente, la palabra clave super como primera línea del constructor de la subclase. La palabra super irá seguida de paréntesis dentro de los cuales pondremos los parámetros que requiera el constructor de la superclase al que queramos invocar. En este caso solo teníamos un constructor de superclase que requería tres parámetros. Si p.ej. hubiéramos tenido otro constructor que no requiriera ningún parámetro podríamos haber usado uno u otro, es decir, super(nombre, apellidos, edad) ó super(), o bien ambos teniendo dos constructores para la superclase y dos constructores para la subclase. Ejemplo: En la superclase:                                public Persona() { nombre =   ; apellidos =   ; edad = 0; } public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad;                   } En la subclase:                                   public Profesor () { super(); IdProfesor =  Unknown ;} public Profesor (String nombre, String apellidos, int edad) { super(nombre, apellidos, edad); IdProfesor =  Unknown ;   } Modifica el código de las clases Persona y Profesor para que queden con dos constructores tal y como hemos mostrado aquí. Crea objetos de ambos tipos en BlueJ y prueba sus métodos. ¿Qué ocurre si olvidamos poner super como primera línea de la subclase? Hay dos posibilidades: si la superclase tiene un constructor sin parámetros, el compilador incluirá en segundo plano super de forma automática y no saltará un error. De cualquier manera se considera contrario al buen estilo de programación, ya que no queda claro si se trata de un olvido. Por ello incluiremos siempre la palabra clave super. La otra posibilidad es que no haya un constructor sin parámetros, en cuyo caso saltará un error. A modo de resumen: la inicialización de un objeto de una subclase comprende dos pasos. La invocación al constructor de la superclase (primera línea del constructor: super…) y el resto de instrucciones propias del constructor de la subclase."
    }
]