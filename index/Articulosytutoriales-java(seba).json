[
    {
        "id": 61,
        "autor": "Oscar Blancarte",
        "pagina": "oscarblancarteblog",
        "fecha": "25/06/2018",
        "titulo": "Creando un API REST en Java (parte 1)",
        "link": "https://www.oscarblancarteblog.com/2018/06/25/creando-un-api-rest-en-java-parte-1/",
        "contenido": "Sin lugar a duda, los servicios REST ya se han convertido en la principal tecnolog√≠a para construir servicios, superando con creces a los servicios SOAP o com√∫nmente conocidos como Web Services. A pesar de que REST ya es visiblemente la tendencia en el desarrollo de servicios, sigue existiendo una gran discusi√≥n acerca de si SOAP es mejor que REST o al rev√©s, sin embargo, no quiera tocar este tema ahora, pues no es el tema central de este art√≠culo, para eso he creado el art√≠culo ‚ÄúSOA vs REST‚Äù donde discutimos sobre estas dos tecnolog√≠as y sus ventajas y desventajas. NOTA: Este art√≠culo es parte de un tutorial completo para crear API REST con JAX-RS, si quieres ver el √≠ndice completo entra aqu√≠. Antes de comenzar, te cuento que puedes descargar el c√≥digo completo en https://github.com/oscarjb1/blog-tutorial-jaxrs/tree/master/M%C3%A9todos%20HTTP/api Configurando el proyecto Dicho este, pasemos ahora si a implementar un API REST con Java, para esto, ser√° indispensable crear un proyecto de tipo WEB en tu IDE favorito, en este caso, vamos a crear un ‚ÄúDynamic web project‚Äù en Eclipse, para esto nos dirigimos a file -> new -> Other en el men√∫ superior: Seleccionamos la opci√≥n Dynamic web Project y presionamos Next para iniciar con la configuraci√≥n de la aplicaci√≥n: Una vez aqu√≠, escribimos ‚Äúapi‚Äù como nombre del proyecto y seleccionamos nuestro servidor de aplicaciones de preferencia, en nuestro caso, utilizamos Wildfly 11 pero podr√≠as utilizar cualquier otro que tengas disponible. Finalmente, presionamos ‚ÄúFinish‚Äù para concluir con la creaci√≥n del proyecto. El siguiente paso ser√° convertir nuestro proyecto a un proyecto Maven, con la finalidad de administrar m√°s f√°cilmente nuestras librer√≠as. Para ello, nos posicionaremos sobre el proyecto creado y presionaremos ‚Äúclick derecho‚Äú para abrir las opciones del proyecto, estando all√≠, nos dirigimos a configure -> convert to Maven Project, tras presionar esto, saldr√° una ventana para configurar el proyecto, a lo que simplemente daremos finalizar. Tras realizar los pasos anteriores deber√°s ver el proyecto tal y como se ve en la imagen anterior. Podr√°s observar una peque√±a ‚ÄúM‚Äù en el √≠cono del proyecto, se√±al de que se trata de un proyecto Maven. El siguiente paso es configurar las librer√≠as de JavaEE y Wildfly con la finalidad de que est√©n disponibles en nuestro proyecto, por lo que tendremos que ir al archivo pom.xml y agregar las siguientes dos librer√≠as: <dependency> <groupId>javax</groupId> <artifactId>javaee-api</artifactId> <version>7.0</version> <scope>provided</scope> <type>jar</type> </dependency> <dependency> <groupId>org.wildfly.core</groupId> <artifactId>wildfly-server</artifactId> <version>2.2.0.Final</version> <scope>provided</scope> </dependency> Guardamos los cambios y tendremos que esperar un momento hasta que Eclipse descarga todas las dependencias necesarias, para esto, ver√°s un indicador de progreso en la parte inferior derecha de Eclipse. Una vez que ha finalizado, estamos listos para empezar a desarrollar. Iniciando el desarrollo Lo primero que debemos de hacer para iniciar nuestra API REST es indicarle el Path base desde el cual estar√° respondiendo nuestra API. Este path corresponde a la URL a partir de la cual se expondr√° nuestros servicios. Para lograr esto, ser√° necesario crear una clase que extienda de ‚ÄúApplication‚Äù, esta clase puede llamarse como sea y puede colocarse en cualquier paquete, lo √∫nico importante es que extienda de Application y defina la anotaci√≥n @ApplicationPath. En nuestro caso crearemos la clase RestApplication en el package api. package api; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( / ) public class RestApplication extends Application { } Como podemos ver, hemos definido ‚Äú/‚Äù como URL base, es decir que los servicios responder√°n a partir de la ra√≠z del proyecto, pero tu podr√≠as remplazarla por la URL base que m√°s te guste, como por ejemplo ‚Äú/api‚Äù o ‚Äú/services‚Äù. El siguiente paso ser√° crear nuestro primer servicio, para lo cual deberemos crear una nueva clase, en este caso, crearemos la clase HelloWorldRest en el mismo paquete: package api; import javax.ws.rs.Consumes; import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.Produces; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; @Path( /helloworld ) @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class HelloWorldRest { @GET public Response sayHello() { return Response.ok( Hello World desde el API REST ,MediaType.APPLICATION_JSON).build(); } } Como podr√°s observar, esta es una clase com√∫n y corriente pero que tiene algunas anotaciones, las cuales ser√°n reconocidas por el servidor de aplicaciones para finalmente exponer el servicio, analicemos para que esta cada una de ellas. La anotaci√≥n @Path indica la URL en la cual responder√° este servicio, cabe mencionar que esta anotaci√≥n se puede poner a nivel de clase y m√©todo, en este caso, al estar a nivel de clase, afecta a todos los servicios que definamos, pero eso lo vamos a analizar m√°s adelante. Las siguientes dos anotaciones son para indicar que tipo de mensaje esperamos como entrada (consumes) y que tipo de mensaje vamos a responder (produces). En este caso, estamos indicando que esperamos JSON como entrada y que vamos a responder igualmente con JSON. Finalmente, siguen los m√©todos, una clase puede tener m√°s de un m√©todo, y cada m√©todo se puede exponer como un servicio independiente, sin embargo, en esta primera introducci√≥n empezaremos con uno. La anotaci√≥n @GET le indica al servidor de aplicaciones que el m√©todo responde por el m√©todo GET √∫nicamente. Adicional tenemos anotaciones para los dem√°s m√©todos, como @POST, @PUT, @DELETE, etc. pero estos los estaremos analizando m√°s adelante. Podr√°s observar que el m√©todo responde con un tipo llamado Response, esta es una clase de utilidad que nos proporciona el API de JAX-RS para convertir f√°cilmente un objeto en un JSON en nuestro caso. Esta clase nos proporciona el m√©todo ok, el cual nos crea una respuesta con status 200, es decir, respuesta exitosa, la cual recibe el mensaje que queremos responder y el tipo de datos del mensaje, en nuestro caso JSON. Probando nuestro Hello World En este punto hemos terminado nuestro primer servicio, por lo que solo resta desplegarlo y probarlo. Para desplegarlo, basta con presionar el click derecho sobre el proyecto y presionar Run As -> Run on Server, presionar siguiente y finalizar. Si la aplicaci√≥n desplego correctamente, podremos probar el servicio en la URL http://localhost:8080/api-0.0.1-SNAPSHOT/helloworld, esta URL la podr√°s ejecutar directamente sobre el navegador: En este punto te estar√°s preguntando como es que se gener√≥ esta URL, por lo que explico a continuaci√≥n: La URL se forma con la siguiente formula: <server_path>:<port>/<app_context>/<app_path>/<service_path> La secci√≥n <server_path> y <port> corresponde al host del servidor y el puerto en el cual responde, esto corresponde a Wildfly. La secci√≥n <app_context> corresponde a la URL base que nos asigna el servidor de aplicaciones cuando desplegamos. La secci√≥n <app_path> fue la que definimos en la anotaci√≥n @ApplicationPath. En nuestro caso, al definirla como ‚Äú/‚Äù quiere decir que responder√° a partir de la ra√≠z del proyecto. Finalmente, <service_path> corresponde a la URL definida en la anotaci√≥n @Path, la cual se defini√≥ como ‚Äúhelloworld‚Äù. Te invito a que veas mi curso Mastering API REST con Spring Boot Conclusiones Hasta este punto hemos aprendido a crear un proyecto web y configurarlo para que responda a nuestras solicitudes como un API REST, por lo que en la siguiente secci√≥n de esta gu√≠a aprenderemos a utilizar los dem√°s m√©todos (POST, DELETE, PUT) y aprenderemos a configurar nuestras URL para responder a URL m√°s complejas, por lo que te invito a que te suscribas a mi blog para hacerte llegar las actualizaciones."
    },

    {
        "id": 62,
        "autor": "Rosa",
        "pagina": "developrogramming",
        "fecha": "12/05/2020",
        "titulo": "Crear API REST JAVA",
        "link": "https://developrogramming.com/crear-api-rest-java/",
        "contenido": "A continuaci√≥n, explicar√© c√≥mo crear servicios web desarrollando una API REST JAVA con la librer√≠a JAX-RS y Jersey. ¬øQu√© es REST? Sus siglas significan Transferencia de Estado Representacional. No es un protocolo de comunicaci√≥n, sino una definici√≥n de arquitectura donde la comunicaci√≥n se realiza v√≠a HTTP utilizando los m√©todos GET, POST, PUT, DELETE y PATCH. La respuesta de esos m√©todos admiten formatos como JSON (Notaci√≥n de Objeto de JavaScript), XML, HTML o TEXTO PLANO, entre otros. As√≠, cuando se habla de aplicaci√≥n RESTful quiere decir que implementa este tipo de arquitectura. ¬øQu√© es JAX-RS? Java API for RESTful Web Services. Es una especificaci√≥n para crear Servicios Web REST que se basa en anotaciones para simplificar el desarrollo y despliegue de los clientes. ¬øQu√© es Jersey? Es un cliente RESTful e implementa JAX-RS. Facilita a los desarrolladores crear servicios web RESTful con Java. api rest Operaciones REST Las principales operaciones de un sistema REST y la especificaci√≥n HTTP son las siguientes: GET (leer) POST (crear) PUT (editar) DELETE (eliminar) PATCH (actualizar) Crear proyecto Lo primero que hay que hacer es crear un proyecto web din√°mico Java y configurarlo para poder trabajar con Maven. Como entorno de desarrollo he utilizado Eclipse. Modificar fichero pom.xml A continuaci√≥n, introducimos las dependencias en el fichero de configuraci√≥n de Maven. pom.xml <project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>API_REST_WS-RS</groupId> <artifactId>API_REST_WS-RS</artifactId> <version>0.0.1-SNAPSHOT</version> <packaging>war</packaging> <build> <sourceDirectory>src</sourceDirectory> <plugins> <plugin> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.0</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <plugin> <artifactId>maven-war-plugin</artifactId> <version>3.2.1</version> <configuration> <warSourceDirectory>WebContent</warSourceDirectory> </configuration> </plugin> </plugins> </build> <dependencies> <dependency> <groupId>javax.ws.rs</groupId> <artifactId>javax.ws.rs-api</artifactId> <version>2.1.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-servlet</artifactId> <version>2.25.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.25.1</version> </dependency> </dependencies> </project> Crear clases A continuaci√≥n, vamos a crear las clases User.java, ServicioUsers.java y Configuration.java. User.java package es.rosamarfil.modelo; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } ServicioUsers.java package es.rosamarfil.services; import java.util.ArrayList; import java.util.List; import javax.ws.rs.BeanParam; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.GET; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.client.Entity; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; import javax.ws.rs.core.Response.Status; import es.rosamarfil.modelo.User; @Path( /users ) public class ServicioUsers { private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; /** * URL: http://localhost:8080/API_REST_WS-RS/api/users * @return Response list Users */ @GET @Produces(MediaType.APPLICATION_JSON) public Response getUsers() { return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/Rosa * * @param name String * @return Response */ @GET @Path( /{name} ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response getUserById(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/createUser Parameters in * Postman: { name : Rosa3333 , username : Marfi3333l } * * @param User * @return Response list NOTA: Si no existe el constructor vac√≠o de User, da un *         error y el userRequest viene null. */ @POST @Path( /createUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response createUser(User userRequest) { this.listaUsuarios.add(userRequest); //return Response.status(Status.CREATED).build(); return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/updateUser Parameters in * Postman: { name : Rosa , username : Marfil3333 } * * @param User * @return user modified NOTA: Si no existe el constructor vac√≠o de User, da un *         error y el userRequest viene null. */ @PUT @Path( /updateUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateUser(User userUpdate) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(userUpdate.getName())) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { found.setUsername(userUpdate.getUsername()); return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa * * @param User * @return Response */ @DELETE @Path( /deleteUser/{name} ) @Produces(MediaType.APPLICATION_JSON) public Response deleteUser(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); listaUsuarios.remove(found); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(listaUsuarios).build(); } } } Configuration.java package es.rosamarfil.services; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( api ) public class Configuration extends Application { } Probar nuestra API REST Para poder acceder a los servicios creados, lo primero que hay que hacer es publicarlos a trav√©s de un servidor. Para ello, desde Eclipse arrancaremos nuestro proyecto. Previamente necesitaremos tener un servidor configurado, como por ejemplo Apache. Una vez hecho esto, nos situaremos sobre nuestro proyecto, desplegaremos el men√∫ contexual y seleccionaremos Run As -> Run on Server. Crear API REST JAVA - JAX-RS y Jersey Una vez arrancado el servidor con nuestra aplicaci√≥n, podemos probar los servicios o bien desde la barra de direcciones de un navegador o desde alg√∫n programa cliente como Postman. La direcci√≥n base de nuestra aplicaci√≥n es: http://localhost:8080/API_REST_WS-RS Vamos a ver los par√°metros a introducir: GET (leer) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users GET (leer) a partir de un par√°metro. En este caso buscaremos un usuario por nombre. En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/Rosa POST (crear) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/createUser y en la secci√≥n Body, introduce un usuario en formato json, como se muestra en la imagen: Crear API REST JAVA - JAX-RS y Jersey - Postman PUT (editar) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/updateUser y en la secci√≥n Body de Postman introduce: {¬´name¬ª:¬ªRosa¬ª,¬ªusername¬ª:¬ªMarfil3333‚Ä≥} DELETE (eliminar) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa Y hasta aqu√≠ la creaci√≥n de tu primera API REST. Como ves, con unos simples pasos es posible crear servicios web basados en REST. Espero que te haya sido de utilidad. Comparte si te ha gustado!!"
    },

    {
        "id": 63,
        "autor": "Emmanuel Guzm√°n",
        "pagina": "oracle-max",
        "fecha": "21/03/2020",
        "titulo": "Creando un API REST con Java y Netbeans, que devuelva un json en su request",
        "link": "https://oracle-max.com/creando-un-api-rest-con-java-y-netbeans-que-devuelva-un-json-en-su-request/",
        "contenido": "En este laboratorio aprender√°s paso a paso, como crear un API Rest con Java en Netbeans, este a su vez devolver√° un json como respuesta a su request. Primero debemos crear un proyecto Maven Web Application: Luego en el source package crearemos un paquete al cual le llamar√© API, daremos click derecho en el paquete y buscaremos la siguiente opci√≥n: Seleccionamos Simple Root Resource En la siguiente pantalla debemos llenar lo siguientes campos seg√∫n corresponda: Path: nombre por el cual realizaremos la consulta a nuestro API. Class Name: nombre de la clase donde programaremos nuestra funci√≥n GET. MIME Type: Tipo de contenido que dar√° como respuesta nuestro API. Lo dem√°s quedar√° igual y presionamos Finish. Se nos crear√°n dos clases como las siguientes: Tenemos un m√©todo llamado getJson dentro de la clase ApipruebaResource, a este le cambiaremos el nombre a consultaPersona y le env√≠aremos 4 par√°metros usando la anotaci√≥n @QueryParam: Ahora crearemos un nuevo paquete llamado com.api.bean y dentro crearemos dos clases, una llamada Persona y otra llamada Telefono, las cuales tendr√°n lo siguiente: Clase Persona Clase Telefono Por √∫ltimo crearemos una clase m√°s llamada Json la cu√°l solamente le enviaremos el objeto persona. Clase Json Ahora nos devolvemos a la clase ApipruebaResource y crearemos nuestro objeto persona el cual convertiremos a json: Antes de continuar, debemos colocar la librer√≠a de gson en nuestro archivo pom.xml para poder usar la conversi√≥n a json: Luego regresamos a la clase ApipruebaResource y colocaremos el siguiente c√≥digo: De esta forma nuestro API Rest quedar√≠a terminada, por lo que debemos compilar y probar nuestra API Rest. Para probar nuestro API Rest lo podemos hacer de 2 maneras: Damos click derecho en la carpeta RESTful Web Services y seleccionamos Test RESTful Web Services: Se nos abrir√° la siguiente pantalla donde lo probaremos: 2. La segunda forma de probarlo es por medio de un url en un navegador, para ello deberemos enviar el siguiente url, el puerto puede variar seg√∫n la configuraci√≥n de su servidor web: http://localhost:8080/APIrestJava/webresources/apiprueba?cedula=12345&nombre=Emmanuel+Guzman&telefono=88888888&operador=Movistar De esta manera hemos logrado crear un API Restful que nos devuelva un json como respuesta, si lo vemos formateado en json queda as√≠: { persona : { cedula :  12345 , nombre :  Emmanuel Guzman , telefono : { telefono :  88888888 , operador :  Movistar } } } Luego de esto ya queda a nuestra creatividad la cantidad de contenedores que queramos crear en el json, sus respectivos atributos y la l√≥gica detr√°s a implementar para responder el request."
    },

    {
        "id": 64,
        "autor": "nigmacode",
        "pagina": "nigmacode",
        "fecha": "01/01/2020",
        "titulo": "Crear API REST con Spring",
        "link": "https://www.nigmacode.com/java/crear-api-rest-con-spring/",
        "contenido": "En este art√≠culo, crearemos una API REST con el framework Spring, el framework m√°s utilizado para la plataforma Java. Para ello, utilizaremos Spring boot que nos facilitar√° su configuraci√≥n (uso de dependencias, conexi√≥n con la base de datos, despliegue de servidor, etc). Debemos tener instalado Java, Maven en nuestro PC y como entorno de desarrollo utilizaremos Eclipse. Creando proyecto con SpringBoot Como hemos comentado, utilizaremos Springboot, que es una de las tecnolog√≠as dentro del mundo de spring, que nos facilita el desarrollo de aplicaciones con este framework, ya que nos facilita el trabajo con de las dependencias (Maven/Grandle), del despliegue del servidor, ya que nos provee de uno (a parte de mucha otra configuraci√≥n). Para comenzar, nos dirigimos a la p√°gina https://start.spring.io/ d√≥nde descargaremos nuestro proyecto: Project: En la primera opci√≥n, elegimos si queremos trabajar con maven o gradle, en este ejemplo, utilizaremos Maven. Language: En la segunda opci√≥n, elegimos con que lenguaje trabajar, Java. Springboot: En esta opci√≥n, elegimos la versi√≥n que queremos utilizar, en este caso 2.1.5 Project Metadata: El nombre de nuestro proyecto. Dependencies: En el buscador de dependecias, buscaremos y a√±adiremos WEB para crear nuestra API REST. Daremos click sobre el bot√≥n Generate the project, comenzar√° la descarga y una vez descargado lo descomprimiremos. Incluyendo proyecto Spring boot en Eclipse Ahora importaremos nuestro proyecto spring boot en Eclipse, para ello, iremos a la barra de eclipse e iremos a file/import/Maven/Existing Maven Porjects y daremos a browse, d√≥nde buscaremos el proyecto que acabamos de descargar, nos fijamos en que este el check que nos aparecer√° del pom.xml marcado y daremos a next. Nuestro proyecto ya aparecer√° en eclipse y comenzar√° a descargar las dependencias de su archivo pom.xml. Configurando spring boot Dependencias Para aprender a a√±adir nuevas dependencias en nuestro proyecto, vamos a dirigirnos a pom.xml, que se encuentra en la raiz de nuestro proyecto, ah√≠ nos aparecer√°n las dependencias que se han agregado al a√±adirle en spring init la dependencia WEB. En este archivo, en el apartado de dependencias, vamos a a√±adir debajo de las que ya tenemos, tres m√°s, una ser√° para trabajar con JPA, otra para conectarnos a nuestra base mysql y otra para que refresque el servidor cada vez que haya alg√∫n cambio: <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>2.1.5.RELEASE</version> <relativePath/> <!-- lookup parent from repository --> </parent> <groupId>com.jlguisado.webjob</groupId> <artifactId>api</artifactId> <version>0.0.1-SNAPSHOT</version> <name>api</name> <description>Demo project for Spring Boot</description> <properties> <java.version>1.8</java.version> </properties> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-data-jpa</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-devtools</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <scope>runtime</scope> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> </dependencies> <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> </project> Una vez hecho esto, actualizaremos nuestro proyecto con estas nuevas dependencias, haciendo click derecho sobre su carpeta, maven/update project. Base de datos En este ejemplo, estoy utilizando xampp para trabajar con la base de datos que he llamado api y una tabla llamada user que tiene la siguiente estructura: Una vez creada nuestra base de datos y su tabla user, vamos a volver a nuestro proyecto spring y nos dirigimos al archivo application.properties, que se encuentra en src/main/resources e indicaremos la ruta de la base de datos, su usuario y contrase√±a: # # JDBC Properties # spring.datasource.url = jdbc:mysql://localhost:3306/api?useUnicode=true&useJDBCCompliantTimezoneShift=true&useLegacyDatetimeCode=false&serverTimezone=UTC #direccion de la base de datos, puede variar el puerto y nombre de la bd spring.datasource.username=root #usuario que utilizas en la bd spring.datasource.password=root #contrase√±a que utilizas en la bd Una vez hecho esto, ya estar√≠amos listo para crear nuestra API REST. Creando API REST con Spring boot Para comenzar, os mostrar√© el carpetado que va a tener nuestro API REST, tendr√©is que crear estos paquetes con estas clases: ApiApplication.java Es la clase que arranca nuestra aplicaci√≥n springboot, dando click derecho sobre la clase y run as application: package com.nigmacode.apirest; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class ApiApplication { public static void main(String[] args) { SpringApplication.run(ApiApplication.class, args); } } Paquete entity En este paquete tenemos nuestro clase User.java y utilizaremos las @anotaciones JPA para relacionarla con nuestra tabla user, quedar√≠a de la siguiente forma: package com.nigmacode.apirest.entity; import java.util.Date; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; import org.hibernate.annotations.CreationTimestamp; import org.hibernate.annotations.UpdateTimestamp; @Entity @Table(name= user ) public class User { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name= id ) private int id; @Column(name= email ) private String email; @Column(name= password ) private String password; @Column(name= created_at ) @CreationTimestamp private Date createdAt; @Column(name= updated_at ) @UpdateTimestamp private Date updatedAt; public User() {} public User(int id, String email, String password) { this.id = id; this.email = email; this.password = password; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public Date getCreatedAt() { return createdAt; } public void setCreatedAt(Date createdAt) { this.createdAt = createdAt; } public Date getUpdatedAt() { return updatedAt; } public void setUpdatedAt(Date updatedAt) { this.updatedAt = updatedAt; } @Override public String toString() { return  User [id=  + id +  , email=  + email +  , password=  + password +  , createdAt=  + createdAt +  , updatedAt=  + updatedAt +  ] ; } } Paquete DAO En UserDAO, crearemos los m√©todos que utilizar√° la clase UserDAOimpl, para conectarse con nuestra base de datos. Interfaz userDAO: package com.nigmacode.apirest.dao; import java.util.List; import com.nigmacode.apirest.entity.User; public interface UserDAO { public List<User> findAll(); public User findById(int id); public void save(User user); public void deleteById(int id); } En nuestra clase UserDAOImpl, implementamos la interfaz, le a√±adiremos la anotaci√≥n @Repository que indica que es un DAO,y mediante la anotaci√≥n @Autowired inyectaremos EntityManager, que lo utilizaremos para crear una sessi√≥n y poder enviar las peticiones a la base de datos en cada m√©todo: package com.nigmacode.apirest.dao; import java.util.List; import javax.persistence.EntityManager; import org.hibernate.Session; import org.hibernate.query.Query; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Repository; import com.nigmacode.apirest.entity.User; @Repository public class UserDAOImpl implements UserDAO{ @Autowired private EntityManager entityManager; @Override public List<User> findAll() { Session currentSession = entityManager.unwrap(Session.class); Query<User> theQuery = currentSession.createQuery( from User , User.class); List<User> users = theQuery.getResultList(); return users; } @Override public User findById(int id) { Session currentSession = entityManager.unwrap(Session.class); User user = currentSession.get(User.class, id); return user; } @Override public void save(User user) { Session currentSession = entityManager.unwrap(Session.class); currentSession.saveOrUpdate(user); } @Override public void deleteById(int id) { Session currentSession = entityManager.unwrap(Session.class); Query<User> theQuery = currentSession.createQuery( delete from User where id=:idUser ); theQuery.setParameter( idUser , id); theQuery.executeUpdate(); } } Paquete Service Como en el paquete anterior tendremos una clase y una interface. El servicio ser√° el que har√° de interemediario entre el DAO y el controlador(La clase que gestionar√° las peticiones de la API que veremos m√°s adelante). La interfaz de service tendr√≠a esta estructura UserService.java: package com.nigmacode.apirest.service; import java.util.List; import com.nigmacode.apirest.entity.User; public interface UserService { public List<User> findAll(); public User findById(int id); public void save(User user); public void deleteById(int id); } Y la clase UserServiceImpl.java, ser√° implementada por la interfaz anterior. Le a√±adiremos la anotaci√≥n @Service, para indicar que es un servicio y tambi√©n de @Autowired para inyectar nuestro DAO y hacer uso de √©l: package com.nigmacode.apirest.service; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.nigmacode.apirest.dao.UserDAO; import com.nigmacode.apirest.entity.User; @Service public class UserServiceImpl implements UserService { @Autowired private UserDAO userDAO; @Override public List<User> findAll() { List<User> listUsers= userDAO.findAll(); return listUsers; } @Override public User findById(int id) { User user = userDAO.findById(id); return user; } @Override public void save(User user) { userDAO.save(user); } @Override public void deleteById(int id) { userDAO.deleteById(id); } } Paquete controller Por √∫ltimo, en el paquete controller tendremos la clase UserRestController.java que ser√° la encargada de gestionar las peticiones que se hagan a nuestra API, esta clase en m√°s extensa y ser√° explicada mediante comentarios en el siguiente c√≥digo: package com.nigmacode.apirest.controller; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.CrossOrigin; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.PutMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import com.nigmacode.apirest.entity.User; import com.nigmacode.apirest.service.UserService; //Indiciamos que es un controlador rest @RestController @RequestMapping( /api ) //esta sera la raiz de la url, es decir http://127.0.0.1:8080/api/ public class UserRestController { //Inyectamos el servicio para poder hacer uso de el @Autowired private UserService userService; /*Este m√©todo se har√° cuando por una petici√≥n GET (como indica la anotaci√≥n) se llame a la url http://127.0.0.1:8080/api/users*/ @GetMapping( /users ) public List<User> findAll(){ //retornar√° todos los usuarios return userService.findAll(); } /*Este m√©todo se har√° cuando por una petici√≥n GET (como indica la anotaci√≥n) se llame a la url + el id de un usuario http://127.0.0.1:8080/api/users/1*/ @GetMapping( /users/{userId} ) public User getUser(@PathVariable int userId){ User user = userService.findById(userId); if(user == null) { throw new RuntimeException( User id not found - +userId); } //retornar√° al usuario con id pasado en la url return user; } /*Este m√©todo se har√° cuando por una petici√≥n POST (como indica la anotaci√≥n) se llame a la url http://127.0.0.1:8080/api/users/  */ @PostMapping( /users ) public User addUser(@RequestBody User user) { user.setId(0); //Este metodo guardar√° al usuario enviado userService.save(user); return user; } /*Este m√©todo se har√° cuando por una petici√≥n PUT (como indica la anotaci√≥n) se llame a la url http://127.0.0.1:8080/api/users/  */ @PutMapping( /users ) public User updateUser(@RequestBody User user) { userService.save(user); //este metodo actualizar√° al usuario enviado return user; } /*Este m√©todo se har√° cuando por una petici√≥n DELETE (como indica la anotaci√≥n) se llame a la url + id del usuario http://127.0.0.1:8080/api/users/1  */ @DeleteMapping( users/{userId} ) public String deteteUser(@PathVariable int userId) { User user = userService.findById(userId); if(user == null) { throw new RuntimeException( User id not found - +userId); } userService.deleteById(userId); //Esto m√©todo, recibira el id de un usuario por URL y se borrar√° de la bd. return  Deleted user id -  +userId; } } Solucionar problema CORS en nuestra API Para que nuestra aplicaci√≥n no nos de problemas a la hora de utilizarla desde otra direcci√≥n, debemos configurarla para que no de error de CORS, para ello debemos seguir las intrucciones de nuestro art√≠culo üëâhttps://www.nigmacode.com/java/Solucionar-CORS-en-Spring De est√° forma, ya tendr√≠amos nuestra API REST con Spring boot lista, ya solo quedar√≠a levantar el servidor, como hemos dicho anteriormente, dando click derecho sobre ApiApplication.java y run as application"
    },

    {
        "id": 65,
        "autor": "Rosa",
        "pagina": "rosamarfil",
        "fecha": "05/05/2020",
        "titulo": "Crear una API REST Java con JAX-RS y Jersey",
        "link": "https://rosamarfil.es/tutoriales/programacion/crear-api-rest-java-jax-rs-jersey/",
        "contenido": "A continuaci√≥n, explicar√© c√≥mo crear una API REST Java con JAX-RS y Jersey. Usaremos los m√©todos comunes para publicar los servicios en nuestra m√°quina local. ¬øQu√© es JAX-RS? Java API for RESTful Web Services. Es una especificaci√≥n para crear Servicios Web REST que se basa en anotaciones para simplificar el desarrollo y despliegue de los clientes. ¬øQu√© es Jersey? Es un cliente RESTful e implementa JAX-RS. Facilita a los desarrolladores crear servicios web RESTful con Java. Las operaciones de un sistema REST y la especificaci√≥n HTTP son cuatro: GET (leer) POST (crear) PUT (editar) DELETE (eliminar) Lo primero que hay que hacer es crear un proyecto web din√°mico Java (mejor la √∫ltima versi√≥n Java JDK 1.8) y configurarlo para poder trabajar con Maven. Yo he utilizado Eclipse como entorno de desarrollo. Si tienes dudas en c√≥mo hacerlo, puedes consultar el tutorial Crear un proyecto web din√°mico. Modificar fichero pom.xml Introduciremos las dependencias en el fichero de configuraci√≥n de Maven. pom.xml <project xmlns= http://maven.apache.org/POM/4.0.0 xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>API_REST_WS-RS</groupId> <artifactId>API_REST_WS-RS</artifactId> <version>0.0.1-SNAPSHOT</version> <packaging>war</packaging> <build> <sourceDirectory>src</sourceDirectory> <plugins> <plugin> <artifactId>maven-compiler-plugin</artifactId> <version>3.8.0</version> <configuration> <source>1.8</source> <target>1.8</target> </configuration> </plugin> <plugin> <artifactId>maven-war-plugin</artifactId> <version>3.2.1</version> <configuration> <warSourceDirectory>WebContent</warSourceDirectory> </configuration> </plugin> </plugins> </build> <dependencies> <dependency> <groupId>javax.ws.rs</groupId> <artifactId>javax.ws.rs-api</artifactId> <version>2.1.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-<a href= https://rosamarfil.es/tutoriales/diccionario/servlet/  data-cmtooltip= Es una clase java que(...)  class= glossaryLink  >servlet</a></artifactId> <version>2.25.1</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.25.1</version> </dependency> </dependencies> </project> Crear el resto de clases User.java package es.rosamarfil.modelo; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } ServicioUsers.java package es.rosamarfil.services; import java.util.ArrayList; import java.util.List; import javax.ws.rs.BeanParam; import javax.ws.rs.Consumes; import javax.ws.rs.DELETE; import javax.ws.rs.GET; import javax.ws.rs.POST; import javax.ws.rs.PUT; import javax.ws.rs.Path; import javax.ws.rs.PathParam; import javax.ws.rs.Produces; import javax.ws.rs.client.Entity; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.Response; import javax.ws.rs.core.Response.Status; import es.rosamarfil.modelo.User; @Path( /users ) public class ServicioUsers { private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; /** * URL: http://localhost:8080/API_REST_WS-RS/api/users * @return Response list Users */ @GET @Produces(MediaType.APPLICATION_JSON) public Response getUsers() { return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/Rosa * * @param name String * @return Response */ @GET @Path( /{name} ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response getUserById(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/createUser Parameters in * Postman: { name : Rosa3333 , username : Marfi3333l } * * @param User * @return Response list NOTA: Si no existe el constructor vac√≠o de User, da un *         error y el userRequest viene null. */ @POST @Path( /createUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response createUser(User userRequest) { this.listaUsuarios.add(userRequest); //return Response.status(Status.CREATED).build(); return Response.ok(listaUsuarios).build(); } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/updateUser Parameters in * Postman: { name : Rosa , username : Marfil3333 } * * @param User * @return user modified NOTA: Si no existe el constructor vac√≠o de User, da un *         error y el userRequest viene null. */ @PUT @Path( /updateUser ) @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public Response updateUser(User userUpdate) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(userUpdate.getName())) { found = listaUsuarios.get(i); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { found.setUsername(userUpdate.getUsername()); return Response.ok(found).build(); } } /** * URL: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa * * @param User * @return Response */ @DELETE @Path( /deleteUser/{name} ) @Produces(MediaType.APPLICATION_JSON) public Response deleteUser(@PathParam( name ) String name) { User found = null; for (int i = 0; i < listaUsuarios.size(); i++) { if (listaUsuarios.get(i).getName().equalsIgnoreCase(name)) { found = listaUsuarios.get(i); listaUsuarios.remove(found); } } if (found == null) { return Response.status(Status.BAD_REQUEST).entity( User not found ).build(); } else { return Response.ok(listaUsuarios).build(); } } } Configuration.java package es.rosamarfil.services; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath( api ) public class Configuration extends Application { } Probar nuestros Servicios Lo primero es levantar la aplicaci√≥n. Para ello, selecciona el proyecto y ejec√∫talo sobre un servidor Apache previamente configurado. Si no sabes como configurarlo, puedes ver el tutorial Configurar Proyecto web y ver la secci√≥n A√±adir Servidor Apache Tomcat a Eclipse. Crear una API REST Java con JAX-RS y Jersey Una vez arrancado el servidor con nuestra aplicaci√≥n, podemos probar los servicios o bien desde la barra de direcciones de un navegador o desde alg√∫n programa cliente como Postman. La direcci√≥n base de nuestra aplicaci√≥n es: http://localhost:8080/API_REST_WS-RS Vamos a ver los par√°metros a introducir: GET (leer) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users GET (leer) a partir de un par√°metro. En este caso buscaremos un usuario por nombre. En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/Rosa POST (crear) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/createUser y en la secci√≥n Body, introduce un usuario en formato json, como se muestra en la imagen: Crear una API REST Java con JAX-RS y Jersey PUT (editar) En Postman, introduce: http://localhost:8080/API_REST_WS-RS/api/users/updateUser y en la secci√≥n Body de Postman introduce: {¬´name¬ª:¬ªRosa¬ª,¬ªusername¬ª:¬ªMarfil3333‚Ä≥} DELETE (eliminar) En la barra de direcciones introduce: http://localhost:8080/API_REST_WS-RS/api/users/deleteUser/Rosa Y esto es todo!! Esta es una forma sencilla para empezar a crear servicios REST JAVA y crear una API REST Java con JAX-RS y Jersey."
    },

    {
        "id": 66,
        "autor": "AWS",
        "pagina": "amazon",
        "fecha": "01/01/2021",
        "titulo": "Tutorial: Crear una API de REST importando un ejemplo",
        "link": "https://docs.aws.amazon.com/es_es/apigateway/latest/developerguide/api-gateway-create-api-from-example.html",
        "contenido": "Puede utilizar la consola de Amazon API Gateway para crear y probar una API REST sencilla con integraci√≥n HTTP para un sitio web PetStore. La definici√≥n de la API est√° preconfigurada como un archivo de OpenAPI 2.0. Despu√©s de cargar la definici√≥n de API en API Gateway, puede utilizar la consola de API Gateway para examinar la estructura b√°sica de API o simplemente implementar y probar la API. La API de ejemplo de PetStore admite los siguientes m√©todos para que un cliente obtenga acceso al sitio web de backend HTTP de http://petstore-demo-endpoint.execute-api.com/petstore/pets. GET /: para leer el acceso del recurso ra√≠z de la API que no se integra con ning√∫n punto de enlace de backend. API Gateway responde con informaci√≥n general del sitio web PetStore. Este es un ejemplo del tipo de integraci√≥n MOCK. GET /pets: para obtener acceso de lectura al recurso /pets de la API que se integra con el recurso /pets de backend asignado. El backend devuelve una p√°gina de mascotas disponibles en PetStore. Este es un ejemplo del tipo de integraci√≥n HTTP. La URL del punto de enlace de integraci√≥n es http://petstore-demo-endpoint.execute-api.com/petstore/pets. POST /pets: para obtener acceso de escritura al recurso /pets de la API que se integra con el recurso /petstore/pets de backend. Tras recibir una solicitud correcta, el backend agrega la mascota especificada a PetStore y devuelve el resultado al autor de la llamada. La integraci√≥n tambi√©n es HTTP. GET /pets/{petId}: para obtener acceso de lectura a una mascota identificada por un valor petId tal como se especifica en una ruta variable de la URL de solicitud de entrada. Este m√©todo tambi√©n tiene el tipo de integraci√≥n HTTP. El backend devuelve la mascota especificada que se encuentra en PetStore. La URL del punto de enlace HTTP del backend es http://petstore-demo-endpoint.execute-api.com/petstore/pets/n, donde n es un entero como identificador de la mascota consultada. La API admite el acceso a CORS a trav√©s de los m√©todos OPTIONS del tipo de integraci√≥n MOCK. API Gateway devuelve los encabezados solicitados que admiten el acceso a CORS. El siguiente procedimiento le guiar√° por los pasos para crear y probar una API a partir de un ejemplo mediante la consola de API Gateway. Para importar, desarrollar y probar la API de ejemplo Si a√∫n no lo ha hecho, realice los pasos de Requisitos previos para comenzar con API Gateway. Inicie sesi√≥n en la consola de API Gateway en https://console.aws.amazon.com/apigateway. Si es la primera vez que utiliza API Gateway, ver√° una p√°gina en la que aparecen las caracter√≠sticas del servicio. En REST API, elija Build (Compilaci√≥n). Cuando aparezca el men√∫ emergente Create Example API (Crear API de ejemplo), elija OK (Aceptar). Si esta no es la primera vez que utiliza API Gateway, elija Create API (Crear API). En REST API, elija Build (Compilaci√≥n). En Create new API (Crear nueva API), elija Example API (API de ejemplo) y, a continuaci√≥n, elija Import (Importar) para crear la API de ejemplo. Para la primera API, la consola de API Gateway comienza con esta opci√≥n de forma predeterminada. Puede desplazarse por la definici√≥n de OpenAPI para obtener informaci√≥n detallada sobre esta API de ejemplo antes de elegir Import (Importar). La API reci√©n creada se muestra de la siguiente forma: El panel Resources (Recursos) muestra la estructura de la API creada como un √°rbol de nodos. Los m√©todos de API definidos en cada recurso son los extremos del √°rbol. Cuando se selecciona un recurso, todos sus m√©todos se muestran en el panel Methods (M√©todos) situado a la derecha. Debajo de cada m√©todo hay un breve resumen del m√©todo, incluidos sus requisitos de URL de punto de enlace, tipo de autorizaci√≥n y clave de API. Para ver los detalles de un m√©todo, para modificar su configuraci√≥n o para probar la invocaci√≥n del m√©todo, elija el nombre del m√©todo en la lista de m√©todos o en el √°rbol de recursos. A continuaci√≥n, elegimos el POST /pets m√©todo como ejemplo: El panel resultante Method Execution (Ejecuci√≥n del m√©todo) presenta una vista l√≥gica de la estructura del m√©todo (POST /pets) elegida y los comportamientos: Method Request (Solicitud de m√©todo) y Method Response (Respuesta de m√©todo) son la interfaz de la API con el frontend de la API (un cliente), mientras que Integration Request (Solicitud de integraci√≥n) e Integration Response (Respuesta de integraci√≥n) son la interfaz de la API con el backend (http://petstore-demo-endpoint.execute-api.com/petstore/pets). Un cliente utiliza la API para obtener acceso a una caracter√≠stica del backend a trav√©s de Method Request (Solicitud de m√©todo). API Gateway traduce la solicitud del cliente, si fuera necesario, a un formato aceptable por el backend en Integration Request (Solicitud de integraci√≥n) antes de reenviar la solicitud entrante al backend. La solicitud transformada se conoce como la solicitud de integraci√≥n. Del mismo modo, el backend devuelve la respuesta a API Gateway en Integration Response (Respuesta de integraci√≥n). A continuaci√≥n, API Gateway la dirige a Method Response (Respuesta de m√©todo) antes de enviarla al cliente. De nuevo, si fuera necesario, API Gateway puede asignar los datos de la respuesta del backend a un formulario previsto por el cliente. En el caso del m√©todo POST de recurso de API, la carga de la solicitud del m√©todo puede transmitirse a trav√©s de la solicitud de integraci√≥n sin modificaci√≥n si la carga de la solicitud de m√©todo est√° en el mismo formato que la carga de la solicitud de integraci√≥n. La solicitud del m√©todo GET / usa el tipo de integraci√≥n MOCK y no est√° vinculada a ning√∫n punto de enlace de backend real. La Integration Response (Respuesta de integraci√≥n) correspondiente est√° configurada para devolver una p√°gina HTML est√°tica. Cuando se llama al m√©todo, API Gateway simplemente acepta la solicitud e inmediatamente devuelve la respuesta a la integraci√≥n configurada al cliente a trav√©s de Method Response (M√©todo de respuesta). Puede utilizar la integraci√≥n simulada para probar una API sin requerir un punto de enlace del backend. Tambi√©n puede utilizarla para servir una respuesta local generada partir de una plantilla de asignaci√≥n de cuerpo de respuesta. Como desarrollador de la API, puede controlar los comportamientos de las interacciones del frontend de la API mediante la configuraci√≥n de la solicitud de m√©todo y una respuesta de m√©todo. Puede controlar los comportamientos de las interacciones del backend de la API mediante la configuraci√≥n de la solicitud de integraci√≥n y la respuesta de integraci√≥n. Estos comportamientos implican asignaciones de datos entre un m√©todo y su integraci√≥n correspondiente. Explicaremos c√≥mo configurar un m√©todo en Tutorial: Desarrollo de una API de REST con integraci√≥n HTTP no de proxy. Por el momento, nos centraremos en probar la API para proporcionar una experiencia de usuario completa. Elija Test (Probar) en Client (Cliente) (tal y como se muestra en la imagen anterior) para comenzar la prueba. Por ejemplo, para probar el m√©todo POST /pets, escriba la siguiente carga { type :  dog , price : 249.99} en Request Body (Cuerpo de la solicitud) antes de elegir el bot√≥n Test (Probar). La entrada especifica los atributos de la mascota que deseamos a√±adir a la lista de mascotas en el sitio web PetStore. El resultado es el siguiente: La entrada Logs (Registros) de la salida muestra los cambios de estado de la solicitud del m√©todo a la solicitud de integraci√≥n y de la respuesta de integraci√≥n a la respuesta del m√©todo. Esto puede resultar √∫til para la resoluci√≥n de errores de asignaci√≥n que impidan que la solicitud se realice correctamente. En este ejemplo, la asignaci√≥n no se aplica: la carga de la solicitud de m√©todo se transfiere a trav√©s de la solicitud integraci√≥n al backend y, de forma parecida, la respuesta del backend se transfiere a trav√©s de la respuesta de integraci√≥n al m√©todo de respuesta. Para probar la API con un cliente distinto de la caracter√≠stica test-invoke-request de API Gateway, primero debe implementar la API en una etapa. Para implementar la API de ejemplo, seleccione la API PetStore y, a continuaci√≥n, elija Deploy API (Implementar API) en el men√∫ desplegable Actions (Acciones). En Deploy API (Implementar API), para Deployment stage (Etapa de implementaci√≥n), elija [New Stage] (Nueva etapa) porque esta es la primera implementaci√≥n de la API. Escriba un nombre (por ejemplo, test) en Stage name (Nombre de etapa) y, si lo desea, escriba las descripciones en Stage description (Descripci√≥n de etapa) y Deployment description (Descripci√≥n de implementaci√≥n). Elija Deploy (Implementar). En el panel Stage Editor (Editor de etapas) resultante, Invoke URL (URL de invocaci√≥n) muestra la direcci√≥n URL para invocar la solicitud del m√©todo GET / de la API. En Stage Editor (Editor de etapas), siga el enlace Invoke URL (URL de invocaci√≥n) para enviar la solicitud del m√©todo GET / en un navegador. Una respuesta correcta devuelve el resultado, generado a partir de la plantilla de asignaci√≥n de la respuesta de integraci√≥n. En el panel de navegaci√≥n Stages (Etapas), expanda la etapa test (prueba), seleccione GET en /pets/{petId} y, a continuaci√≥n, copie el valor Invoke URL (URL de invocaci√≥n) de https://api-id.execute-api.region.amazonaws.com/test/pets/{petId}. {petId} hace referencia a una variable de ruta. Pegue el valor de Invoke URL (URL de invocaci√≥n) (obtenido en el paso anterior) en la barra de direcciones de un navegador, sustituyendo {petId} por, por ejemplo, 1 y, a continuaci√≥n, pulse Intro para enviar la solicitud. Deber√≠a devolverse una respuesta 200 OK con la siguiente carga JSON: { id : 1, type :  dog , price : 249.99 } La invocaci√≥n del m√©todo de la API tal como se muestra es posible porque su tipo Authorization (Autorizaci√≥n) est√° establecido en NONE. Si se ha utilizado la autorizaci√≥n de AWS_IAM, firmar√≠a la solicitud con los protocolos Signature Version 4 (SigV4). Para ver un ejemplo de una solicitud de este tipo, consulte Tutorial: Desarrollo de una API de REST con integraci√≥n HTTP no de proxy."
    },

    {
        "id": 67,
        "autor": "Adrian Francisco Becerra Arias",
        "pagina": "soloenbinario",
        "fecha": "30/07/2019",
        "titulo": "Creando servicios REST con JAVA",
        "link": "https://soloenbinario.wordpress.com/2019/07/30/creando-servicios-rest-java/",
        "contenido": "Actualmente la gran mayor√≠a de aplicaciones cuentan con, por lo menos, un servicio WEB. En los √∫ltimos tiempos se ha popularizado una nueva forma de crear y consumir servicios llamado RESTful. Este tipo de servicios ha tenido una gran acogida por su f√°cil uso y tambi√©n por los tiempos de respuesta cuando se consumen estos. Dada esta peque√±a introducci√≥n vamos al grueso del asunto y para ello vamos a utilizar las siguientes herramientas: Eclipse 2018-09 o superior. Maven 3.5.4 Jersey 2.27 JAXB 2.3.1 Creando el servicio WEB Vamos a crear una aplicaci√≥n WEB y para ello escoge la opci√≥n haciendo clic derecho, New -> Other‚Ä¶ -> WEB -> Dynamic WEB Project. Selecciona la opci√≥n Next. Ahora dale un nombre a tu aplicaci√≥n WEB y selecciona la opci√≥n Next. En la siguiente pantalla no es necesario configurar nada por lo que puedes seleccionar la opci√≥n Next. En esta pantalla selecciona la opci√≥n Gen√©rate web.xml deployment descriptor. Es importante que lo selecciones porque en este archivo de configuraci√≥n vamos definir el API REST y tambi√©n cuales son las clases que se encargan de publicar los servicios que vamos a definir. Seleccionadas las opciones importantes, ahora selecciona la opci√≥n Finish. Configurando Maven Has clic derecho sobre tu aplicaci√≥n WEB recientemente creada y selecciona la opci√≥n Configure -> Convert to Maven Project‚Ä¶ En la ventana que aparece puedes configurar los datos que aparecen all√≠, te recomiendo que el packaging no lo modifiques. Luego, selecciona la opci√≥n Finish. Configuraci√≥n del POM Ahora vamos a realizar lo siguiente: Vamos a importar las dependencias necesarias para que los servicios WEB funcionen sin problemas, y vamos a configurar el nombre del servicio WEB. Las dependencias que te recomiendo para la configuraci√≥n de un servicio WEB RESTful son: Glassfish Jersey Core Server. Glassfish Jersey Containers Servlet. Glassfish Jersey Inject HK2. Glassfish Jersey Media JSON Jackson. JAXB. Estas dependencias las puedes encontrar en la pagina MVNRepository, sin embargo aqu√≠ te los dejo (Recuerda que el siguiente bloque debe ir despu√©s de la etiqueta <build></build>): <dependencies> <dependency> <groupId>org.glassfish.jersey.core</groupId> <artifactId>jersey-server</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.containers</groupId> <artifactId>jersey-container-servlet</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.inject</groupId> <artifactId>jersey-hk2</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.media</groupId> <artifactId>jersey-media-json-jackson</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> </dependencies> Creaci√≥n del servicio WEB Vamos ahora con la creaci√≥n de la clase y los m√©todos de consumo. Lo primero que vas a hacer es crear el package y luego vas a crear la clase que ser√° el servicio WEB como tal. Luego vamos a agregar algunas anotaciones para que nuestro API REST funcione. Para este ejercicio vamos a crear m√©todos de consumo de tipo GET y tipo POST que retornaran los siguiente: Datos de tipo String. Datos de tipo XML. Datos de tipo JSON. Objetos Objetos de tipo Response. Empecemos. Creada la clase vamos a agregarle encima del nombre de la misma la anotaci√≥n @Path. M√©todo que retorna un objeto de tipo String Dentro de la clase crea una m√©todo que retorne datos de tipo String. Cuando lo hayas creado, agr√©gale las anotaciones @GET, @Path y @Produces quedando de la siguiente manera: M√©todo que retorna informaci√≥n en formato XML Crea un m√©todo que retorne datos de tipo XML. Lo que vas a realizar a continuaci√≥n es crear un objeto que va a ser retornado por el m√©todo en cuesti√≥n. Este objeto debe tener lo siguiente para que el API REST lo transforme a XML: Anotaciones JAXB. Un constructor vac√≠o. En ese orden de ideas, crea tu clase la cual deber√° quedar como el siguiente ejemplo: Cuando hayas creado el objeto, crea tu m√©todo y agrega las anotaciones @GET, @Path, @Produces y dentro de esta √∫ltima anotaci√≥n agrega el MediaType APPLICATION_XML quedando de la siguiente manera: M√©todo que retorna informaci√≥n en formato JSON Crea un m√©todo que retorne datos en formato JSON. La creaci√≥n es bastante similar al m√©todo que retorna datos en formato XML, lo √∫nico que cambia es el tipo de MediaType que es APPLICATION_JSON. Entonces, el resultado deber√° ser el siguiente: M√©todo con paso de par√°metros mediante PathParam Crea un m√©todo que va a recibir un par√°metro por la URL. En este caso ser√° un par√°metro que reciba uno o varios argumentos y por cada argumento tienes que anteceder la anotaci√≥n @PathParam([nombre_parametro]) donde nombre_parametro ser√° el alias del par√°metro que debe ser parte de la URI, as√≠: Como te coment√©, en la anotaci√≥n @PathParam colocamos el alias p. Si te das cuenta este alias aparece como parte de la URI dentro de la anotaci√≥n @Path. Entonces, cuando realices el consumo del servicio WEB lo que debe ir en {p} es el dato que vas a pasar al m√©todo del servicio REST. M√©todo con paso de par√°metros mediante QueryParam Un m√©todo con paso de par√°metros mediante QueryParam ser√≠a, por ejemplo, http://localhost:8080/SampleREST/rest/WebServiceRest/bienvenida/json_qp?p=dato. De este modo, crea un m√©todo que retorne un objeto y que este sea retornado en formato JSON y luego agr√©gale la cantidad de argumentos que necesites pasarle. A cada uno de ellos debes anteponerle la anotaci√≥n @QueryParam que entre par√©ntesis debe ir el nombre del par√°metro que ser√° enviado por Query String. Es decir, que en la URL que mencion√© anteriormente estamos enviando un dato a la variable p, en la anotaci√≥n @QueryParam debe ir el dato llamado p, quedando de la siguiente manera: M√©todo POST En la creaci√≥n de m√©todos POST las variaciones con respecto a un m√©todo de tipo GET son que, debemos decirle qu√© tipo de informaci√≥n va a consumir, el tipo de informaci√≥n que va a producir y el retorno ser√° un dato de tipo Response. En este orden de ideas cr√©ate un m√©todo con la anotaci√≥n @POST y la anotaci√≥n @Consumes la cual va a aceptar datos en formato JSON. Como par√°metros al m√©todo puedes pasarle un objeto y el dato de retorno un objeto de tipo Response. De resto las anotaciones @Path y @Produces siempre van a ser las m√°s comunes en todos los m√©todos de un servicio REST. El m√©todo deber√≠a quedar como este: Creando un cliente para el consumo de los servicios Con pocas l√≠neas de c√≥digo se pueden crear clientes de consumo de servicios WEB REST en JAVA. Vamos a crear un cliente en JAVA SE para que veas el funcionamiento. Creando el proyecto En Eclipse, haz clic derecho y selecciona la opci√≥n New -> Other‚Ä¶ Selecciona la opci√≥n Java Project. Ahora selecciona un nombre para tu nuevo cliente REST y luego selecciona la opci√≥n Finish. Una vez se haya terminado la creaci√≥n del cliente, has clic derecho en √©l y selecciona la opci√≥n Configure -> Convert to Maven Project. En la nueva ventana que aparece, lo puedes dejar como lo sugiere el asistente y presionas la opci√≥n Finish. Las dependencias que puede usar para la creaci√≥n de los m√©todos cliente son: <dependencies> <dependency> <groupId>org.glassfish.jersey.core</groupId> <artifactId>jersey-client</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>org.glassfish.jersey.inject</groupId> <artifactId>jersey-hk2</artifactId> <version>2.27</version> </dependency> <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.1</version> </dependency> <dependency> <groupId>com.googlecode.json-simple</groupId> <artifactId>json-simple</artifactId> <version>1.1.1</version> </dependency> </dependencies> Creaci√≥n de la clase cliente En la carpeta src has clic derecho y selecciona la opci√≥n New -> Class. En la nueva ventana que aparece selecciona un paquete y luego Escribe el nombre de la clase. Si el paquete que escribiste no existe, no hay problema. El asistente lo crea autom√°ticamente. Ahora Selecciona la opci√≥n Finish. Ahora vamos a crear los siguientes m√©todos que van a consumir cada uno de las funciones que creamos para el servicio REST. Haciendo recuento, los m√©todos son: M√©todo para retornar datos de tipo String. M√©todo para retornar datos de tipo XML. M√©todo para retornar datos de tipo JSON. M√©todo para retornar objetos de tipo Response. Y los tipos de consumo son: Get Post QueryParam PathParam Declarando las instancias para el consumo del servicio Empieza con crear una instancia de tipo Client. como aparece a continuaci√≥n: Como puedes observar en la imagen anterior, puedes crear una instancia para toda la clase o bien puedes crear la instancia en cada m√©todo donde la vayas a utilizar. La elecci√≥n es tuya. Consumiendo datos de tipo XML, JSON y String ¬øPor qu√© este apartado abarca tres tipos de datos diferentes? Resulta que lo que vas a ver a continuaci√≥n es el consumo de servicios de datos de tipo String, JSON y XML con las mismas l√≠neas de c√≥digo. Es decir que lo √∫nico que cambia son los tipos de retorno y las URIs de los servicios WEB. As√≠ pues esta son las l√≠neas de c√≥digo que deber√≠as usar para consumir los servicios retornando datos String, XML y JSON: En esta instancias lo que debes cambiar para este ejemplo es el target, el request, el accept y el get. En conclusi√≥n los m√©todos quedar√≠an construidos de la siguiente manera: Consumiendo m√©todos Path Param El consumo de este tipo de servicios es muy similar al que vimos para consumir datos de tipo String, JSON y XML. Lo √∫nico que debemos agregar es el m√©todo path() despu√©s del m√©todo target() donde va la URI a consumir, quedando de la siguiente manera: Consumiendo m√©todos Query Param Exactamente igual que consumir m√©todos de tipo Path Param, as√≠ son los que se pasan datos por Query String. Despu√©s del m√©todo target() agrega el m√©todo queryParam() en el cual el primer argumento es el nombre de la variable Query String y en el segundo argumento colocas el valor para la variable. Recuerda que el nombre de la variable debe ser exactamente igual al que definiste en el m√©todo del servicio WEB. As√≠ quedar√≠a: Consumiendo m√©todos POST Quiz√° este puede ser el m√©todo al cual toca agregarla un poco mas de l√≠neas de c√≥digo. Pero a la final es un c√≥digo bastante sencillo de digerir. Como te puedes dar cuenta se necesita crear lo siguiente: Crear una nueva instancia del objeto que vas a enviar. Luego creamos una instancia de tipo Client. Crear una instancia de tipo WebTarget la cual va a recibir la URI del m√©todo del servicio a consumir. Crear una instancia de tipo Builder en la cual vamos a solicitar que el servicio nos retorne la informaci√≥n en formato JSON. Crear una instancia de tipo Response en donde vamos a pasar como par√°metro el objeto que instanciaste en el punto No . 1. Como pudiste observar, entender y practicar a lo largo de este POST, la creaci√≥n de servicios WEB REST es bastante sencilla por lo cual a futuro no tendr√°s tanto problema cuando empieces a crearlos en forma. Espero que este contenido haya sido de gran ayuda para ti. El c√≥digo fuente de estos ejercicios los puedes encontrar en los siguientes enlaces: Servicio REST: https://github.com/elle184/ScriptsJAVA/tree/master/SampleREST Cliente del servicio REST: https://github.com/elle184/ScriptsJAVA/tree/master/SampleRestClient"
    },

    {
        "id": 68,
        "autor": "Csacanam",
        "pagina": "platzi",
        "fecha": "01/02/2015",
        "titulo": "C√≥mo crear un API con Spark Java",
        "link": "https://platzi.com/blog/api-spark-java/",
        "contenido": "No es un secreto que el enfoque de Java hacia las aplicaciones web empresariales ha generado opiniones encontradas. Por una parte, Java EE es una arquitectura ideal para hacer aplicaciones de ese tipo, pues el servidor provee caracter√≠sticas importantes como la seguridad; sin que el desarrollador deba preocuparse por eso. Sin embargo, esto tambi√©n provoca que sea m√°s complicado desarrollar proyectos m√°s livianos;  pues se requiere de varias configuraciones para lograr hacerlo funcionar. Por esta raz√≥n, han surgido varias iniciativas para evitar que la popularidad de Java en la web disminuya. Actualmente, ocupa el tercer lugar en popularidad de lenguajes del lado del servidor. Por debajo de PHP y ASP .NET y por encima de lenguajes como Python y Ruby. Esas iniciativas no apuntan a que se deje de lado a Java EE; sino que buscan solucionar las necesidades de los nichos de las aplicaciones web empresariales. Por otro lado, tambi√©n surgieron otras que buscan solucionar necesidades menos exigentes de una forma m√°s √°gil; y ese es el caso del framework Spark Java. Se trata de un framework web liviano inspirado en Sinatra (framework basado en Ruby), que permite crear aplicaciones web con Java 8 con el m√≠nimo esfuerzo. El objetivo principal de este art√≠culo es introducir el framework y crear una soluci√≥n sencilla que te permita entender c√≥mo podr√≠as hacer uso del mismo. Para poder seguir el tutorial es necesario que tengas instalado el Java Development Kit 8 (JDK 8). Se puede instalar en Windows, Mac o Linux y descargar en la p√°gina oficial de Oracle. Adicionalmente, requerir√°s de un entorno de desarrollo (IDE) para Java que te permita crear un proyecto de Maven. Puedes hacer uso de Eclipse, IntelliJ o NetBeans. En mi caso, voy a hacer uso de la versi√≥n 8.0.2 de NetBeans para Java EE. Y si est√°s iniciando en el desarrollo de aplicaciones con este lenguaje, no te puedes perder el curso gratuito de Java B√°sico en Platzi. Aprender√°s todo lo que necesitas saber para crear proyectos desde cero. ¬øQu√© es Spark? Es un micro framework web de Java basado en Sinatra, cuyo tama√±o total no excede 1 MB. Para poder mantener un c√≥digo limpio, los desarrolladores decidieron dejar de soportar Java 7 y aprovechar la simplicidad que ofrece Java 8. Por esta raz√≥n, en Spark 2 s√≥lo se puede desarrollar con esta versi√≥n del lenguaje. En las im√°genes abajo puedes observar el cambio que hubo en el Hello World de Spark 1 a Spark 2. Hello World en Spark 1 API Spark Java Hello World en Spark 2 API Spark Java ¬øPara qu√© se usa Spark? Aunque Spark est√° basado en Sinatra, no se presenta como una competencia. Su finalidad es que haya una alternativa para los desarrolladores Java, que les permita desarrollar r√°pidamente aplicaciones web con el lenguaje que ya conocen. Seg√∫n una encuesta que realiz√≥ el equipo de Spark este a√±o, se dio a conocer que alrededor del 50% de los usuarios de Spark lo usan para crear APIs REST y un 25% lo usa para crear p√°ginas web. Tambi√©n mencionan que el 15% de las aplicaciones Spark desplegadas sirven a m√°s de 10.000 usuarios a diario. Con estos datos podemos concluir que es un framework adecuado si la finalidad es construir un API con Java de forma √°gil. Creando un Hello World Despu√©s de haber instalado el JDK 8 y Netbeans para Java EE, abriremos el √∫ltimo y crearemos un nuevo proyecto File > New project. En el di√°logo seleccionamos la carpeta Maven y elegimos Java Application. A continuaci√≥n seleccionamos la opci√≥n Next. API Spark Java En el siguiente di√°logo ingresamos el nombre del proyecto y damos clic en Finish. API Spark Java De esta manera, NetBeans crear√° un proyecto con la estructura de un proyecto Maven. Los elementos sobre los que trabajaremos ser√°n el paquete ubicado en Source Packages y el archivo pom.xml  ubicado en Project Files. API Spark Java Si abrimos el archivo pom.xml encontraremos un contenido parecido al siguiente: [java] <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>com.peewah</groupId> <artifactId>holaplatzi</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <maven.compiler.source>1.7</maven.compiler.source> <maven.compiler.target>1.7</maven.compiler.target> </properties> </project> [/java] Lo que debemos hacer a continuaci√≥n es agregar la dependencia de Spark al archivo para que Maven lo instale en el proyecto. Nuestro archivo pom.xml quedar√≠a as√≠: [java] <?xml version= 1.0  encoding= UTF-8 ?> <project xmlns= http://maven.apache.org/POM/4.0.0  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xsi:schemaLocation= http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd > <modelVersion>4.0.0</modelVersion> <groupId>com.peewah</groupId> <artifactId>holaplatzi</artifactId> <version>1.0-SNAPSHOT</version> <packaging>jar</packaging> <properties> <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding> <maven.compiler.source>1.7</maven.compiler.source> <maven.compiler.target>1.7</maven.compiler.target> </properties> <!-- Dependencias de Maven --> <dependencies> <!-- Dependencia Spark Java --> <dependency> <groupId>com.sparkjava</groupId> <artifactId>spark-core</artifactId> <version>2.3</version> </dependency> </dependencies> </project> [/java] Para que Maven instale la librer√≠a, debemos dar clic derecho sobre el proyecto y seleccionar la opci√≥n Build. Al terminar la compilaci√≥n, nuestro proyecto tendr√° instalado Spark Java. Ahora que ya configuramos lo necesario para agregar Spark Java al proyecto, vamos a escribir el c√≥digo necesario. Para lograrlo damos clic derecho sobre el paquete en Source Packages, seleccionamos New y luego Other. API Spark Java En el di√°logo seleccionamos la carpeta Java; elegimos Java Class y damos click en Next. API Spark Java En el siguiente di√°logo escribimos el nombre de nuestra clase, HolaPlatzi en este caso, y seleccionamos Finish. API Spark Java NetBeans nos crea nuestra clase y la coloca dentro del paquete que hemos creado previamente. El c√≥digo inicial debe ser algo as√≠: [java] package com.peewah.holaplatzi; /** * * @author csacanam */ public class HolaPlatzi { } [/java] A continuaci√≥n, agregaremos el c√≥digo necesario para crear un servicio web de tipo GET que retorne un mensaje que podremos observar en el navegador. Para lograrlo debemos crear el m√©todo main, que es el punto de entrada en una aplicaci√≥n Java. Dentro de main se agrega el servicio web de tipo GET. En la l√≠nea de c√≥digo donde lo definimos, es necesario especificar el tipo, la ruta (/hello), los par√°metros req (request) y response (res) y por √∫ltimo, el mensaje que se va a mostrar en el navegador. As√≠, la clase que creamos anteriormente debe quedar as√≠: [java] package com.peewah.holaplatzi; import static spark.Spark.*; /** * * @author csacanam */ public class HolaPlatzi { public static void main(String[] args) { get( /hello , (req, res) ->  Hola Platzi. Saludos desde Peewah. ); } } [/java] Si NetBeans indica que hay un error por las expresiones lambda, debemos dar clic derecho sobre el proyecto y seleccionar Properties. En la categor√≠a Sources debemos cambiar la opci√≥n Source/Binary Format a 1.8. Esto s√≥lo estar√° disponible si hemos instalado previamente el JDK 8. Para ejecutar el proyecto, elegimos la opci√≥n correr proyecto en el bot√≥n verde en la parte superior o presionamos F6. Al hacer esto, se abrir√° un di√°logo donde se indicar√° que seleccionemos la clase principal (hasta el momento solamente tenemos creada una). Despu√©s de esto, presionamos la opci√≥n Select Main Class. API Spark Java Despu√©s de unos cuantos segundos la consola nos muestra un mensaje similar al mostrado a continuaci√≥n, indicando que el servidor est√° corriendo por el puerto 4567. Este es el puerto por defecto de Spark Java. Sin embargo, podemos modificarlo si as√≠ lo deseamos. API Spark Java Para probar que nuestro servicio web est√° funcionando, abrimos nuestro navegador de preferencia y ponemos la direcci√≥n http://localhost:4567/hello. El resultado del navegador deber√° mostrar algo as√≠: API Spark Java Y as√≠ es como logramos crear de forma sencilla y r√°pida un servicio web con Spark Java que retorna un mensaje de saludo. Si te interesa saber m√°s y conocer el potencial de este framework web y, adem√°s, aprender a escribir y leer c√≥digo en Java, buenas pr√°cticas de programaci√≥n, paradigma de orientaci√≥n a objetos y todos los elementos que necesitas para programar desde cero;"
    },

    {
        "id": 69,
        "autor": "Javi Moreno",
        "pagina": "programar",
        "fecha": "18/12/2016",
        "titulo": "C√≥mo Crear Una API REST",
        "link": "https://programar.cloud/post/como-crear-un-api-rest/",
        "contenido": "Vamos a ponernos el gorrito de un miembro del equipo, en concreto la persona que se haya asignado la tarea de implementar la historia de usuario PROGRESO_CURSOS. ¬øLa recuerdas del post anterior ? Dec√≠a algo as√≠: Como administrador de cursos deseo poder obtener una visualizaci√≥n global de la utilizaci√≥n de cada curso y unidad did√°ctica para conocer su popularidad y actuar en consecuencia.* Bien, manos a la obra: tendremos que detectar los recursos a manipular, definir unas rutas HTTP claras para invocar operaciones sobre ellos y generar la respuesta deseada. No problem. O s√≠. ¬°Ojo! Para que no haya confusiones entre el rol √°gil de product owner y el cargo que ostenta el cliente para el que desarrollamos la aplicaci√≥n (descrito tambi√©n como propietaro del producto originalmente pero que no siempre tiene por qu√© coincidir) he cambido el nombre de este √∫ltimo a un mucho m√°s l√≥gico administrador de cursos. Mil perdones, esta noche me pego unos latigazos. Umh‚Ä¶ Vale, ya podemos seguir. Fundada en 1880source: imgur.com Los Recursos En la Wikipedia tienes una buena descripci√≥n sobre REST, no voy a repetirte lo que hay all√≠: mi plan es ir cont√°ndote los detalles que hagan falta en el momento en el que los necesites, no adelantarlos todos para despu√©s aplicarlos. Es como a m√≠ me gusta aprender. Pero si prefieres hacerte una idea de lo que vamos a hablar antes de seguir no te cortes y visita el link antes de continuar leyendo. Tampoco te preocupes si tu programaci√≥n est√° un poco oxidada, ver√°s que no hago mucho hincapi√© en ese aspecto en este post. Lo primero que tenemos que tener claro es que REST se estructura alrededor de recursos, las entidades que permites manipular. Esas entidades deben quedar representadas en la URL (la ruta) que se utiliza para ejecutar operaciones sobre ellas. As√≠ que el primer paso es definir la lista de recursos y para ello vamos a echar un vistazo a la historia de usuario. El administrador de cursos, claramente, es un actor involucrado que en el fondo corresponder√° a un tipo de usuario. No va a tener un papel relevante m√°s all√° de la autorizaci√≥n: qu√© operaciones puede invocar y a qu√© informaci√≥n tiene acceso. As√≠ que de momento aparcamos su implementaci√≥n. Esto generar√° una nueva tarea que consistir√° en integrar el sistema de permisos en la funcionalidad que implementemos ahora mismo pero ya la llevaremos a cabo m√°s tarde. Lo comentamos con el resto del equipo, apuntan la nueva tarea y pasamos al siguiente paso. F√≠jate en algo importante: hemos pedido una aclaraci√≥n. Qu√© loco. Durante el desarrollo. Seguimos revisando la historia de usuario. ¬°Encontramos otro sustantivo: curso! Claramente aqu√≠ tenemos nuestro primer recurso. Preguntamos al product owner y nos comenta que un curso b√°sicamente ahora mismo est√° definido por un c√≥digo alfanum√©rico √∫nico e inmutable, un t√≠tulo en espa√±ol, una descripci√≥n de unas 100 palabras y una serie de unidades did√°cticas. F√≠jate en algo importante: hemos pedido una aclaraci√≥n. Qu√© loco. Durante el desarrollo. M√°s te vale que sea posible llevar a cabo esta acci√≥n de la manera m√°s eficiente posible si no quieres acabar como yo en ese horrible proyecto . De la historias de usuario y de la √∫ltima conversaci√≥n detectamos que existe otro recurso llamado unidad did√°ctica. De nuevo el product owner nos explica que cada una de ellas tiene un n√∫mero de orden (no consecutivo e inmutable) y un t√≠tulo. Usando el c√≥digo es posible generar el link al post que en el fondo la implementa. El product owner nos dice que simplemente quiere saber cu√°nta gente ha participado activamente en cada uno de los cursos y en cada una de las unidades did√°cticas y que ello puede saberse contando cu√°ntas personas han cambiado el estado de una unidad a ‚Äúcompletado‚Äù. As√≠ que ya tenemos nuestra lista inicial de recursos: curso y unidad-didactica. Adem√°s hay una relaci√≥n jer√°rquica clar√≠sima entre ellos: un curso est√° compuesto de unidades did√°cticas. Compartimos esta informaci√≥n con el resto del equipo que no ha estado presente en la conversaci√≥n porque est√° claro que les har√° falta y no queremos que nuestro product owner nos odie m√°s de lo imprescindible por preguntarle diez veces lo mismo. Las Operaciones ¬°Son consultas, est√° bastante claro! En concreto confirmamos con el product owner que est√° interesado en poder visualizar datos del n√∫mero de estudiantes que han participado en cada curso y tambi√©n quiere ver el n√∫mero de estudiantes que han participado en cada lecci√≥n de un curso concreto entre un rango de fechas determinado. La aclaraci√≥n no es muy diferente de lo que nos hab√≠a comentado en la reuni√≥n de planificaci√≥n as√≠ que decidimos que podemos implementarlo. Pero no tiene por qu√© ser as√≠: si el trabajo de planificaci√≥n fue pobre y fallamos en describir correctamente la tarea resulta imposible estimar su duraci√≥n correctamente. En ese caso la mejor opci√≥n es siempre crear nuevas tareas con los detalles extra que no se puedan asumir en este sprint y dejarlos pendientes para el siguiente. Si implementar el filtro hubiese supuesto mucho trabajo eso es exactamente lo que habr√≠amos hecho. Y ¬øsabes una cosa que a m√≠ me sigue costando pero que poco a poco voy aprendiendo? S√≠, exacto: a decir NO. Y es cr√≠tico hacerlo cuando est√°s en este tipo de desarrollo y se propone un cambio de funcionalides importante porque te has comprometido a muy corto plazo para completar una serie de tareas. Si tienes problemas enfrent√°ndote a las peticiones del product owner, avisa al scrum master: sus responsabilidades incluyen adem√°s de hacer caf√©s el mantener la din√°mica del sprint y (si es necesario) controlar las peticiones del product owner. grumpy cat dice NO.source: imgur.com Bien, volvamos a las operaciones. Vamos a definir rutas que tengan cierta sem√°ntica y utilizaremos el plural para representar el recurso (en serio, hazlo, todo queda m√°s natural). Recuerda (por lo que has le√≠do en la Wikipedia) que en REST nos vamos a esforzar en utilizar la sem√°ntica original del protocolo HTTP para describir qu√© queremos hacer sobre esos recursos. Si repasas la RFC de HTTP (no, en serio, hazlo, que es s√∫per legible y sencilla) ver√°s que para obtener un documento debe usarse el m√©todo GET. Tambi√©n vamos a tomar la convenci√≥n de que si una parte de la ruta es variable (para especificar un subconjunto del total de recursos) colocaremos su identificador entre llaves. Digamos que definimos estas operaciones: GET /cursos GET /cursos/{codigo}/unidades-didacticas La primera nos retornar√° la informaci√≥n de todos los cursos y la segunda informaci√≥n sobre las unidades did√°cticas de un curso concreto. Un ejemplo de la segunda URL en la que se ha aplicado un valor a la parte variable ser√≠a: /cursos/introduccion/unidades-didacticas indicando que quieres conocer los datos de las unidades did√°cticas del curso con el c√≥digo introduccion. As√≠ que ¬øqu√© te parece esta primera aproximaci√≥n? Exacto: posiblemente nos hemos venido arriba. La primera ruta representa todos los cursos con lo que sem√°nticamente ser√≠a perfectamente aceptable devolver todos los datos asociados a los mismos. Esto incluir√≠a el n√∫mero de alumnos inscritos pero tambi√©n la descripci√≥n. Y este √∫ltimo atributo nos supone una sobrecarga de unos 500 bytes por cada uno de los cursos que no vamos a utilizar para solucionar este caso de negocio. Este es el criterio importante: c√≥mo se adapta nuestra operaci√≥n a la query que necesitamos responder por lo que decidimos que este dise√±o supone demasiado sobrepeso en el documento de respuesta y tenemos que buscar una soluci√≥n alternativa. Este es el criterio importante (c√≥mo se adapta nuestra operaci√≥n a la query que necesitamos responder). Hay dos opciones. La primera ser√≠a a√±adir un mecanismo por el cual podamos especificar en la URL una proyecci√≥n, que es una forma elegante de decir que solo quieres parte de la informaci√≥n disponible en cada momento. Esta opci√≥n la implementar√≠amos con par√°metros en la querystring de la URL. O bien tambi√©n puedes crear un nuevo recurso dependiente del anterior que solo incluya la informaci√≥n que necesitamos. Calma, ahora te ense√±o dos ejemplos: GET /cursos?proyeccion=titulo,actividad GET /cursos/actividad ¬øQu√© te parece mejor? Pues √©sa es la decisi√≥n correcta. En mi caso creo que la segunda opci√≥n se entiende mejor, es m√°s legible sobre todo si m√°s adelante tenemos que utilizar la querystring para alguna otra cosa. Y seguramente tambi√©n tiene una sem√°ntica m√°s fuerte. As√≠ que optamos por ella. Pero no deja de ser una decisi√≥n de dise√±o, defi√©ndela como tal. Por coherencia seguimos la misma t√°ctica con las unidades did√°cticas. Y nuestra API queda as√≠: GET /cursos/actividad GET /cursos/{codigo}/unidades-didacticas/actividad Bien, perfecto. Funcionar√°. Ahora tenemos que solucionar el extra del que hemos hablado antes: el poder filtrar entre un rango de fechas. Y aqu√≠ s√≠ es muy c√≥modo y natural ampliar la informaci√≥n que proporcionamos en forma de querystring, como par√°metros opcionales. Por ejemplo: GET /cursos/actividad?desde={fechaInicial}&hasta={fechaFinal} El formato para especificar fechas m√°s popular es el de ISO-8601. Y vigila, porque ya sabes que en inform√°tica las fechas tienen siempre m√°s peligro que una pira√±a en un bid√©: almacena el dato siempre en UTC y solo cuando dibujes pantallas pres√©ntalo en el formato local del usuario. O tendr√°s poblemas. Serios. B√°sicamente la UTC (Coordinated Universal Time acronimizado por alguien que llevaba dos cervezas de m√°s) se determina a partir de las oscilaciones de m√°s de 70 relojes at√≥micos y es en el fondo el valor reconocido internacionalmente como fecha actual independientemente de la zona horaria en la que te encuentres. Bien, filtro solucionado. Un inciso ¬øtendr√≠a sentido una ruta de este estilo? /cursos/{codigo-curso}/unidades-didacticas/{numero-ul}/actividad Probablemente no: el resultado ser√≠a simplemente un n√∫mero con el n√∫mero de unidades did√°cticas completadas y estar√≠as pagando toda la latencia de una petici√≥n/respuesta para conseguir una informaci√≥n demasiado precisa. Tardar√≠as lo mismo (o casi) en retornar todos los datos de la unidad didactica que seleccionases (c√≥digo, t√≠tulo, actividad, etc) y adem√°s con toda seguridad ese ser√≠a el caso de uso real de la operaci√≥n: manipular la ficha entera de una unidad did√°ctica, no solo conocer los estudiantes que la han completado. La ruta quedar√≠a sin el recurso final: /cursos/{codigo-curso}/unidades-didacticas/{numero-ul} Si te parece complicado, piensa en pantallas para humanos: posiblemente crear√≠as una para visualizar la ficha de una unidad did√°ctica pero no para presentar tan solo la actividad que ha recibido. La mejor manera de incrementar tu productividad es no hacer lo que nadie ha pedido. Pero recuerda que nadie nos ha pedido esta funcionalidad y que la mejor manera de incrementar tu productividad es no hacer lo que nadie ha pedido. Las Respuestas Una vez solucionado el c√≥mo invocamos la operaci√≥n tenemos que decidir el formato en el que responderemos. Y s√© lo que esperas: esperas que te diga que XML es muerte y hay que usar JSON. Y lo cierto es que XML es muerte pero si tu usuario (¬°el consumidor del API!) trabaja con XML es tu responsabilidad darle esa opci√≥n: que sea √©l quien con por ejemplo la cabecera Accept de HTTP te indique qu√© prefiere. La enorme mayor√≠a de frameworks del mundo permiten generar los dos formatos autom√°ticamente as√≠ que ante todo mucha calma. Por cierto, una cabecera HTTP es‚Ä¶ no, espera, mejor √©chale un vistazo a este v√≠deo que describe HTTP para entender los detalles de este protocolo. Lo que te ense√±o ahora es un ejemplo del posible resultado para ambas APIs para la petici√≥n /cursos/actividad?desde=2016-11-01T00:00:00-00:00&hasta=2000-10-31T23:59:59-00:00 [ { codigo :  cultura , titulo :  Cultura DevOps , unidadesDidacticasCompletadas : 2580, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z }, { codigo :  apirest , titulo :  Dise√±o de APIs , unidadesDidacticasCompletadas : 2200, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z }, { codigo :  spoiler , titulo :  No way , unidadesDidacticasCompletadas : 0, desde :  2016-11-01T00:00:00Z , hasta :  2000-10-31T23:59:59Z } ] El hecho de repetir el rango de fechas para cada curso es una decisi√≥n de dise√±o, de nuevo. El objetivo es facilitar la vida al desarrollador que utilice la API al devolverle objetos muy simples como respuestas en lugar de obligarle a crear una composici√≥n en la que un objeto Curso contenga instancias de tipo Actividad. Una vez hayamos publicado esta versi√≥n de la API estamos firmando un contrato: no vamos a poder cambiar el nombre y el tipo de ninguno de sus atributos. Y sobre todo recuerda que una vez hayamos publicado esta versi√≥n de la API estamos firmando un contrato: no vamos a poder cambiar el nombre y el tipo de ninguno de sus atributos. A√±adir nueva informaci√≥n puede ser aceptable pero a menos que quieras mantener varios proyectos que implementen distintas versiones del web service (ya te contar√© c√≥mo hacerlo si resulta inevitable) los nombres y tipos que hayas decidido aqu√≠ est√°n para quedarse. Y si no me crees echa un vistazo a la cantidad de atributos repetidos (con distinto formato) en un tuit cualquiera. Por ejemplo, la propiedad geo est√° duplicada en place (en distintos formatos) y deber√≠a ir asociada a location. Pero los chiquitos que crearon el contrato se han portado bien y han resistido el impulso de refactorizarlo. anatom√≠a de un tuit, por raffi krikoriansource: imgur.com Pero ¬øse te ocurre otro par de formatos que podr√≠an ser √∫tiles en nuestro caso? Venga, para un momento y piensa un poco en ello. Luego sigue leyendo. Yeeeeees. Estamos hablando de n√∫meros, estad√≠sticas. Y el product owner nos ha dicho que quiere dibujarlos, representarlos. As√≠ que ¬øpor qu√© no ofreces la posibilidad de pedir un dibujo? Ya sabes, image/png, image/jpg‚Ä¶ lo que sea. No es tan dif√≠cil, de nuevo tienes una lista enorme de librer√≠as que te ayudan. De esta manera le est√°s facilitando enormente el trabajo de hacer una primera integraci√≥n entre su producto y tu API. Y por otro lado si hay n√∫mero de por medio una forma muy potente de a√±adir todo tipo de funcionalidades a tu aplicaci√≥n es dejando que el usuario final (el profesor, en este caso) la implemente. En forma de hoja de c√°lculo, por ejemplo. Hagamos que nuestro web service sea tambi√©n capaz de retornar ficheros tipo text/csv y que los magos de las rejillas monten sus historias sin tener que pedirnos ayuda. excel magicsource: imgur.com Como ahora mismo t√∫ eres mi usuario y quiero que puedas jugar r√°pidamente con el microservicio he a√±adido tambi√©n el c√≥digo necesario para que te responda si invocas la url desde el navegador. En el fondo se trata simplemente de aceptar tambi√©n text/html como un posible formato de respuesta. T√©cnica y est√©ticamente impecable, que no te vengan con historias de que un web service solo debe retornar JSON. El mismo razonamiento puedes hacer a la hora de recibir informaci√≥n en la petici√≥n. En nuestro caso no ha hecho falta pero mientras m√°s flexibilidad aportes, mejor. Aunque reconozco que muchas veces es m√°s costosa de implementar esta parte as√≠ que si t√∫ tambi√©n terminas llegando a un compromiso no te sientas demasiado mal. La Implementaci√≥n En este post no voy a dar muchos detalles sobre ella, no es el objetivo que tengo aqu√≠. En cuanto pueda montar√© una serie de entradas especiales centradas espec√≠ficamente en el desarrollo y como ya escuchaste en el cap√≠tulo anterior se basar√° en Spring Boot: este framework me tiene el coraz√≥n robado, brib√≥n. Aqu√≠ tienes el repositorio de c√≥digo fuente y en este otro link encontrar√°s el ejecutable ya compilado. Elige el camino con el que est√©s m√°s c√≥modo para probarlo pero seguramente este √∫ltimo te ser√° m√°s sencillo si no has programado antes en java: solo tienes que instalar el kit de desarollo y desde l√≠nea de comando: cd <carpeta_en_la_que_tienes_el_jar> java -jar controlactividad-0.0.1-SNAPSHOT.jar Aparecer√°n unos bonitos mensajes (incluyendo el aviso de que el servidor de aplicaciones est√° listo para recibir peticiones) y dado que son consultas y por lo tanto utilizan el m√©todo GET de HTTP puedes probarlas desde tu navegador: http://localhost:8080/cursos/actividad?desde=2016-11-01T00:00:00-00:00&hasta=2000-10-31T23:59:59-00:00 http://localhost:8080/cursos/introduccion/actividad Ver√°s tambi√©n que si cambias los par√°metros ¬°obtienes exactamente el mismo resultado! Eso es porque solo est√° implementada la capa del Controlador, es decir, la que permite interaccionar con el exterior de la aplicaci√≥n y que es la que define la API. Las reglas de negocio, la base de datos y el resto de componentes est√°n simulados y nos dedicaremos a ellas m√°s adelante. Es m√°s, si pruebas la segunda direcci√≥n a fecha de hoy no te funcionar√° porque no la he implementado todav√≠a: no aporta mucho a lo que ya hemos explicado. Querr√°s comprobar tambi√©n si los otros formatos de respuesta funcionan y para eso tienes que ser capaz de enviar cabeceras HTTP. Desde el navegador puedes hacerlo con extensiones como el s√∫per conocido Postman para Chrome o el Rest-easy para Firefox. En el v√≠deo en el que te hablar√© de HTTP te ense√±o a usarlos. Si (como yo) eres un rom√°ntico o una rom√°ntica en realidad terminar√°s usando the good old cUrl. En El Siguiente Cap√≠tulo Recuerda: tengo un plan. Y el plan incluye empezar a hablar sobre tests tan r√°pido como sea posible porque son la √∫nica manera de asegurar la calidad de tu c√≥digo. Nos dedicaremos a ello semana que viene mientras gestionamos los posibles errores de la API y alguna operaci√≥n adicional. Tambi√©n hablaremos de documentaci√≥n autom√°tica, algo cr√≠tico a la hora de facilitar la vida a tus usuarios. Y de HATEOAS y paginaci√≥n. No, eso no va a caber. Lo dejaremos para la siguiente entrega. Pero ¬°seguiremos implementando nuestro microservicio! ¬°Ah! Y si no tienes clara alguna de las ideas que han ido saliendo (por ejemplo qu√© es JSON), d√≠melo. Tengo un plan, pero si no te gusta aqu√≠ tengo otros ;-) jv pd: ¬øAdivinas de qui√©n es la m√∫sica de la entradilla? Yes, de Marcus. No me digas que no sonr√≠es cuando la oyes. ppd: La imagen del post ilustra perfectamente lo que quiero hacer una vez pase la pr√≥xima semana y es de Ben GAllager. pppd: Como casi siempre te dejo una tira de Dilbert. Por cierto, la de esta semana es espectacular. ppppd: Simon Fodden escribi√≥ hace tiempo una interesante art√≠culo sobre la anatom√≠a de un tuit utilizando para ello el gr√°fico que has visto antes de Raffi Krikorian."
    },

    {
        "id": 70,
        "autor": "Roberto Canales Mora",
        "pagina": "adictosaltrabajo",
        "fecha": "23/09/2015",
        "titulo": "Creando servicios RESTful con NetBeans 8",
        "link": "https://www.adictosaltrabajo.com/2015/09/23/creando-servicios-restful-con-netbeans-8/",
        "contenido": "En este tutorial vamos a ver c√≥mo utilizar el asistente de NetBeans 8 para crear servicios RESTful f√°cilmente Hace tiempo que no tocaba c√≥digo y como tengo que impartir unos cursos para directivos de Gobierno SOA me he puesto a mirar como crear ejemplos sencillos y r√°pidos de servicios. Aunque en mi contexto utilizamos m√°s Eclipse, a mi siempre me ha gustado lo intuitivo de NetBeans. En este caso voy a ense√±ar como crear servicios RESTful usando los asistentes de NetBeans 8, bueno, hasta donde se puede. Equipo iMac (Retina 5K, 27 pulgadas, finales de 2014) 4 GHz Intel Core i7 16 GB 1600 MHz DDR3 AMD Radeon R9 M295X 4096 MB Antes de empezar voy a ver la versi√≥n que tengo en mi Mac de Java. Shell java -version 1 java -version Nos descargamos NetBeans, en Bundle para JEE: Arrancamos Creamos un nuevo proyecto Elegimos el tipo aplicaci√≥n Web Voy a hacer un ejemplo de Pizza por lo que creo el proyecto con ese nombre Elegimos en servidor de aplicaciones que viene por defecto No elegimos ning√∫n framework Y damos a ¬´Play¬ª para probar que la aplicaci√≥n funciona. De momento solo tiene una p√°gina con un literal. Ahora vamos a a√±adir un fichero Elegimos RESTful WebService from patterns. Es lo m√°s sencillo y luego ya tocaremos. Elegimos el nombre del recurso a gestionar y de la clase contenedora El proyecto por defecto no trae un Web.xml por lo que lo creamos a partir del mismo asistente. Le metemos el servlet mapping de jersey. Curiosamente hay un peque√±o problema, que el c√≥digo generado es de la versi√≥n 1 y no 2, por lo que hay que buscar las librer√≠a de la versi√≥n 1 (por internet), descargarlas y a√±adirlas a mano (dar al bot√≥n derecho en el proyecto para que aparezcan las propiedades) No es dif√≠cil de encontrar Lo descargamos, descomprimimos y a√±adimos. Ahora ya tenemos un proyecto con este aspecto. Si lo ejecutamos saldr√° la pagina de antes. Para ver algo debemos meter en el navegador la URL http://localhost:8080/PizzasAutentia/ (en mi caso) Inicialmente fallar√° porque no hay un c√≥digo m√≠nimo y se lanza una excepci√≥n por defecto Java throw new UnsupportedOperationException(); 1 throw new UnsupportedOperationException(); A√±adimos una linea solo para ver que funciona. Java public Pizza getXml() { return ‚Äúlo que sea‚Äù; } 1 2 3 public Pizza getXml() { return ‚Äúlo que sea‚Äù; } Yo he metido una respuesta en un pseudo xml Como uso Firefox, instalo el pluggin RESTClient. https://addons.mozilla.org/es/firefox/addon/restclient/ Ahora puedo controlar mejor que es lo que mando y llega Vemos ejemplo de respuesta 200 Voy a hacer un poco de limpia, y solo dejo la clase PizzaRecursos, que nos sobra para hacer mapping y juguetear un poco con Jersey. Java @GET @Produces( application/xml ) public String getXml() { //TODO return proper representation object return  <datos>Ejemplo Colecci√≥n</datos> ; // throw new UnsupportedOperationException(); } /** * POST method for creating an instance of PizzaRecurso * @param content representation for the new resource * @return an HTTP response with content of the created resource */ @POST public Response postXml(String content) { System.out.println( por aqui ); return Response.ok().build(); // return Response.created(context.getAbsolutePath()).build(); } /** * Sub-resource locator method for {id} */ @Path( {id} ) public String getPizzaRecurso(@PathParam( id ) String id) { System.out.println( reclamamos elemento ); return  Complicando los mappings ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @GET @Produces( application/xml ) public String getXml() { //TODO return proper representation object return  <datos>Ejemplo Colecci√≥n</datos> ; // throw new UnsupportedOperationException(); } /** * POST method for creating an instance of PizzaRecurso * @param content representation for the new resource * @return an HTTP response with content of the created resource */ @POST public Response postXml(String content) { System.out.println( por aqui ); return Response.ok().build(); // return Response.created(context.getAbsolutePath()).build(); } /** * Sub-resource locator method for {id} */ @Path( {id} ) public String getPizzaRecurso(@PathParam( id ) String id) { System.out.println( reclamamos elemento ); return  Complicando los mappings ; } Este es el aspecto Ahora que funciona, vamos a crear una clase y hacer el mapping directo a XML. Creamos la clase Pizza A manita (ya por no andar capturando m√°s pantallas) creamos atributos, constructor por defecto, constructor deseado y lo anotamos como @XmlRootElement No olvidar: import javax.xml.bind.annotation.*; Java /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package PizzaAutentiaPkg; import javax.xml.bind.annotation.*; /** * * @author rcanales */ @XmlRootElement public class Pizza { private int     id; private String  nombre; private String  desc; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public Pizza() { // costructor por defecto id      = 0; nombre  =  defecto ; desc    =  defecto ; } public Pizza(int pid, String pnombre, String pdesc) { this.id      = pid; this.nombre  = pnombre; this.desc    = pdesc; } @Override public String toString() { return new StringBuffer(  id:  ). append(id). append(  nombre:  ). append(nombre). append(  desc:  ). append(desc).toString(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ package PizzaAutentiaPkg; import javax.xml.bind.annotation.*; /** * * @author rcanales */ @XmlRootElement public class Pizza { private int     id; private String  nombre; private String  desc; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getDesc() { return desc; } public void setDesc(String desc) { this.desc = desc; } public Pizza() { // costructor por defecto id      = 0; nombre  =  defecto ; desc    =  defecto ; } public Pizza(int pid, String pnombre, String pdesc) { this.id      = pid; this.nombre  = pnombre; this.desc    = pdesc; } @Override public String toString() { return new StringBuffer(  id:  ). append(id). append(  nombre:  ). append(nombre). append(  desc:  ). append(desc).toString(); } } Aqu√≠ un poco m√°s bonito Modificamos el m√©todo get para decir que produce XML y que retorna un objeto de tipo Pizza. Java @GET @Produces( application/xml ) public Pizza getXml() { //TODO return proper representation object return new Pizza(1,  Carbonara ,  Nuestra m√°s afamada ); // throw new UnsupportedOperationException(); } 1 2 3 4 5 6 7 8 @GET @Produces( application/xml ) public Pizza getXml() { //TODO return proper representation object return new Pizza(1,  Carbonara ,  Nuestra m√°s afamada ); // throw new UnsupportedOperationException(); } Y la magia est√° hecha."
    },

    {
        "id": 71,
        "autor": "Cecilio √Ålvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "14/06/2013",
        "titulo": "Introducci√≥n a Servicios REST",
        "link": "https://www.arquitecturajava.com/servicios-rest/",
        "contenido": "Cada d√≠a necesitamos mas usar servicios web REST . Estos servicios se diferencian de una forma importante de los servicios web SOAP con los que hemos trabajado . REST (Representational State Transfer) es un estilo de arquitectura para desarrollar servicios. Los servicios web que siguen este estilo deben cumplir con las siguientes premisas. Cliente/Servidor : Como servicios web son cliente servidor y definen un interface de comunicaci√≥n entre ambos separando completamente las responsabilidades entre ambas partes. Sin estado : Son servicios web que no mantienen  estado asociado al cliente .Cada petici√≥n que se realiza a ellos es completamente independiente de la siguiente . Todas las llamadas al mismo servicio ser√°n id√©nticas. Cache : El contenido de los servicios web REST ha se puede cachear de tal forma que una vez realizada la primera petici√≥n al servicio el resto puedan apoyarse en la cache si fuera necesario. Servicios Uniformes :Todos lo servicios REST compartir√°n una forma de invocaci√≥n y m√©todos uniforme utilizando los metodos GET,POST,PUT ,DELETE Arquitectura en Capas: Todos los servicios REST estan orientados hacia la escalabilidad y un cliente REST no ser√° capaz de distinguir entre si esta realizando una petici√≥n directamente al servidor , o se lo esta devolviendo un sistema de caches intermedio o por ejemplo existe un balanceador que se encarga de redirigirlo a otro servidor. Una  vez vista una introducci√≥n al concepto de servicio REST en los siguientes POST nos encargaremos de construir uno usando los standards de la plataforma JEE."
    },

    {
        "id": 72,
        "autor": "Arteco",
        "pagina": "arteco-consulting",
        "fecha": "01/02/2020",
        "titulo": "C√≥mo crear una aplicaci√≥n con SpringBoot Initializr",
        "link": "https://www.arteco-consulting.com/tu-primera-aplicacion-con-spring-boot/",
        "contenido": "Por parte de los desarrolladores de Spring, se tiene a disposici√≥n una herramienta web online denominada Spring Initializr donde por medio de unos par√°metros de configuraci√≥n genera autom√°ticamente un proyecto Maven o Gradle, seg√∫n se elija, en un archivo comprimido Zip conteniendo la carpeta con la estructura de la aplicaci√≥n para ser importada directamente desde el editor de programaci√≥n como Eclipse IDE, Netbeans IDE o Intellij. Se puede acceder mediante el enlace a la direcci√≥n: https://start.spring.io/ El asistente web solicita una serie de datos necesarios para poder ejecutar la plantilla que construye los primeros archivos del programa. Para todos ellos aporta una configuraci√≥n por defecto que conviene cambiar, como el nombre de la aplicaci√≥n, o el package que se usar√° en las clases generadas. A continuaci√≥n se explica qu√© par√°metros hay y para qu√© sirven: Project: Permite elegir la herramienta de construcci√≥n de la aplicaci√≥n. En Java las dos herramientas m√°s usadas son Maven y Gradle. Recomendamos Maven al ser la m√°s expendida. Language: Lenguaje de programaci√≥n que se va a utilizar en la aplicaci√≥n. Los tres tipos est√°n soportados por la m√°quina virtual JVM. Java es la opci√≥n m√°s extendida y tiene mejor soporte de los editores de programaci√≥n. Spring Boot: Versi√≥n del Spring Boot a usar. Siempre que se pueda se optar√° por la √∫ltima estable, compuesta √∫nicamente por n√∫meros. Project Metadata, Group: Se refiere al descriptor de Maven groupId, utilizado para clasificar el proyecto en los repositorios de binarios. Normalmente se suele usar una referencia similar a la de los packages de las clases. Por ejemplo, com.arteco.web para disponer todas las aplicaciones web en el mismo directorio. Project Metadata, Artifact: Se refiere al otro descriptor de Maven artifactId, y por tanto para indicar el nombre del proyecto y del binario resultante. La combinaci√≥n de groupId y artifactId (m√°s la versi√≥n) identifican inequ√≠vocamente a un binario dentro de cualquier organizaci√≥n. Packaging: Indica qu√© tipo de binario se debe construir. Si la aplicaci√≥n se ejecutar√° por s√≠ sola se seleccionar√° JAR, √©ste contiene todas las dependencias dentro de √©l y se podr√° ejecutar con java -jar binario-<version>.jar. Si por el contrario, la aplicaci√≥n se ejecutar√° en un servidor J2EE existente o en un Tomcat ya desplegado se deber√° escoger WAR. Java: Se selecciona la versi√≥n de Java a usar. En este caso, se recomienda usar la versi√≥n de Java m√°s antigua para garantizar la compatibilidad con otras librer√≠as o proyectos que se quieran incluir, as√≠ ser√° m√°s probable encontrar documentaci√≥n existente que siga siendo v√°lida. Reduce el riesgo de toparse con funcionalidades no muy maduras. Dependencies: Buscador de dependencias con los starters de Spring boot disponibles. Las dependencias m√°s habituales son: Spring Web se deber√° escoger cuando se desee hacer una aplicaci√≥n web o microservicios, siempre que se requiera una comunicaci√≥n http y por tanto el uso de Spring MVC. Thymeleaf Incorpora el motor de plantillas para HTML din√°mico, sucesor de los anteriores JSP (Java Server Page). Spring Data JPA necesario para utilizar la capa est√°ndar de acceso a base de datos SQL denominada Java Persistence Api. Spring Security Permite incorporar controles de acceso en base a usuarios y roles sobre URLs de la aplicaci√≥n. Tambi√©n habilita el control de ejecuci√≥n de m√©todos de servicio en base a roles seg√∫n los est√°ndares J2EE. Lombok Aporta utilidades que facilitan la programaci√≥n como la creaci√≥n de @Getters y @Setters autom√°ticamente para las clases que forman parte del conjunto de mensajes. Flyway Librer√≠a que permite aplicar scripts de cambios de base de datos de manera controlada cuando arranca la aplicaci√≥n. Estos scripts se denominan migraciones y est√°n sujetos a un control de versiones para garantizar que se aplican en el orden correcto. Mysql/Postgresql Incluye el JAR que contiene el driver JDBC necesario para configurar la capa de JPA seg√∫n la base de datos a usar. Otras‚Ä¶ El asistente permite seleccionar entre m√°s de 50 dependencias e integraciones de herramientas open source dentro de los proyectos realizados con Spring. Una vez seleccionados los par√°metros que se quieren, haciendo click en el bot√≥n ¬´Generate-Ctrl+¬ª se descargar√° un archivo zip con el nombre del Artifact que contendr√° la carpeta con la estructura de la aplicaci√≥n lista para importar desde el IDE. Recursos generados por SpringBoot Initializr Para realizar la importaci√≥n, bastar√° con importar o abrir el fichero pom.xml que viene dentro del comprimido. Los editores crear√°n y configurar√°n el classpath y las librer√≠as que se indican en √©l para que est√©n disponibles para el programador. El contenido del fichero tendr√° la siguiente forma: . ‚îú‚îÄ‚îÄ HELP.md ‚îú‚îÄ‚îÄ mvnw ‚îú‚îÄ‚îÄ mvnw.cmd ‚îú‚îÄ‚îÄ pom.xml ‚îî‚îÄ‚îÄ src ‚îú‚îÄ‚îÄ main ‚îÇ   ‚îú‚îÄ‚îÄ java ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ org ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ eadp ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ spring ‚îÇ   ‚îÇ               ‚îî‚îÄ‚îÄ SpringAppApplication.java ‚îÇ   ‚îî‚îÄ‚îÄ resources ‚îÇ       ‚îú‚îÄ‚îÄ application.properties ‚îÇ       ‚îú‚îÄ‚îÄ static ‚îÇ       ‚îî‚îÄ‚îÄ templates ‚îî‚îÄ‚îÄ test ‚îî‚îÄ‚îÄ java ‚îî‚îÄ‚îÄ org ‚îî‚îÄ‚îÄ eadp ‚îî‚îÄ‚îÄ spring ‚îî‚îÄ‚îÄ SpringAppApplicationTests.java De los ficheros incluidos, el m√°s importante es MyWebAppApplication.java que corresponde con el punto de entrada a la ejecuci√≥n del programa. Aqu√≠ es donde se aloja el m√©todo public static void main(String[] arg) que es el que inicializa toda la aplicaci√≥n de Spring Boot. Durante el arranque del framework, Spring revista el resto de directorios o paquetes que cuelgan de m√©todo main en b√∫squeda de clases marcadas con alguna anotaci√≥n que permite el registro de componentes como: @Service, @Component, @Repository y dem√°s anotaciones de Spring y de Spring MVC como @Controller o @RestController. F√≠jese que el paquete utilizado es el com.eadp.web, esta opci√≥n puede especificarse en el asistente Spring Initializr. El siguiente fichero m√°s importante es application.properties que es donde se aloja toda la configuraci√≥n de los componentes de Spring Boot, c√≥mo que encoding usar (utf-8), si debe usar cach√© en las plantillas, qu√© nombre y clave de acceso son los de por defecto, etc‚Ä¶ En el enlace de configuraciones y propiedades comunes de spring boot hay una referencia de todas las existentes y sus valores iniciales. El siguiente fichero es MyWebAppApplicationTests.java donde se aloja el primer test de ejemplo que genera Initializr por nosotros. Ah√≠, el usuario debe a√±adir los test que considere oportunos para aplicar en la medida de lo posible desarrollo orientado a test o TDD. Los otros directorios son static que es donde se alojan los recursos est√°ticos que la aplicaci√≥n debe servir sin procesar. Por ejemplo en esta carpeta se incluyen los ficheros CSS, Javascript, im√°genes o fuentes que se referencian desde el HTML. Si el fichero alojado en este directorio est√° en una sub-carpeta de static, como puede ser static/css/main.css. Spring Boot lo publicar√° autom√°ticamente en la url http://localhost:8080/css/main.css. As√≠ que no debe haber informaci√≥n sensible que cuelgue del directorio static porque entonces ser√° accesible abiertamente. Y por √∫ltimo la carpeta templates almacena los ficheros que permiten generar HTML din√°micamente con alg√∫n motor de plantillas soportado por Spring como Thymeleaf o Freemarker. C√≥mo a√±adir funcionalidad al proyecto El proyecto creado es muy simple, si tratamos de arrancar el m√©todo main de la clase MyWebAppApplication, veremos c√≥mo Spring inicializa toda la aplicaci√≥n y se pone a la escucha del puerto 8080, pero si dirigimos el navegador a esa URL no aparecer√° ning√∫n contenido. As√≠ que veamos c√≥mo podemos hacer para imprimir algunos datos mediante html din√°mico. Para que las siguientes l√≠neas sirvan debemos asegurarnos de haber escogido al menos las dependencias de Spring Web y Thymeleaf, dejando el resto de opciones como se indican en las l√≠neas superiores. Generamos el proyecto de nuevo, de no ser as√≠ y crearemos el primer controlador que permitir√° a√±adir c√≥digo Java y una plantilla Thymeleaf que generar√° los primeros documentos HTML din√°micos. Con el proyecto ya importado en el editor vamos a crear un primer controlador que ser√° el encargado de ejecutar c√≥digo Java dada una URL. En √©ste crearemos una variable que podr√° ser impresa en la plantilla mediante el traspaso del dato v√≠a el modelo. // contenido del fichero: src/main/java/org/eadp/spring/controller/MyController.java package org.eadp.spring; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import java.time.LocalDateTime; @Controller public class MyController { @GetMapping( / ) public String index(Model model) { model.addAttribute( tstamp , LocalDateTime.now()); return  index ; } } El controlador registra un m√©todo en ¬´/¬ª, la ra√≠z del sitio, de tal manera que cuando la aplicaci√≥n est√© arrancada y lista para escuchar peticiones http, normalmente por el puerto 8080, el m√©todo index ser√° ejecutado cuando se solicite la URL de inicio http://localhost:8080/. En ese momento, el m√©todo ser√° ejecutado a√±adiendo la hora actual a una variable con nombre tstamp que se guarda en model, objeto que se pasa a la vista, para que pueda construir el html din√°micamente. En este caso, mostrando la hora en la que se invoc√≥ ese m√©todo. Por otro lado, nada m√°s ejecutarse el m√©todo del controlador, Spring pasar√° el control a la vista con nombre index correspondiente al fichero index.html de la carpeta de templates, tal y como indica el return ¬´index¬ª, en el que no hace falta indicar la extensi√≥n .html. Para completar el c√≠rculo y ver los resultado necesitamos crear la vista index.html con el siguiente contenido: // contenido del fichero: src/main/resources/templates/index.html <!doctype html> <html lang= es  xmlns:th= http://www.thymeleaf.org > <head> <title>My First Spring Boot App</title> <style> html { font-family: 'DejaVu Sans', Arial, Helvetica, sans-serif; color: #404040; background-color: #d3d3d3; } body{ padding: 5em; } </style> </head> <body> <h1>Hello from Spring Boot!</h1> <p> This page is served at <span th:text= __$_{__tstamp} ></span> </p> </body> </html> Y listos! Ahora ya podemos arrancar de nuevo la aplicaci√≥n y hacer la petici√≥n a http://localhost:8080/. Dando como resultado la impresi√≥n de la hora en la que se ejecut√≥ el controlador."
    },

    {
        "id": 73,
        "autor": "Natalia Roales Gonz√°lez",
        "pagina": "adictosaltrabajo",
        "fecha": "21/12/2016",
        "titulo": "Aplicaciones web con Spring Boot capa a capa",
        "link": "https://www.adictosaltrabajo.com/2016/12/22/aplicaciones-web-con-spring-boot-capa-a-capa/",
        "contenido": "En este tutorial vamos a aprender a desarrollar una aplicaci√≥n web con los recursos que nos brinda Spring Web. √çndice de contenidos 1. Introducci√≥n 2. Entorno 3. Creando el proyecto 4. Definiendo la clase principal 5. Empaquetando el proyecto y arrancando el servidor 6. Desarrollando la capa controlador 7. Desarrollando la capa de servicio 8. Desarrollando la capa de repositorio 9. Desarrollando la capa de acceso a datos 10. Todo listo, ¬°invoquemos al servicio! 11. Conclusiones 12. Referencias 1. Introducci√≥n Muchos de vosotros habr√©is o√≠do hablar de Spring Boot. Para los m√°s despitadillos, os dir√© que se trata de un proyecto creado a partir de Spring, el cual nos permite desarrollar y arrancar de forma muy r√°pida aplicaciones basadas en Spring. Hoy os voy a demostrar que realmente esto es as√≠, y para ello vamos a desarrollar una aplicaci√≥n web muy sencillita, paso a paso. La aplicaci√≥n consistir√° en un peque√±o servicio que nos muestra un mensaje de bienvenida al ser invocado. Bueno, ¬°pues comencemos a programar! üòÄ 2. Entorno Este tutorial ha sido realizado en un entorno con las siguientes caracter√≠sticas: Hardware: MacBook Pro Retina 15‚Äô (2,5 GHz Intel Core i7, 16 GB DDR3) Sistema Operativo: OS X El Capitan 10.11.5 Entorno de desarrollo: IntelliJ IDEA Ultimate 2016.1 Java 1.8 3. Creando el proyecto En primer lugar, creamos un proyecto maven. Para indicar que queremos utilizar Spring Web con Spring Boot, a√±adimos lo siguiente al fichero pom.xml: XHTML <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.4.1.RELEASE</version> </parent> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> 1 2 3 4 5 6 7 8 9 10 11 12 <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.4.1.RELEASE</version> </parent> <dependencies> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> </dependencies> De este modo, el proyecto que acabamos de crear extiende del proyecto padre spring-boot-starter-parent, e incluye las dependencias agrupadas en el starter spring-boot-starter-web. Un starter es un conjunto de dependencias que nos ayudan a cubrir las necesidades de un tipo de proyecto concreto. Por ejemplo, el starter que estamos utilizando sirve para cubrir las necesidades de un proyecto web. M√°s adelante utilizaremos otros starters, entre ellos el que nos ayuda a integrar MyBatis en la aplicaci√≥n. Podemos definir en qu√© versi√≥n de Java desarrollaremos nuestra aplicaci√≥n, a√±adiendo lo siguiente al fichero pom.xml: XHTML <properties> <java.version>1.8</java.version> </properties> 1 2 3 <properties> <java.version>1.8</java.version> </properties> En este caso, la versi√≥n que vamos a emplear ser√° la 1.8. Otra cosa importante es la definici√≥n de una buena estructura de paquetes. Un buen ejemplo puede ser el siguiente: paqueteria Esta estructura de paquetes agrupa las clases en cuatro paquetes principales: mapper para la capa de acceso a datos, repository para la capa de repositorio, service para la capa de servicio, y web para la capa controlador. No hay que seguir este ejemplo al pie de la letra ni mucho menos, es m√°s, puede que la estructura de paquetes de otros proyectos sea muy distinta pero totalmente v√°lida. Lo que pretendo mostraros es que debe existir una estructura de paquetes ordenada para que la aplicaci√≥n sea mantenible y para que la responsabilidad de las clases quede bien clara. 4. Definiendo la clase principal Toda aplicaci√≥n en java debe contener una clase principal con un m√©todo main. Dicho m√©todo, en caso de implementar una aplicaci√≥n con Spring, deber√° llamar al m√©todo run de la clase SpringApplication. A continuaci√≥n, definimos de una forma muy f√°cil la clase principal de nuestra aplicaci√≥n. Java @Configuration @EnableAutoConfiguration @ComponentScan public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 1 2 3 4 5 6 7 8 9 @Configuration @EnableAutoConfiguration @ComponentScan public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } La etiqueta @Configuration, indica que la clase en la que se encuentra contiene la configuraci√≥n principal del proyecto. La anotaci√≥n @EnableAutoConfiguration indica que se aplicar√° la configuraci√≥n autom√°tica del starter que hemos utilizado. Solo debe a√±adirse en un sitio, y es muy frecuente situarla en la clase main. En tercer lugar, la etiqueta @ComponentScan, ayuda a localizar elementos etiquetados con otras anotaciones cuando sean necesarios. Para no llenar nuestra clase de anotaciones, podemos sustituir las etiquetas @Configuration, @EnableAutoConfiguration y @ComponentScan por @SpringBootApplication, que engloba al resto. Java @SpringBootApplication public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 1 2 3 4 5 6 7 @SpringBootApplication public class Application { public static void main(String[] args) throws Exception { SpringApplication.run(Application.class, args); } } 5. Empaquetando el proyecto y arrancando el servidor Tras haber definido la clase principal del proyecto, podemos proceder a empaquetarlo y arrancar el servidor con nuestra aplicaci√≥n. Si hemos a√±adido correctamente las dependencias al fichero pom.xml no deber√≠a haber ning√∫n problema de empaquetado, y maven no nos devolver√≠a ning√∫n error en tiempo de compilaci√≥n. Para salir de dudas, vamos a ejecutar el siguiente comando en el directorio ra√≠z del proyecto: Shell $ mvn clean package 1 $ mvn clean package Si todo va bien, tras ejecutar esta instrucci√≥n, se generar√°n los ficheros .class a partir de las clases .java y se empaquetar√° el proyecto en un fichero .jar. Podemos ver tambi√©n qu√© dependencias han sido incluidas en el proyecto, es decir, qu√© dependencias engloban tanto los starters a√±adidos como el proyecto padre. Esto es posible con el siguiente comando: Shell $ mvn dependency:tree 1 $ mvn dependency:tree Por otro lado, los proyectos de tipo Spring Boot integran un servidor de aplicaciones, por lo que arrancar una aplicaci√≥n Spring Boot es muy f√°cil. En el directorio ra√≠z del proyecto ejecutamos el siguiente comando: Shell $ mvn spring-boot:run 1 $ mvn spring-boot:run Si no se produce ning√∫n error en tiempo de ejecuci√≥n, el servidor estar√≠a levantado y listo para recibir peticiones. 6. Desarrollando la capa controlador Definamos ahora el comportamiento de la aplicaci√≥n implementando el resto de clases. Vamos a comenzar por la capa de m√°s alto nivel, la de los controladores, donde expondremos los servicios de la aplicaci√≥n. El servicio que vamos a crear tendr√° un comportamiento muy simple. Recuperar√° de base de datos un mensaje de bienvenida cuyo contenido variar√° en funci√≥n del idioma del usuario, recibiendo como par√°metro el mismo nombre de usuario. El comportamiento del controlador ser√° a√∫n m√°s sencillo, ya que lo √∫nico que har√° ser√° llamar a la capa de servicio y devolver lo que √©sta nos retorne. Comenzaremos por el desarrollo del test que valide el controlador. Nuestro controlador se llamar√° SampleController, as√≠ que el test del controlador se llamar√° SampleControllerTest y estar√° en el mismo paquete que SampleController pero en el directorio test. Necesitaremos incluir una serie de dependencias englobadas en el starter spring-boot-starter-test: XHTML <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> 1 2 3 4 5 <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-test</artifactId> <scope>test</scope> </dependency> El contenido de la clase de test ser√° el siguiente: Java public class SampleControllerTest { private SampleController sampleController; private SampleService sampleService; @Before public void init(){ sampleService = mock(SampleService.class); sampleController = new SampleController(sampleService); } @Test public void sampleControllerShouldCallService() { String userName =  nroales ; String expectedMessage =  message ; when(sampleService.welcome(userName)).thenReturn(expectedMessage); String message = sampleController.welcome(userName); verify(sampleService).welcome(userName); assertTrue(message.equals(expectedMessage)); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class SampleControllerTest { private SampleController sampleController; private SampleService sampleService; @Before public void init(){ sampleService = mock(SampleService.class); sampleController = new SampleController(sampleService); } @Test public void sampleControllerShouldCallService() { String userName =  nroales ; String expectedMessage =  message ; when(sampleService.welcome(userName)).thenReturn(expectedMessage); String message = sampleController.welcome(userName); verify(sampleService).welcome(userName); assertTrue(message.equals(expectedMessage)); } } Hemos declarado un atributo de la clase SampleService, ya que lo que vamos a probar es que el controlador invoque a la capa de servicio y que devuelva lo mismo, as√≠ que debemos crear SampleService para que el test compile. Adem√°s, lo mockeamos para simular su comportamiento, pues el objetivo de este test no es probar la capa de servicio. Vamos a hacer que el test pase de rojo a verde con la siguiente implementaci√≥n de SampleController: Java @Controller public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) @ResponseBody public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Controller public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) @ResponseBody public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } En el fragmento de c√≥digo anterior aparecen algunas anotaciones. Vamos a ver qu√© significa cada una de ellas: @Controller: Con esta anotaci√≥n Spring podr√° detectar la clase SampleController cuando realice el escaneo de componentes. @Autowired: A trav√©s de esta anotaci√≥n Spring ser√° capaz de llevar a cabo la inyecci√≥n de dependencias sobre el atributo marcado. En este caso, estamos inyectando la capa de servicio, y por eso no tenemos que instanciarla. @RequestMapping: Con esta anotaci√≥n especificamos la ruta desde la que escuchar√° el servicio, y qu√© m√©todo le corresponde. @ResponseBody: Con ella definimos lo que ser√° el cuerpo de la respuesta del servicio. @PathVariable: Sirve para indicar con qu√© variable de la url se relaciona el par√°metro sobre el que se est√© usando la anotaci√≥n. Podemos tambi√©n utilizar la etiqueta @RestController en lugar de @Controller, que sustituye al uso de @Controller + @ResponseBody, quedando el controlador de la siguiente forma: Java @RestController public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RestController public class SampleController { @Autowired private SampleService sampleService; public SampleController(SampleService sampleService) { this.sampleService = sampleService; } @RequestMapping(value =  /welcome/{userName} , method = RequestMethod.GET) public String welcome( @PathVariable( userName ) String userName ) { return sampleService.welcome(userName); } } 7. Desarrollando la capa de servicio Aunque a partir de este punto no aparezcan las clases de test, no quiere decir que no sean necesarias para completar el desarrollo que estamos realizando. Sin embargo, he decidido omitirlas para que el tutorial no se extienda demasiado, pero siempre es recomendable respaldar nuestra aplicaci√≥n con una bater√≠a de pruebas (y m√°s a√∫n hacer TDD). Vamos implementar la capa de servicio. Un m√©todo de servicio definir√° una operaci√≥n a nivel de negocio, por ejemplo, dar un mensaje de bienvenida. Los m√©todos de servicio estar√°n formados por otras operaciones m√°s peque√±as, las cuales estar√°n definidas en la capa de repositorio. El mapper, por √∫ltimo, contendr√° las operaciones de acceso a datos que ser√°n invocadas por el repositorio. En este caso, el servicio realizar√° una sola llamada al repositorio, pas√°ndole como par√°metro el nombre de usuario. Lo llamaremos SampleService. Java @Service public class SampleService { @Autowired private SampleRepository sampleRepository; public SampleService(SampleRepository sampleRepository) { this.sampleRepository = sampleRepository; } public String welcome(String userName) { return sampleRepository.getMessageByUser(userName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Service public class SampleService { @Autowired private SampleRepository sampleRepository; public SampleService(SampleRepository sampleRepository) { this.sampleRepository = sampleRepository; } public String welcome(String userName) { return sampleRepository.getMessageByUser(userName); } } La anotaci√≥n @Service funciona de forma parecida a la anotaci√≥n @Controller, ya que permite que Spring reconozca a SampleService como servicio al escanear los componentes de la aplicaci√≥n. 8. Desarrollando la capa de repositorio Ahora tenemos que desarrollar el repositorio al que ha invocado el servidor. Por tanto, crearemos la clase SampleRepository e implementaremos el m√©todo getMessageByUser. Java @Repository public class SampleRepository { @Autowired private SampleMapper sampleMapper; public SampleRepository(SampleMapper sampleMapper) { this.sampleMapper = sampleMapper; } public String getMessageByUser(String userName) { String language = sampleMapper.getLanguageByUser(userName); return sampleMapper.getMessageByLanguage(language); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Repository public class SampleRepository { @Autowired private SampleMapper sampleMapper; public SampleRepository(SampleMapper sampleMapper) { this.sampleMapper = sampleMapper; } public String getMessageByUser(String userName) { String language = sampleMapper.getLanguageByUser(userName); return sampleMapper.getMessageByLanguage(language); } } Para recuperar el mensaje de bienvenida dado el nombre de usuario tendremos dos m√©todos en la capa de acceso a datos, siendo uno para recuperar el idioma dado el usuario, y otro para recuperar el mensaje dado el idioma. Desde el repositorio llamamos a los dos. 9. Desarrollando la capa de acceso a datos Ya solo nos queda implementar la capa de acceso a datos. En esta capa es en donde se definen las consultas a base de datos, a trav√©s de interfaces denominadas mappers. Vamos a crear el mapper con los dos m√©todos invocados en el repositorio, que son getLanguageByUser y getMessageByLanguage. Java @Mapper public interface SampleMapper { String getLanguageByUser(@Param( userName ) String userName); String getMessageByLanguage(@Param( language ) String language); } 1 2 3 4 5 6 7 @Mapper public interface SampleMapper { String getLanguageByUser(@Param( userName ) String userName); String getMessageByLanguage(@Param( language ) String language); } Utilizamos la etiqueta @Mapper para indicar que una interfaz es un mapper, y as√≠ Spring pueda localizarla. Tambi√©n utilizamos la etiqueta @Param para que MyBatis identifique los campos a la hora de procesar las consultas. Para poder trabajar con MyBatis debemos incluir algunas dependencias, agrupadas dentro del starter mybatis-spring-boot-starter: XHTML <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.1.1</version> </dependency> 1 2 3 4 5 <dependency> <groupId>org.mybatis.spring.boot</groupId> <artifactId>mybatis-spring-boot-starter</artifactId> <version>1.1.1</version> </dependency> Tambi√©n debemos a√±adir el conector correspondiente a la base de datos que vayamos a utilizar. Podemos hacerlo incluyendo su dependencia maven en el pom.xml. En caso de utilizar una base de datos MySQL a√±adimos la siguiente dependencia: XHTML <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.6</version> </dependency> 1 2 3 4 5 <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>5.1.6</version> </dependency> Y en el fichero application.properties, localizado en el directorio resources, a√±adiremos la informaci√≥n de nuestra base de datos, siendo testdb el nombre de la base: Shell spring.datasource.url=jdbc:mysql://localhost:3306/testdb spring.datasource.username=user spring.datasource.password=pass spring.datasource.driver-class-name=com.mysql.jdbc.Driver 1 2 3 4 spring.datasource.url=jdbc:mysql://localhost:3306/testdb spring.datasource.username=user spring.datasource.password=pass spring.datasource.driver-class-name=com.mysql.jdbc.Driver Una vez tenemos todo lo necesario para trabajar con MyBatis, definimos cada uno de los dos m√©todos del mapper. Dentro de la carpeta resources, creamos una estructura de directorios id√©ntica a la estructura de paquetes donde se encuentra SampleMapper.java, y creamos el fichero SampleMapper.xml. Tendr√° el siguiente contenido: XHTML <mapper namespace= com.autentia.demo.mapper.SampleMapper > <select id= getLanguageByUser  resultType= String > SELECT USL_LANGUAGE FROM USER_LANGUAGE WHERE USL_USER = #{userName} </select> <select id= getMessageByLanguage  resultType= String > SELECT MSG_DESCRIPTION FROM MESSAGES WHERE MSG_MESSAGE =  welcome  AND MSG_LANGUAGE = #{language} </select> </mapper> 1 2 3 4 5 6 7 8 9 10 11 <mapper namespace= com.autentia.demo.mapper.SampleMapper > <select id= getLanguageByUser  resultType= String > SELECT USL_LANGUAGE FROM USER_LANGUAGE WHERE USL_USER = #{userName} </select> <select id= getMessageByLanguage  resultType= String > SELECT MSG_DESCRIPTION FROM MESSAGES WHERE MSG_MESSAGE =  welcome  AND MSG_LANGUAGE = #{language} </select> </mapper> La primera query recupera de la tabla USER_LANGUAGE el campo USL_LANGUAGE dado el valor del campo USL_USER, obteni√©ndose el idioma asociado al usuario userName. La segunda query, recupera el campo MSG_DESCRIPTION de la tabla MESSAGES dado el valor del campo MSG_LANGUAGE para MSG_MESSAGE igual a ‚Äúwelcome‚Äù, obteni√©ndose el mensaje de bienvenida en el idioma del usuario. Aunque parezca obvio, vuestras consultas deber√°n concordar con el dise√±o de la base de datos. Lo que aparece dentro de #{userName} y #{language} son los identificadores que hemos designado a los par√°metros de entrada con las anotaciones @Param. 10. Todo listo, ¬°invoquemos al servicio! Es el momento de la verdad‚Ä¶ ¬°Vamos a invocar a nuestro servicio! Ya sab√©is, para ello levantamos el servidor con el siguiente comando: Shell $ mvn spring-boot:run 1 $ mvn spring-boot:run Una vez haya arrancado el servidor procedemos a invocar al servicio, y para ello accedemos a la url http://localhost:8080/welcome/userName. Tenemos que sustituir userName por el nombre de usuario que hayamos guardado en nuestra base de datos. Como respuesta, veremos en el navegador el mensaje de bienvenida que hayamos definido. 11. Conclusiones Gracias a Spring Boot nos acabamos de marcar en un momento una aplicaci√≥n totalmente funcional. Hemos comenzado creando un proyecto maven e indicando en el pom.xml que el proyecto es de tipo Spring Boot, heredando de spring-boot-starter-parent el proyecto creado. Despu√©s hemos elegido el starter que m√°s se ajusta a las necesidades de nuestro tipo de proyecto, en este caso spring-boot-starter-web, y lo hemos a√±adido como dependencia. Luego hemos creado la clase principal de la aplicaci√≥n, implementando posteriormente las clases e interfaces que definen su comportamiento, y por √∫ltimo hemos arrancado el servidor. El tiempo que hemos perdido en la configuraci√≥n del proyecto es m√≠nimo, y solo nos hemos tenido que preocupar de implementar los m√©todos que definan el comportamiento de los servicios. Tampoco hemos perdido tiempo en montar el servidor de aplicaciones, ya que Spring Boot cuenta con un Tomcat embebido. Ya no ten√©is excusa para no desarrollar proyectos web en Java. ¬øHab√©is visto qu√© f√°cil y r√°pido es tener una aplicaci√≥n Java web funcional desde cero? Os animo a que lo prob√©is"
    },

    {
        "id": 74,
        "autor": "Rosa",
        "pagina": "rosamarfil",
        "fecha": "16/08/2019",
        "titulo": "Crear una aplicaci√≥n web con Spring Boot",
        "link": "https://rosamarfil.es/tutoriales/programacion/spring-boot-api-rest-2-crear-una-aplicacion-web-con-spring-boot/",
        "contenido": "En este tutorial aprender√°s a instalar Spring Boot y crear una aplicaci√≥n web con Spring Boot desde cero. El proyecto estar√° basado en servicios web REST (o com√∫nmente microservicios). ¬øQu√© es Spring Boot? Es un framework o herramienta que ayuda a construir aplicaciones basadas principalmente en microservicios de una forma m√°s √°gil. Instalar Spring Boot Existen dos maneras: Instalado Spring Boot Starter (que es un Eclipse con Spring Boot integrado). Se puede descargar desde su p√°gina oficial: https://spring.io/tools. Accediendo a la p√°gina https://start.spring.io y generando el proyecto para descargarlo en tu PC. Instalando Spring Tools Suite en Eclipse (Se instala desde Eclipse, como un plugin). Yo, en este caso optar√© por la tercera opci√≥n e instalar√© Spring Tools Suite en Eclipse, con java JDK 8. Para ello: Abre Eclipse, dir√≠gete a Help -> Eclipse Marketplace‚Ä¶ Introduce ¬´sts¬ª en el cuadro de texto para realizar la b√∫squeda y presiona Enter. Visualiza la opci√≥n Spring Tools 4 ‚Äì for Spring Boot (aka Spring Tool Suite 4). Pulsa sobre el bot√≥n Install. install-spring-boot Instalar Spring Boot en Eclipse La instalaci√≥n tardar√° unos minutos y Eclipse te pedir√° que lo reinicies. Un vez reiniciado Eclipse observa que aparece un nuevo bot√≥n  (Boot Dashboard) en la barra de men√∫ superior. Crear proyecto Dir√≠gete a File -> New -> Project y elige Spring Boot -> Spring Boot Starter. Presiona Next. A continuaci√≥n, completa los datos para el proyecto y presiona Next: new-spring-boot-project Crear un proyecto Spring Boot A continuaci√≥n, activa las casillas Spring Web Services y Spring Web Starter. Pulsa Finish: spring-boot-dependencies-Crear aplicaci√≥n web con Spring Boot Seg√∫n las casillas que activemos, se crear√°n sus dependencias en el fichero pom.xml. Observa que no hay ning√∫n error a la hora de la creaci√≥n del proyecto. Prueba una ejecuci√≥n de la aplicaci√≥n (ejecutando el proyecto como Spring Boot App) y observando una salida por consola como la siguiente: Crear aplicaci√≥n web con Spring Boot Picar los servicios En mi caso he creado un servicio que devuelve una lista de usuarios. UserServiceRest.java En esta clase lo importante son las anotaciones que hemos a√±adido y de forma sencilla para que entend√°is que significa cada una os explico: @RestController -> Indica que ser√° una clase que va a publicar servicios REST. @RequestMapping(value= /users , method=RequestMethod.GET) -> se indica el nombre del m√©todo accesible desde el navegador. En este caso users. Y tambi√©n se indica el tipo de m√©todo, en este caso de tipo GET. C√≥digo de la clase UserServiceRest.java: package es.springboot.rosamarfil.services; import java.util.ArrayList; import java.util.List; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import es.springboot.rosamarfil.model.User; @RestController public class UserServiceRest { /** * Lista de ejemplo de usuarios */ private static List<User> listaUsuarios = new ArrayList<User>() { { add(new User( Rosa ,  Marfil )); add(new User( Pepito ,  Grillo )); add(new User( Manuela ,  Lago )); } }; @RequestMapping(value= /users , method=RequestMethod.GET) public List<User>  getUsers(){ return listaUsuarios; } } User.java package es.springboot.rosamarfil.model; import java.io.Serializable; public class User implements Serializable { private static final long serialVersionUID = 1L; public String name; public String username; public User() { super(); } public User(String name, String username) { super(); this.name = name; this.username = username; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } Probar servicio REST Despu√©s de picar el escueto c√≥digo, arranca tu aplicaci√≥n Spring Boot y muestra el resultado en el navegador introduciendo en la barra de direcciones: http://localhost:8080/users El resultado ser√°: Crear aplicaci√≥n web con Spring Boot Como ves, con este peque√±o tutorial has aprendido a crear una aplicaci√≥n web con Spring Boot y publicar en local un servicio REST. Evidentemente, un proyecto real tendr√≠a muchas m√°s capas y ser√≠a m√°s complejo, pero el concepto de Web Services REST con Spring Boot es el que te he explicado. Espero que te haya sido de utilidad. Gracias por leerme y comparte si te ha gustado. Nos vemos en el pr√≥ximo tutorial."
    },

    {
        "id": 75,
        "autor": "Iv√°n Salas",
        "pagina": "programandoointentandolo",
        "fecha": "25/10/2018",
        "titulo": "TUTORIAL SPRING BOOT ‚Äì CREANDO NUESTRA PRIMERA APLICACI√ìN",
        "link": "https://programandoointentandolo.com/2018/10/tutorial-spring-boot-creando-nuestra-primera-aplicacion.html",
        "contenido": "HomeJavaSpringSpring BootTutorial Spring Boot ‚Äì Creando nuestra primera aplicaci√≥n TUTORIAL SPRING BOOT ‚Äì CREANDO NUESTRA PRIMERA APLICACI√ìNSpring Boot  25 octubre, 2018  0  Iv√°n Salas reset css En este tutorial vamos a ver lo r√°pido y sencillo que es crear un proyecto utilizando Spring Boot, ya que no nos vamos a tener que preocupar de gestionar las dependencias que necesitaremos (al menos las m√°s comunes), ni hacer las t√≠picas configuraciones iniciales que hacemos al empezar un proyecto de Spring y ni tan siquiera nos vamos a tener que preocupar de configurar un servidor para correr nuestra aplicaci√≥n. Vamos que nos permite centrarnos en el desarrollo gracias a todas las cosas que Spring Boot hace por nosotros y que nos van a permitir crear y desplegar nuestras aplicaciones de una forma muy sencilla. El proyecto que vamos a crear en este tutorial lo voy a usar de base para ir entrando m√°s en profundidad en posteriores post tanto en Spring Boot como en otros temas relacionados de forma que la idea es tener al final una aplicaci√≥n sencilla pero que nos permita tener una visi√≥n completa de Spring, por eso en este post nos vamos a centrar en c√≥mo crear nuestra primera aplicaci√≥n con Spring Boot, analizar su estructura, explicar los puntos b√°sicos y arrancarla, ni m√°s ni menos. 1. CREAR UN PROYECTO CON SPRING BOOT Vamos a ver c√≥mo crear un proyecto con Spring Boot desde 0 usando el String Tool Suite que es un entorno de desarrollo basado en eclipse con todo lo que necesitamos para hacer desarrollos con Spring o bien podemos usar un eclipse ¬´normal¬ª y instalarle el Spring Tools desde el Eclipse Marketplace, podr√≠amos usar el IDE que m√°s nos guste pero alguno hab√≠a que elegir para hacer el tutorial‚Ä¶ Para crear un proyecto nuevo proyecto de Spring nos vamos a File/New/Spring Starter Proyect, si no aparece elegimos Proyect‚Ä¶ y lo buscamos dentro de Spring Boot y siguiente. Crear nuevo proyecto con Spring Boot En esta primera pantalla podemos decidir si queremos usar maven o gradle, la versi√≥n de java que queremos usar, la forma en la que queremos que se empaquete el proyecto, el lenguaje de programaci√≥n que vamos a usar y los t√≠picos datos del proyecto, nombre, package, ‚Ä¶ Ponemos los datos del proyecto y nos quedamos con maven, con la √∫ltima versi√≥n de la jdk, nos vamos a quedar tambi√©n con el jar porque no necesitamos otra cosa y como lenguaje pues elegimos Java aunque quiz√°s alg√∫n d√≠a me anime a hacerlo tambi√©n con Kotlin. Pulsamos en Next > para que nos aparezca la pantalla para seleccionar las dependencias que sabemos que va a utilizar nuestro proyecto. Seleccionar dependencias nuevo proyecto Spring Boot Las buscamos y las seleccionamos y cuando tengamos todas las que necesitamos le damos a Finish, si se nos olvida alguna no pasa nada, siempre podremos incluirlas a mano en el pom.xml pero desde aqu√≠ es m√°s simple porque con unos clics ya tenemos configuradas todas las dependencias sin necesidad de estar copi√°ndolas de otros proyectos que tengamos o peor de estar busc√°ndolas una a una. Y as√≠ de f√°cil tenemos nuestro proyecto listo para empezar. 2. ESTRUCTURA DEL PROYECTO La estructura del proyecto va a depender de las elecciones que hici√©semos a la hora de crear el proyecto, por ejemplo, si hubi√©semos elegido empaquetarlo como .war tendr√≠amos la carpeta webapp y si adem√°s quit√°semos Thymeleaf y lo seguimos dejando como un proyecto web tendr√≠amos una clase adicional (ServletInitializer), pero b√°sicamente podemos decir que la estructura del proyecto ser√° la t√≠pica de un proyecto de Spring. Estructura de proyecto Spring Boot Dentro de nuestro package principal tenemos una clase con el nombre del proyecto + Application que es la que nos proporciona Spring Boot para arrancar nuestra aplicaci√≥n. package com.programandoointentandolo.tsb; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class TutorialSpringBootApplication { public static void main(String[] args) { SpringApplication.run(TutorialSpringBootApplication.class, args); } } Como vemos esta clase es muy sencilla ya que solo contiene el m√©todo main dentro del que se llama a SpringApplication.run() y una anotaci√≥n @SpringBootApplication que es equivalente a usar las anotaciones @Configuration, @EnableAutoConfiguration y @ComponentScan con sus configuraciones por defecto. @Configuration: Esta anotaci√≥n se utiliza para indicar que la clase puede contener beans que ser√°n registrados al iniciar la aplicaci√≥n. @EnableAutoConfiguration: Con esta anotaci√≥n se le indica a Spring que se encargue de configurar todas las dependencias que tengamos en el proyecto. @ComponentScan: Permite que se escaneen todos los @Component que se encuentre dentro del paquete en el que se define, se puede configurar para que busque en los paquetes que queramos. El siguiente archivo que vemos en el proyecto es el application.properties que es el archivo que utilizaremos para configurar nuestra aplicaci√≥n, por lo tanto aqu√≠ es donde vamos a configurar nuestra conexi√≥n de base de datos y el resto de configuraciones que necesitemos, porque aunque Spring Boot nos evita tener que indicar todas las t√≠picas configuraciones en las que solo nos limitar√≠amos a dejar los valores por defecto siempre existe la posibilidad de que necesitemos cambiarlas, o simplemente como en el caso de las referentes a la base de datos que no tengamos m√°s remedio que indicarlas manualmente. En este enlace de la documentaci√≥n pues revisar las propiedades m√°s comunes. Para nuestro ejemplo vamos a usar una base de datos MySql y como durante el tutorial es muy probable que nuestras clases cambien y nos obliguen a cambiar nuestro modelo de BD vamos a dejar que Spring Boot nos cree las tablas a partir de nuestras clases cuando arranquemos la aplicaci√≥n y que las borre cuando la paremos para poder centrarnos en lo que estamos haciendo y no tener que preocuparnos por dejar datos inconsistentes. Por lo que nuestro application.properties ser√° el siguiente ya que la BD se va a llamar pruebas, va a estar en localhost:8889 y tanto el usuario como la password van a ser root. aplicacion.nombre=Tutorial Spring Boot server.port=9876 spring.datasource.url=jdbc:mysql://localhost:8889/pruebas?useSSL=false spring.datasource.username=root spring.datasource.password=root spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.jpa.database-platform=org.hibernate.dialect.MySQL57Dialect spring.jpa.hibernate.ddl-auto=create-drop logging.level.org.hibernate.SQL=debug Esas 3 propiedades son las que es posible que tengas que cambiar para poder usar tu BD, en cuanto al resto he puesto una propiedad inventada aplicacion.nombre para que se vea que tambi√©n es posible indicar nuestras propias variables de configuraci√≥n, con server.port podemos indicar el puerto en el que se arrancar√° la aplicaci√≥n por si no nos gusta el puerto por defecto, luego tenemos las propiedades referentes a la conexi√≥n de BD y la que hace nuestra base de datos se limpie con cada ejecuci√≥n spring.jpa.hibernate.ddl-auto=create-drop. Los archivos .properties son sencillos sobre todo cuando son peque√±os pero si crecen un poco y se van metiendo las propiedades desordenadas pueden ser dificiles de leer, por eso vamos a sustituir el application.properties que Spring Boot nos ha creado por un application.yml porque Spring Boot soporta tambi√©n el formato YAML perfectamente y el resultado es m√°s legible. A continuaci√≥n tenemos el .yml correspondiente al application.properties anterior. aplicacion: nombre: Tutorial Spring Boot server: port: 9876 spring: datasource: url: jdbc:mysql://localhost:8889/pruebas?useSSL=false username: root password: root driver-class-name: com.mysql.jdbc.Driver jpa: database-platform: org.hibernate.dialect.MySQL57Dialect hibernate: ddl-auto: create-drop logging: level: org: hibernate: SQL: debug Comparando uno y otro vemos que las propiedades son las mismas y lo que cambia es su representaci√≥n, mientras que en el .yml se sigue una estructura de √°rbol en el .properties cada propiedad contiene toda su ruta completa, y si nos fijamos vemos que el .yml lo que hace es que sustituye el ¬´.¬ª de separaci√≥n del .properties por ¬´:¬ª y comienza una nueva rama y as√≠ sucesivamente hasta que llega al nombre de la propiedad donde ya si que indica su valor. A Spring Boot le da igual que usemos uno u otro formato y no vamos a tener que hacer ning√∫n tipo de configuraci√≥n adicional para que use el application.yml, en cualquier caso lo que har√° cuando vaya a arrancar la aplicaci√≥n ser√° leer nuestro application.yml o application.properties para inyectar los valores de las propiedades que definamos en las clases de configuraci√≥n correspondientes para que se arranque correctamente configurada. El √∫ltimo archivo que nos queda por ver es el test que nos crea que como es natural esta vac√≠o‚Ä¶ pero ya vemos que tiene 2 anotaciones, @RunWith(SpringRunner.class) para que el tets use el runner de Spring y @SpringBootTest que lo que hace es buscar la clase anotada con @SpringBootApplication y usarla para cargar el contexto completo de la aplicaci√≥n para hacer el test por lo que por lo general no vamos a usarla ya que normalmente no vamos a necesitar cargar toda la aplicaci√≥n a no ser que queramos hacer una prueba completa de todas las capas de muestra aplicaci√≥n. package com.programandoointentandolo.tsb; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner; @RunWith(SpringRunner.class) @SpringBootTest public class TutorialSpringBootApplicationTests { @Test public void contextLoads() { } } Pero como no todo puede ser perfecto si estamos usando en nuestro proyecto una jdk posterior a la 8 como en nuestro caso que estamos usando la 10 e intentamos ejecutar el test nos va a saltar una excepci√≥n, para solucionarlo solo tenemos que a√±adir una demencia al pom.xml, porque esta librer√≠a ya no est√° incluida dentro de la jdk, bueno en realidad si lo sigue estando hasta la pr√≥xima versi√≥n pero para que nos funcione tendr√≠amos que a√±adir el comando ‚Äìadd-modules java.xml.bind pero no es una soluci√≥n muy limpia y menos sabiendo que con la siguiente versi√≥n ya no nos va a funcionar. <dependency> <groupId>javax.xml.bind</groupId> <artifactId>jaxb-api</artifactId> <version>2.3.0</version> </dependency> 3. ARRANCANDO NUESTRO EJEMPLO CON SPRING BOOT Una vez que ya tenemos el proyecto creado y hemos echado un vistazo a lo que nos vamos a encontrar los proyectos de Spring Boot ya estamos listos para crear un proyecto sencillo y probar nuestra primera aplicaci√≥n usando Spring Boot. Para no alargar esto innecesariamente no voy a incluir aqu√≠ el c√≥digo de los controllers, services, ‚Ä¶ ya que no es el prop√≥sito de este post y ya lo iremos viendo y desarrollando m√°s en profundidad de forma separada para que sea m√°s f√°cil de seguir. Bueno, pues vamos a ver como probar nuestra aplicaci√≥n, para arrancarla desde nuestro IDE podemos hacer click derecho sobre nuestro proyecto y despu√©s elegimos Run As y Spring Boot App. Arrancar aplicacion Spring Boot Tambi√©n podemos hacerlo desde el Boot Dashboard, que es una vista muy similar a Servers pero en este caso para las aplicaciones de Spring Boot Vista Boot Dashboard Abrimos la url en nuestro navegador y voila, ya tenemos nuestra aplicaci√≥n funcionando. Aplicacion Spring Boot + Thymeleaf + Bootstrap Desplegar nuestra aplicaci√≥n desde el STS es f√°cil, pero ¬øy desplegarla sin √©l? pues la verdad es que es incre√≠blemente f√°cil, solo tenemos que coger el jar que se habr√° generado en la carpeta target del proyecto y ejecutarlo con java -jar tutorial-spring-boot-0.0.1-SNAPSHOT.jar y aplicaci√≥n desplegada. Arrancando aplicacion Spring Boot desde la consola El c√≥digo completo del de este ejemplo esta en mi repositorio de github tutorial-spring-boot pero como el proyecto va a ir evolucionando a medida que vayamos viendo m√°s cosas puede que el c√≥digo no sea exactamente el mismo, pero para eso con cada nuevo post creare una release para que se pueda consultar como se encontraba el proyecto en ese momento y sea sencillo encontrar el estado correspondiente o para descargar directamente el c√≥digo correspondiente al post, el enlace correspondiente a esta release esta aqu√≠."
    },

    {
        "id": 76,
        "autor": "Acodigo",
        "pagina": "acodigo",
        "fecha": "01/04/2017",
        "titulo": "Spring Boot : Crear una Aplicaci√≥n Web",
        "link": "http://acodigo.blogspot.com/2017/04/spring-boot-crear-una-aplicacion-web.html",
        "contenido": "Spring Boot es un sub-proyecto Spring que simplifica y agiliza el proceso de creaci√≥n y desarrollo de aplicaciones web o de escritorio que utilicen el Framework Spring, la configuraci√≥n requerida para iniciar una aplicaci√≥n, de cualquier tipo, es m√≠nima y autom√°tica, Spring Boot se auto-configura analizando el classpath, adem√°s se elimina por completo la necesidad de tener archivos de configuraci√≥n XML, a pesar de ello el mecanismo de configuraci√≥n se mantiene bastante flexible, permiti√©ndonos personalizar la configuraci√≥n siempre que lo necesitemos. Nos es necesario tener alguna herramienta especial para crear nuestras aplicaciones, es posible utilizar la mayor√≠a de los IDEs como: NetBeans, Eclipse, IntelliJ, etc., tampoco es un requisito, pero si una buena opci√≥n utilizar una herramienta que nos facilite la administraci√≥n de las dependencias, en este serie de cursos usaremos Maven, debe ser la versi√≥n 3.2 o superior, obviamente tambi√©n requerimos el JDK la versi√≥n 1.6 en adelante. La manera mas sencilla de crear el proyecto inicial es dirigirse a la web: https://start.spring.io aqu√≠ seleccionar√°s el tipo de proyecto y le versi√≥n a utilizar, en la secci√≥n Project Metadata introduces la informaci√≥n correspondiente a tu proyecto, en la secci√≥n Dependencies deber√°s seleccionar las dependencias requeridas por tu proyecto, por ejemplo, para crear una aplicaci√≥n web agregamos Web, para acceso a datos JPA, puedes agregar todos los que sean necesarios, para finalizar presiona Generate Project para descargar el proyecto en un archivo comprimido ZIP. spring boot starter Presionando en el enlace que se encuentra en la parte inferior, que dice: ‚ÄúSwitch to the full version‚Äù, expandir√°s la ventana y se mostrar√° m√°s detalladamente las opciones de configuraci√≥n. Para abrir el proyecto con NetBeans 8 nos vamos al men√∫ File | Open Project... y localizamos la carpeta descomprimida del proyecto que acabamos de generar. Lo primero que debemos ver es el archivo pom.xml, lo abrimos, clic derecho sobre el proyecto y seleccionamos Open POM, veremos: <parent> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-parent</artifactId> <version>1.5.1.RELEASE</version> <relativePath/> <!-- lookup parent from repository --> </parent> Con esto heredamos las funcionalidades que nos permitir√°n administrar las dependencias de nuestro proyecto de una manera f√°cil. <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-jdbc</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-thymeleaf</artifactId> </dependency> <dependency> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-starter-web</artifactId> </dependency> Para iniciar un proyecto de manera r√°pida contamos con los spring-boot-starter-*, estos nos permiten administrar un grupo de dependencias para un proyecto en especifico, por ejemplo: spring-boot-started-web contiene todas las dependencias necesarias para crear una aplicaci√≥n web MVC, spring-boot-starter-jdbc a√±ade las dependencias requeridas para realizar el acceso a datos con la API JDBC, spring-boot-starter-thymeleaf nos proporciona las dependencias que requiere el motor de plantillas Thymeleaf el cual usaremos para generar nuestras vistas, existen muchos m√°s, para todo tipo de proyectos. <build> <plugins> <plugin> <groupId>org.springframework.boot</groupId> <artifactId>spring-boot-maven-plugin</artifactId> </plugin> </plugins> </build> Este plugin maven ser√° el encargado de empaquetar la aplicaci√≥n en el correspondiente archivo jar, este contiene todo los necesario para ejecutarse con el comando java -jar. spring boot tutorial Esta es la estructura de nuestro proyecto inicial, si vemos la clase IntroduccionApplication encontraremos el m√©todo main(String[] args) este es el punto de inicio de nuestra aplicaci√≥n, el m√©todo SpringApplication.run() es el encargado de iniciar la aplicaci√≥n, como argumento le indicamos la clase de configuraci√≥n y los argumentos de comandos, la clase de configuraci√≥n es la propia clase IntroduccionApplication la misma usa la anotaci√≥n @SpringBootApplication la cual es equivalente a utilizar las anotaciones: @Configuration, @EnableAutoConfiguration y @ComponentScan, estas anotaciones hacen lo siguiente: @Configuration: Indica que esta es una clase usada para configurar el contenedor Spring. @ComponentScan: Escanea los paquetes de nuestro proyecto en busca de los componentes que hayamos creado, ellos son,  las clases que utilizan las siguientes anotaciones: @Component, @Service, @Controller, @Repository. @EnableAutoConfiguration: Habilita la configuraci√≥n autom√°tica, esta herramienta analiza el classpath y el archivo application.properties para configurar nuestra aplicaci√≥n en base a las librer√≠as y valores de configuraci√≥n encontrados, por ejemplo: al encontrar el motor de bases de datos H2 la aplicaci√≥n se configura para utilizar este motor de datos, al encontrar Thymeleaf se crearan los beans necesarios para utilizar este motor de plantillas para generar las vistas de nuestra aplicaci√≥n web. Si lo deseamos podemos personalizar la aplicaci√≥n, para ello creamos una instancia de la clase SpringApplication y cambiamos el comportamiento deseado, por ejemplo, para deshabilitar el banner usamos Banner.Mode.OFF. import org.springframework.boot.Banner; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class IntroduccionApplication { public static void main(String[] args) { SpringApplication app = new SpringApplication(IntroduccionApplication.class); app.setBannerMode(Banner.Mode.OFF); app.run(args); } } En el constructor usamos indicamos la clase de configuraci√≥n, con el m√©todo app.run(args) iniciamos ala ejecuci√≥n de la aplicaci√≥n. Si deseas crea una aplicaci√≥n de escritorio no web debes desactivar los componente web, lo hacen del siguiente modo: app.setWebEnvironment(false); Nuestro primer controlador Crearemos nuestro primer controlador que llamaremos HomeController y lo ubicaremos en el paquete carmelo.spring.web es importante que los controladores se ubiquen en un paquete dentro del paquete que contiene la clase principal para que puedan ser detectados correctamente. package carmelo.springboot.web; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HelloController { @RequestMapping( /hello ) public String showHello(Model model){ model.addAttribute( saludo ,  Mi primera aplicacion web Spring Boot ); return  hello ; } } Este controlador responde a la petici√≥n HTTP localhost:8080/hello, a√±ade un atributo al modelo y retorna el nombre l√≥gico de la vista, hello, para m√°s detalles puedes ver: Spring MVC Controladores. Las vistas ser√° generadas con motor de plantillas Thymeleaf, seg√∫n nuestro controlador requerimos el archivo src/main/resources/templates/hello.html. <!DOCTYPE html> <html xmlns:th= http://www.thymeleaf.org > <head> <meta charset= UTF-8 /> <title>Spring Boot</title> </head> <body> <p th:text= ${saludo}  /> </body> </html> Tambi√©n vamos a a√±adir el archivo src/main/resources/static/index.html esta es la p√°gina que se muestra al agregar a localhost:8080/ de modo que en esta p√°gina solo a√±adiremos un enlace que nos lleve a localhost:8080/hello para ver nuestro controlador funcionando. <!DOCTYPE html> <html> <head> <title>Spring Boot</title> <meta charset= UTF-8 > </head> <body> <a href= /hello >Go Home</a> </body> </html> spring boot web Con esto tenemos nuestra primera aplicaci√≥n web Spring Boot lista. Si deseamos cambiar la ubicaci√≥n y la extensi√≥n de las plantillas editamos el archivo de propiedades application.properties para agregar las siguientes configuraciones: spring.thymeleaf.prefix=classpath:/views/ spring.thymeleaf.suffix=.html La primera indica las carpetas donde se encuentran las plantillas y la segunda la extensi√≥n de las mismas, con este ejemplo nuestra vista ser√° src/main/resources/views/hello.html. Ejecutar una aplicaci√≥n Spring Boot Spring Boot trabaja con servidor integrado, por defecto Apache Tomcat, para ejecutar nuestra aplicaci√≥n, en NetBeans IDE solo presionamos Run, si todo est√° correcto podemos ir al navegar y deberemos ver nuestra aplicaci√≥n. spring boot run Una aplicaci√≥n web Spring Boot puede ejecutarse desde la consola de comandos sin problemas, de la siguiente manera: java -jar target/introduccion-0.0.1-SNAPSHOT.jar image Nuestra aplicaci√≥n en el navegador: image Tambi√©n es posible ejecutar una aplicaci√≥n usando el Spring Boot Maven Plugin con el siguiente comando: mvn spring-boot:run Debemos tener presente que si una instancia de la aplicaci√≥n est√° ejecut√°ndose e intentamos iniciar otra instancia se producir√° un error ya que el puerto estar√° en uso, es posible cambiar el puerto mediante el archivo application.properties a√±adiendo server.port=8178 donde 8178 es el nuevo puerto. En este tutorial hemos visto la simplicidad que nos aporta Spring Boot a la hora de crear aplicaciones web MVC, no requerimos configuraci√≥n XML, el DispatcherServlet, ViewResolver, y todo los requerido para crear una aplicaci√≥n web fue configurado de manera autom√°tica, no fue necesario desplegar la aplicaci√≥n en un servidor externo, estos son algunos de los beneficios obtenidos al utilizar esta herramienta, en pr√≥ximos tutoriales veremos mas caracter√≠sticas interesantes."
    },

    {
        "id": 77,
        "autor": "Javadesde0",
        "pagina": "javadesde0",
        "fecha": "23/06/2019",
        "titulo": "Creando un proyecto de Spring Boot",
        "link": "https://javadesde0.com/creando-un-proyecto-de-spring-boot/",
        "contenido": "Para crear un proyecto de Spring, tenemos varias opciones. Las 2 m√°s populares son: Crear un proyecto desde Spring Boot Initializer la herramienta web que nos proporciona Pivotal. Crear el proyecto desde el IDE mediante al Command Line Tool (CLI), en nuestro caso el IDE elegido ser√° Spring Tool Suite 4. En mi opini√≥n, la m√°s sencilla es desde el propio Spring Tool Suite 4, ya que nos carga el proyecto autom√°ticamente en el explorador de proyectos del IDE. Y as√≠, ya podemos trabajar directamente con √©l. Creando un proyecto de Spring mediante a Spring Boot Initializer Para crear un proyecto desde la web, visitaremos la web https://start.spring.io/ La configuraci√≥n que utilizaremos ser√° mediante a Maven, utilizando Java, y Spring Boot 2.1.6 (quiz√°s esta versi√≥n cambie est√©s realizando este tutorial). Si desplegamos el Options, podemos ver que podemos seleccionar la versi√≥n de Java. Nosotros utilizaremos la 8. Si bajamos un poco m√°s, podemos ver el apartado de dependencias. En nuestro caso, vamos a a√±adir spring Web Started. La podemos buscar desde el buscador, o bien ir al icono de alado, donde nos aparecer√° un listado con dependencias y seleccionarla. Y finalmente, pulsamos en generar proyecto. Finalmente, se nos descargar√° el proyecto en archivo .zip, El cual vamos a descomprimir en el mismo directorio de descargas donde se nos ha descargado el proyecto Cargando un proyecto de Spring Boot Ahora, vamos a cargar un proyecto de maven, esto nos vale para cualquier proyecto, no solamente para los que creamos desde https://start.spring.io/ . Para realizar la carga, vamos a Project Explorer > Bot√≥n derecho > Import‚Ä¶ Seleccionamos la opci√≥n de proyecto de Maven existente: Seleccionamos el directorio donde se encuentra (si hab√©is seguido las indicaciones estar√° en descargas). Y una vez seleccionado, podemos ver como se realiza la importaci√≥n y la descarga de dependencias. Finalmente, y una vez concluida la descarga de dependencias, ya tenemos nuestro proyecto cargado en Spring Tool Suite con nuestro fichero pom.xml Creando un proyecto Maven mediante a Spring Tool Suite 4 Anteriormente si hab√©is seguido el tutorial paso a paso hasta aqu√≠, hemos creado un proyecto, por lo que no podemos repetir el mismo nombre. Ya que nos generar√≠a un error. Llegados a este punto, tenemos dos opciones, eliminar el proyecto o ponerle otro nombre diferente. En mi caso, voy a borrar el proyecto. Eliminando un proyecto de Spring Boot Si no marcamos el delete project contents on disk, realmente estamos √∫nicamente eliminando el proyecto del explorador de proyectos del IDE. Pero a√∫n existir√≠a el directorio. Bien, tras ver como realizamos un proyecto desde la web de https://start.spring.io/ vamos a ver como realizarlo con Spring Tool Suite. Esta manera, para m√≠ es la m√°s r√°pida y sencilla, aunque mejor que decirlo por aqu√≠ es que lo comprobareis vosotros mismos. Abrimos nuestro IDE y vamos a File > New > Project Seleccionamos Spring Starter Project Y a√±adimos la informaci√≥n del proyecto: Y finalmente, a√±adimos las dependencias y pulsamos sobre finalizar. Una vez finalizada la creaci√≥n, como en la creaci√≥n anterior, realizar√° la importaci√≥n y descargar√° dependencias. Y ya tenemos el proyecto listo para trabajar sobre el: Pom resultante de ambos proyectos Si observamos el pom que se nos a creado en el proyecto, destaca principalmente el ver la versi√≥n de Java con al que estamos trabajando, en nuestro caso la 1.8. Tambi√©n podemos apreciar que pese a que hemos marcado una sola dependencia, tenemos dos. Esto es debido a que autom√°ticamente, al incluir la dependencia spring-boot-starter-web , tambi√©n se nos incluye la dependencia de testing (spring-boot-starter-test)."
    },

    {
        "id": 78,
        "autor": "Cecilio √Ålvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "11/05/2020",
        "titulo": "Spring @Autowired y la inyecci√≥n de dependencias",
        "link": "https://www.arquitecturajava.com/spring-autowired-y-la-inyeccion-de-dependencias/",
        "contenido": "Spring @Autowired es una de las anotaciones m√°s habituales cuando trabajamos con Spring Framework ya que se trata de la anotaci√≥n que permite inyectar unas dependencias con otras dentro de Spring . Spring @Autowired y su funcionamiento Normalmente estamos acostumbrados a usar @AutoWired a nivel de la propiedad que deseamos inyectar. Spring funciona como una mega factoria de objetos. Cada clase se registra para instanciar objetos con alguna de las anotaciones @Controller ,@Service ,@repository o @RestController. Spring inyeccion dependencia Una vez que los objetos estan creados la anotaci√≥n Spring @Autowired se encarga de construir las ligazones entre los distintos elementos Spring @Autowired Por ejemplo este caso es habitual cuando tenemos un servicio y un repositorio. Vamos a verlo usando Spring Boot package com.arquitecturajava.wired; import java.util.ArrayList; import java.util.List; import org.springframework.stereotype.Component; import org.springframework.stereotype.Repository; @Repository public class LibroRepository { public List<Libro> buscarTodos() { List<Libro> lista= new ArrayList<Libro>(); lista.add(new Libro ( 1 , java , pedro )); lista.add(new Libro ( 2 , python , gema )); return lista; } } Como podemos ver tenemos el LibroRepository como primer componente y le queremos enlazar desde un Servicio. package com.arquitecturajava.wired; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class LibroRestService { @Autowired LibroRepository repositorio; @RequestMapping( /libros ) public List<Libro> buscarTodos() { return repositorio.buscarTodos(); } } Ahora tenemos los dos elementos enlazados y un ServicioREST publicado por lo tanto si ejecutamos la aplicaci√≥n de Spring Boot dispondremos de una Url con un listado de Libros disponible Spring @Autowrired rest Spring Testing y Wiring Hoy por hoy las metodolog√≠as de TDD cada d√≠a se usan m√°s y aunque este uso de la anotacion @Autowired es el m√°s habitual suele ser m√°s pr√°ctico y c√≥modo para el manejo de test realizar un @Autowired a nivel de constructores por lo tanto el c√≥digo quedar√≠a as√≠: package com.arquitecturajava.wired; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class LibroRestService { LibroRepository repositorio; @Autowired public LibroRestService(LibroRepository repositorio) { this.repositorio=repositorio; } @RequestMapping( /libros ) public List<Libro> buscarTodos() { return repositorio.buscarTodos(); } } De esta manera el c√≥digo queda m√°s limpio , flexible y m√°s sencillo de usar cuando utilicemos Test Driven Development."
    },

    {
        "id": 79,
        "autor": "Iv√°n Salas",
        "pagina": "programandoointentandolo",
        "fecha": "22/05/2013",
        "titulo": "INYECCI√ìN DE DEPENDENCIAS EN SPRING",
        "link": "https://programandoointentandolo.com/2013/05/inyeccion-de-dependencias-en-spring.html",
        "contenido": "La inyecci√≥n de dependencias es quiz√°s la caracter√≠stica m√°s destacable del core de Spring Framework, que consiste que en lugar de que cada clase tenga que instanciar los objetos que necesite, sea Spring el que inyecte esos objetos, lo que quiere decir que es Spring el que creara los objetos y cuando una clase necesite usarlos se le pasaran (como cuando le pasas un par√°metro a un m√©todo). La inyecci√≥n de dependencias es una forma distinta de dise√±ar aplicaciones, si estas empezando con Spring (como yo) ya habr√°s visto que en muchos sitios usan los t√©rminos inyecci√≥n de dependencia (DI) e inversi√≥n de control (IoC) de forma indistinta y aunque no son sin√≥nimos, sino que m√°s bien la inyecci√≥n de dependencia ser√≠a una forma de inversi√≥n de control. Pero probablemente te preguntaras en que consiste la inyecci√≥n de dependencia y que ventajas tiene su uso, pues aqu√≠ voy a intentar explicar lo que yo he entendido con unos ejemplos para verlo de una forma m√°s intuitiva, que para ver definiciones ya hay muchos libros. La DI consiste en que en lugar de que sean las clases las encargadas de crear (instanciar) los objetos que van a usar (sus atributos), los objetos se inyectaran mediante los m√©todos setters o mediante el constructor en el momento en el que se cree la clase y cuando se quiera usar la clase e cuesti√≥n ya estar√° lista, en cambio sin usar DI la clase necesita crear los objetos que necesita cada vez que se use. En Spring hay un Contendor DI que es el encargado de inyectar a cada objeto los objetos que necesita (de los que depende) seg√∫n se le indique ya sea en un archivo de configuraci√≥n XML o mediante anotaciones. Con esta peque√±a explicaci√≥n te puedes hacer una idea de en que consiste la inyecci√≥n de dependencia, vamos ahora a ver cual es el sentido de su uso. La que nos ofrece la inyecci√≥n de dependencias es desacoplamiento y tambi√©n que los objetos son instanciados en el Contenedor DI y se inyectan donde sea necesario de forma que pueden ser reutilizados. Un ejemplo t√≠pico para ver su utilidad es el de una clase que necesita una conexi√≥n a base de datos, sin DI si varios usuarios necesitan usar esta clase se tendr√°n que crear m√∫ltiples conexiones a la base de datos con la consiguiente posible perdida de rendimiento, pero usando la inyecci√≥n de dependencia las dependencias de la clase (sus atributos), son instanciados una √∫nica vez cuando se despliega la aplicaci√≥n y se comparten por todas las instancias de modo que una √∫nica conexi√≥n a base de datos es compartida por m√∫ltiples peticiones. En este caso esta bien que sea una √∫nica instancia pero habr√° casos en los que no nos interesar√° esta opci√≥n que es la que se usa por defecto por lo que Spring nos da la opci√≥n por si queremos que nuestros objetos no usen el patr√≥n singleton. Y en lo referente al desacoplamiento como no es necesario instanciar en una clase los objetos que necesita sino que son inyectados si la clase que necesita cambia no es necesario modificar nada en la clase que hacia uso de ella. Y en lo referente al desacoplamiento al no tener que instanciar las dependencias si alguna cambia no hay que modificar nada pues esa clase no estar√° instanciada en ning√∫n sitio de nuestra clase (Clase c = new clase();). Vamos a ver unos ejemplos de como se hace la DI mediante settters, mediante el constructor y con el uso de anotaciones para no tener que escribir nada en el xml. EJEMPLO DE INYECCI√ìN DE DEPENDENCIA MEDIANTE SETTTERS Para que se vean bien las cosas vamos a crear una aplicaci√≥n de escritorio, en una aplicaci√≥n web la aplicaci√≥n es la misma pero como hay m√°s archivos de configuraci√≥n es m√°s f√°cil equivocarse aunque como digo la inyecci√≥n de dependencia se hace exactamente igual, salvo que para una aplicaci√≥n de escritorio hay que indicarle en el Main donde se encuentra el archivo en el que est√°n declarados los beans y en una aplicaci√≥n web se hace en el web.xml. En este primer ejemplo vamos a usar una clase Libro que entre sus atributos tendr√° uno de la clase Autor y en el Main mostraremos los datos del libro. package com.blogspot.programandoointentandolo; public class Libro { private String titulo; private Autor autor; private String genero; private String editorial; private int edicion; private int paginas; // Getters y Setters } package com.blogspot.programandoointentandolo; public class Autor { private String nombre; private String apellido; // Getters y Setters } La clase Libro es un simple POJO y como vamos a inyectar las dependencias mediante setters pues l√≥gicamente deber√° disponer de ellos (lo mismo para Autor) y en el Main para hacer uso de la ID primero debemos de cargar el xml en el que estar√°n definidos los beans y luego obtenemos el que nos interesa (libro). package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.BeanFactory; import org.springframework.context.support.ClassPathXmlApplicationContext; public class Main { public static void main(String[] args) { BeanFactory factory = new ClassPathXmlApplicationContext( META-INF/spring/app-context.xml ); Libro libro = (Libro) factory.getBean( libro ); System.out.println( -   + libro.getTitulo()); System.out.println( -   + libro.getAutor().getNombre() +     + libro.getAutor().getApellido()); System.out.println( -   + libro.getEditorial()); System.out.println( -   + libro.getGenero()); System.out.println( -   + libro.getEdicion()); System.out.println( -   + libro.getPaginas()); } } Vamos con el app-context.xml que ser√° donde definamos los beans para poder inyectarlos donde lo necesitemos: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <bean id= libro  class= com.blogspot.programandoointentandolo.Libro > <property name= titulo  value= Aprendiendo Spring /> <property name= autor  ref= autor /> <property name= genero  value= Aventuras /> <property name= edicion  value= 2 /> <property name= paginas  value= 257 /> </bean> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <property name= nombre  value= Luis  /> <property name= apellido  value= Perez  /> </bean> </beans> Viendo el c√≥digo anterior te puedes hacer una idea bastante buena de que es lo que hace sin ninguna explicaci√≥n pero vamos a explicarlo. En primer lugar las clases se definen con la etiqueta <bean> y se deben de indicar el atributo class que indica donde esta la clase de la que ser√° el bean y si se quiere usar en otro lugar el atributo id que nos servir√° como identificador del bean. Dentro de cada bean se pueden indicar las propiedades que se quieren inyectar con la etiqueta property, el atributo name hace referencia al nombre del atributo que se quiere inyectar, por ejemplo el primero es para inyectar el titulo, y despu√©s puede tener un atributo value si le queremos inyectar un String, int,‚Ä¶ y el atributo ref que lo usaremos cuando queramos inyectar otro bean, es el caso de autor, y en el atributo ref debemos de poner el id del bean que queremos inyectarle, en este caso tambi√©n es autor. Y con esto cuando ejecutemos la aplicaci√≥n veremos como se nos imprimen los valores que hemos introducido en xml sin haber tenido que instanciar en ning√∫n momento ning√∫n objeto ni de la clase Libro ni de la clase Autor. Pues as√≠ de sencilla es la inyecci√≥n de dependencia. EJEMPLO DE INYECCI√ìN DE DEPENDENCIA MEDIANTE EL CONSTRUCTOR Adem√°s de poder inyectar mediante m√©todos setters tambi√©n se puede inyectar mediante constructor aunque es mejor la primera opci√≥n. Vamos a ver en este ejemplo como inyectar las propiedades del Autor mediante constructor para lo cual la clase Autor deber√° de tener un constructor con los par√°metros nombre y apellido y no hace falta que tenga m√©todos setters. No hace falta modificar otra cosa del resto del c√≥digo java. Y el xml para poder inyectar mediante constructor en el bean autor es este: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <bean id= libro  class= com.blogspot.programandoointentandolo.Libro > <property name= titulo  value= Aprendiendo Spring /> <property name= autor  ref= autor /> <property name= genero  value= Aventuras /> <property name= edicion  value= 2 /> <property name= paginas  value= 257 /> </bean> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <constructor-arg value= Luis  /> <constructor-arg value= Perez  /> </bean> </beans> Los par√°metros del libro los seguimos inyectando mediante setters pero para el autor usaremos el constructor para lo que debemos de cambiar property por constructor-arg y solo le indicamos el value o ref si fuese el caso, pero no hay que indicar el name ya que estos atributos se pasaran en orden al constructor por lo que debemos de tener cuidado de ponerlos en el orden correcto. EJEMPLO DE INYECCI√ìN DE DEPENDENCIA CON ANOTACIONES De las dos formas anteriores era necesario indicar en el archivo de configuraci√≥n que beans pod√≠an ser inyectados en otros y sobre los que se quer√≠an inyectar. Mediante las anotaciones podemos hacer ambas cosas o solo una si se quiere, por ejemplo podemos declarar los beans en el xml y usar anotaciones para inyectarlos en lugar de usar <property name=¬ªautor¬ª ref=¬ªautor¬ª>. Antes de empezar voy a poner una lista de las anotaciones que voy a comentar: @Component:Sustituye la declaraci√≥n del bean en el xml. @Autowired:Sustituye la declaraci√≥n de los atributos del bean en el xml. @Qualifier(¬´nombreBean¬ª):Sirve para indicar que clase es la que se debe inyectar. @Required:Indica si el atributo es obligatorio. @Service, @Repository y @Controller:Son estereotipos de @Component y se usan para indicar que la clase sera un servicio (@Service), una clase de acceso a datos (@repository) o un controlador (@Controller). @PostConstruct:Ejecuta el metodo con esta anotaci√≥n despues de crear el objeto. @PreDestroy:Ejecuta el metodo con esta anotaci√≥n antes de destruir el objeto. @Scope:Sirve para indicar el ambito en el que se encontrara el bean. Las anotaciones de la lista anterior son propias de Spring pero tambi√©n se pueden usar anotaciones propias del standar Java EE como las 2 siguientes: @Inject:Se puede usar en lugar de @Autowired. @Resource(¬´nombreBean¬ª):Sustituye el uso de las anotaciones @Autowired y @Qualifier(¬´nombreBean¬ª) de forma que es necesaria una sola anotaci√≥n. @AUTOWIRED Para empezar vamos a ver la anotaci√≥n @Autowired que nos permite no tener que definir la propiedad que se quiere inyectar en el xml dentro del bean. La anotaci√≥n @Autowired se puede poner encima del atributo que se quiere inyectar, encima del m√©todo setter de dicho m√©todo o tambi√©n encima del constructor y dependiendo de donde se ponga la inyecci√≥n se har√≠a por atributo, por setter o por constructor como es l√≥gico. Respecto al c√≥digo que ten√≠amos sin usar anotaciones hay que modificar la clase Libro a√±adiendo la anotaci√≥n @Autowired de cualquiera de las 3 formas que dec√≠a, en este ejemplo anotamos el atributo. import org.springframework.beans.factory.annotation.Autowired; public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired private Autor autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; // Setters y getters } Y en el xml quedar√≠a as√≠: <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <!-- Habilita el uso de anotaciones --> <context:annotation-config /> <bean id= libro  class= com.blogspot.programandoointentandolo.Libro /> <bean id= autor  class= com.blogspot.programandoointentandolo.Autor > <constructor-arg value= Luis  /> <constructor-arg value= Perez  /> </bean> </beans> El bean autor sigue igual ya que no hemos hecho ninguna anotaci√≥n en el, pero en el bean libro ahora no hay ning√∫n atributo ya que ahora hemos usado la anotaci√≥n @Autowired para inyectar el autor, y el resto de campos que son simples strings e ints simplemente est√°n inicializados en la clase aunque en un ejemplo m√°s ¬´serio¬ª pues se le dar√≠an valores con los setters por ejemplo aunque para el caso de ver como funcionan las anotaciones eso no aporta nada. Adem√°s de que en el bean libro ya no est√°n los atributos para poder usar la anotaci√≥n @Autowired es necesario incluir <context:annotation-config /> para indicar que vamos a usar esta anotaci√≥n. @COMPONENT Esta anotaci√≥n nos evita la necesidad de declarar el bean en el xml, vamos a anotar las clases Libro y Autor con @Component y de este modo ya no tendremos ning√∫n bean en el xml, de modo que el xml solo tendr√° que contener la siguiente l√≠nea en la que le indicamos el paquete apartir del que se buscaran las clases anotadas con @Component o cualquiera de sus estereotipos y tambi√©n sustituye a <context:annotation-config /> que usemos por si solo quer√≠amos usar @Autowired. <?xml version= 1.0  encoding= UTF-8 ?> <beans xmlns= http://www.springframework.org/schema/beans xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance  xmlns:context= http://www.springframework.org/schema/context xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd > <!-- Habilita el uso de anotaciones --> <context:component-scan base-package= com.blogspot.programandoointentandolo  /> </beans> Y en lo referente a las clases Autor y Libro quedarian de la siguiente forma: package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component public class Autor { private String nombre =  Luis ; private String apellido =  Perez ; public Autor(){} // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired private Autor autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } Adem√°s de anotar la clase con @Component tambien hay que a√±adir un constructor sin par√°metros, en el caso de que tuvi√©semos alguno con par√°metros ya que al usar la anotaci√≥n @Component el objeto se crea con este constructor y sino lo tenemos no compilar√°. @QUALIFIER Con esta anotaci√≥n podemos indicar el id del bean que se quiere inyectar, esta anotaci√≥n se usa cuando el atributo que vamos a inyectar es una interfaz de la que hay varias implementaciones y entonces ser√° mediante esta anotaci√≥n con la que le diremos cual es la clase que queremos inyectar. Tambi√©n se puede usar por ejemplo si en el xml declaramos varios beans que aunque sean de la misma clase (tengan el mismo atributo class) tengan un id distinto. Aunque en los ejemplos que he puesto no he puesto ninguna interfaz pues no aporta nada a la explicaci√≥n lo normal ser√° que las clases que se inyectan sean interfaces para hacer el c√≥digo m√°s desacoplado y facilitar las posibles futuras modificaciones. Por ejemplo si en lugar de la clase autor directamente tuvi√©semos una interfaz AutorInterfaz y dos clases AutorDesconocido y AutorConocido package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component( autordesconocido ) public class AutorDesconocido implements AutorInterfaz{ private String nombre =  Luis ; private String apellido =  Perez ; // Setters y getters } package com.blogspot.programandoointentandolo; import org.springframework.stereotype.Component; @Component( autorconocido ) public class AutorConocido implements AutorInterfaz{ private String nombre =  Antonio ; private String apellido =  Fernandez ; // Setters y getters } Como en @Qualifier hemos indicado autorconocido se inyectara la clase AutorConocido pero si quisi√©semos cambiar para que se inyectara AutorDesconocido o cualquier otra clase que implementase AutorInterfaz solo tendr√≠amos que indicar en @Qualifier el nombre del bean que queremos inyectar. @REQUIRED Esta anotaci√≥n creo que esta bastante claro para que se usa, si queremos que un campo sea obligatorio lo anotaremos con @Required. Para que el autor fuese obligatoria la clase Libro ser√≠a as√≠: package com.blogspot.programandoointentandolo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} // Setters y getters } @POSTCONSTRUCT Y @PREDESTROY Estas son anotaciones para m√©todos y las usaremos si queremos que se ejecute un m√©todo justo despu√©s de que se haya creado la clase (objeto de la clase) o antes de que se destruya. import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} @PostConstruct public void saludar(){ System.out.println( Hola ); } @PreDestroy public void despedirse(){ System.out.println( Adios ); } // Setters y getters } @SCOPE Con esta anotaci√≥n indicamos cuando se crearan instancias de la clase con esta anotaci√≥n y en que √°mbito. Si no se usa la anotaci√≥n @Scope (valor por defecto) el scope es singleton. Los posibles valores son: singleton: Se crea una unica instancia del bean para toda la aplicaci√≥n. prototype: Se crea una nueva instacia del bean cada vez. request: Se crea una nueva instacia del bean para cada petici√≥n HTTP request. session: Se crea una nueva instacia del bean por sesi√≥n HTTP. globalSession: Se crea una nueva instacia del para cada sesi√≥n HTTP global. Las 3 ultimas aunque supongo que se ve por el nombre solo son para aplicaciones web mientras que las dos primeras pueden usarse en cualquier tipo de aplicaci√≥n Spring. Y para finalizar si quisi√©semos que se crease una instancia de la clase Libro cada vez usar√≠amos @Scope(¬´prototype¬ª). import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; @Component @Scope( prototype ) public class Libro { private String titulo =  Aprendiendo Spring ; @Autowired @Qualifier( autorconocido ) @Required private AutorInterfaz autor; private String genero =  Aventuras ; private String editorial =  Una ; private int edicion = 2; private int paginas = 257; public Libro() {} @PostConstruct public void saludar(){ System.out.println( Hola ); } @PreDestroy public void despedirse(){ System.out.println( Adios ); } // Setters y getters } Despu√©s de ver como hacer las inyecciones de dependencias con anotaciones probablemente te preguntaras si es mejor o peor usar anotaciones. Desde el punto de vista de que es m√°s f√°cil y m√°s r√°pido esta claro que ganan las anotaciones y desde el punto de vista de tener todo centralizado mejor usar el xml porque con las anotaciones esta repartido por toda la aplicaci√≥n por lo que para modificar algo ser√≠a necesario buscarlo, modificarlo y recompilarlo mientras que con el xml todo esta en el mismo sitio y con cambiar el xml esta todo listo sin hacer nada m√°s. Entonces podr√≠amos decir que las anotaciones son ideales durante la fase de desarrollo porque el c√≥digo esta cambiando constantemente y cuanto m√°s r√°pido sea hacer un cambio mejor y una vez que la aplicaci√≥n ya sea ¬´estable¬ª se sustituyen las anotaciones y de este modo tenemos las ventajas de ambas opciones en los momentos en las que los necesitamos, aunque no se si tiene demasiado sentido hacer esto"
    },

    {
        "id": 80,
        "autor": "Rub√©n Pahino",
        "pagina": "campusmvp",
        "fecha": "31/03/2020",
        "titulo": "¬øQu√© son Spring framework y Spring Boot? Tu primer programa Java con este framework",
        "link": "https://www.campusmvp.es/recursos/post/que-son-spring-framework-y-spring-boot-tu-primer-programa-java-con-este-framework.aspx",
        "contenido": "Si desarrollas con Java, o lo has hecho en alg√∫n momento de los √∫ltimos a√±os, seguramente te suene Spring Framework, aunque sea de o√≠das. Spring Framework es un framework Open Source que facilita la creaci√≥n de aplicaciones de todo tipo en Java, Kotlin y Groovy. Si bien es cierto que, por lo que es m√°s conocido es por la inyecci√≥n de dependencias, Spring Framework est√° dividido en diversos m√≥dulos que podemos utilizar, ofreci√©ndonos muchas m√°s funcionalidades: Core container: proporciona inyecci√≥n de dependencias e inversi√≥n de control. Web: nos permite crear controladores Web, tanto de vistas MVC como aplicaciones REST. Acceso a datos: abstracciones sobre JDBC, ORMs como Hibernate, sistemas OXM (Object XML Mappers), JSM y transacciones. Programaci√≥n orientada a Aspectos (AOP): ofrece el soporte para aspectos. Instrumentaci√≥n: proporciona soporte para la instrumentaci√≥n de clases. Pruebas de c√≥digo: contiene un framework de testing, con soporte para JUnit y TestNG y todo lo necesario para probar los mecanismos de Spring. Estos m√≥dulos son opcionales, por lo que podemos utilizar los que necesitemos sin tener que llenar nuestro classpath con clases que no vamos a usar. Esquema que ilustra los diferentes m√≥dulos de Spring, obtenido de la documentaci√≥n oficial Razones para usar Spring Aunque no sea una caracter√≠stica √∫nica de Spring, el uso de inyecci√≥n de dependencias facilita la programaci√≥n contra interfaz, permitiendo a los distintos componentes depender √∫nicamente de interfaces y produciendo as√≠ un c√≥digo menos acoplado. No solo eso, tambi√©n permite implementar el patr√≥n singleton de una forma extremadamente sencilla (por defecto, las dependencias que inyectamos son singletons). Hay cientos de tecnolog√≠as que Spring permite integrar. Desde bibliotecas que implementan opentracing hasta las que nos generan m√©tricas para nuestra aplicaci√≥n, pasando por serializaci√≥n/deserializaci√≥n a JSON y XML, seguridad con OAuth2 o programaci√≥n reactiva entre otras. En general, Spring aumenta la productividad y reduce la fricci√≥n al ofrecernos abstracciones sobre implementaciones de tecnolog√≠as concretas. Un ejemplo claro es el de spring-data, que nos permite definir el acceso a base de datos con interfaces Java. Esto lo consigue parseando el nombre de los m√©todos y generando la consulta con la sintaxis espec√≠fica para el driver que utilicemos. Por ejemplo, cambiar nuestra aplicaci√≥n de MySQL a PostgreSQL es tan sencillo como cambiar el driver: Spring se encarga de la sintaxis de forma transparente. A pesar de  la magia de Spring  üßôüèª‚Äç‚ôÇÔ∏è, como muchos lo llaman, Spring nos permite desactivar estos  comportamientos m√°gicos  en caso de ser necesario, por lo que podemos tomar el control cuando necesitemos m√°s granularidad. Siguiendo con el ejemplo de spring-data, este control ser√≠a necesario si tenemos que realizar consultas mucho m√°s complejas que un SELECT * BY name. En esos casos, entre otras opciones, podemos anotar nuestro m√©todo con @Query y escribir la consulta que deseemos. Ya no hay magia üòâ Por lo general, Spring no obliga a implementar ni extender nada, lo que nos permite escribir c√≥digo que es  agn√≥stico  del framework. De esta forma, desarrolladores con cero o muy poco conocimiento de Spring pueden realizar su trabajo sin mayores complicaciones. Spring es de c√≥digo abierto y tiene una gran comunidad detr√°s. Si encuentras un bug, echas en falta una funcionalidad o lo que sea, siempre puedes abrir un ticket o contribuir por tu cuenta. ¬øPero no √≠bamos a hablar de Spring Boot? Hasta ahora he hablado de Spring Framework en general, pero el t√≠tulo de esta entrada menciona Spring Boot, as√≠ que voy a presentarlo. Si bien es cierto que Spring Framework es muy potente, la configuraci√≥n inicial y la preparaci√≥n de las aplicaciones para producci√≥n son tareas bastante tediosas. Spring Boot simplifica el proceso al m√°ximo gracias a sus dos principales mecanismos. Contenedor de aplicaciones integrado Spring Boot permite compilar nuestras aplicaciones Web como un archivo .jar que podemos ejecutar como una aplicaci√≥n Java normal (como alternativa a un archivo .war, que desplegar√≠amos en un servidor de aplicaciones como Tomcat). Esto lo consigue integrando el servidor de aplicaciones en el propio .jar y levant√°ndolo cuando arrancamos la aplicaci√≥n. De esta forma, podemos distribuir nuestras aplicaciones de una forma mucho m√°s sencilla, al poder configurar el servidor junto con la aplicaci√≥n. Esto tambi√©n es muy √∫til en arquitecturas de microservicios, puesto que permite distribuir nuestras aplicaciones como im√°genes Docker que podemos escalar horizontalmente (algo muy complicado con un .war). Nota: Spring boot permite distribuir tu aplicaci√≥n como un jar, no lo impone. Si prefieres desplegar tu aplicaci√≥n en un servidor de aplicaciones tradicional, Spring Boot te deja compilar el c√≥digo como un .war que no incluya ning√∫n servidor de aplicaciones integrado. Starters Spring Boot nos proporciona una serie de dependencias, llamadas starters, que podemos a√±adir a nuestro proyecto dependiendo de lo que necesitemos: crear un controlador REST, acceder a una base de datos usando JDBC, conectar con una cola de mensajes Apache ActiveMQ, etc. Una vez a√±adimos un starter, √©ste nos proporciona todas las dependencias que necesitamos, tanto de Spring como de terceros. Adem√°s, los starters vienen configurados con valores por defecto, que pretenden minimizar la necesidad de configuraci√≥n a la hora de desarrollar. Un buen ejemplo es el de spring-boot-starter-actuator: una vez que a√±adimos la dependencia, nuestra aplicaci√≥n empezar√° a generar m√©tricas tanto de la JVM como de la aplicaci√≥n en s√≠ (latencias, errores, etc). Al igual que con Spring Framework, cualquier configuraci√≥n puede ser modificada de ser necesario: desde el puerto en el que la aplicaci√≥n escucha peticiones, hasta el banner que sale por consola al arrancar la aplicaci√≥n. Hola Mundo con Spring Boot Para demostrar lo f√°cil que es empezar a usar Spring Boot, vamos a ver el c√≥digo necesario para crear nuestro primer  Hola mundo : @SpringBootApplication @RestController public class Application { @GetMapping( /hello ) public String hello() { return  Hello Bootiful! ; } } Sencillo, ¬øverdad? Aprende con nosotros a sacarle todo el partido a Spring Framework y Spring Boot. Un poco m√°s abajo te explico en un v√≠deo pr√°ctico c√≥mo llegar a este c√≥digo y qu√© significa. Bonus tip: Spring Initializr Captura de Spring Initializr El equipo de Spring tambi√©n ha creado Spring Initializr, una herramienta web que puedes utilizar para autogenerar el esqueleto de tu aplicaci√≥n Spring Boot. Se trata de un inicializador muy √∫til, ya que genera el pom.xml (o build.gradle), el main de la aplicaci√≥n, y un test que comprueba que la aplicaci√≥n arranca correctamente."
    },

    {
        "id": 81,
        "autor": "Cleventy",
        "pagina": "cleventy",
        "fecha": "8/07/2020",
        "titulo": "Capa controlador de un proyecto Spring Boot",
        "link": "https://cleventy.com/capa-controlador-de-un-proyecto-spring-boot/",
        "contenido": "Este art√≠culo continua la serie iniciada en el primer art√≠culo. En este art√≠culo vamos a presentar la implementaci√≥n de la capa controlador de la aplicaci√≥n. Entendemos como controlador a la capa de una aplicaci√≥n que responde a eventos e invoca peticiones a la capa modelo. En nuestro ejemplo, los controladores est√°n bajo el paquete controller y tienen las siguientes caracter√≠sticas: Est√°n anotados con @Controller (o @RestController) Atienden peticiones bajo una ruta definida en la anotaci√≥n @RequestMapping Su nombre termina en Controller Suelen tener inyectados (con anotaci√≥n @Autowired) el servicio relacionado al que acceden Responden a diferentes m√©todos HTTP definidos por la anotaci√≥n @GetMapping Diferenciamos, dependiendo de la naturaleza de los eventos, entre Controlador Web y Controlador API. Controlador Web Responde a eventos lanzados por el usuario desde la web. Un ejemplo es el controlador web de administraci√≥n de usuarios. En √©l hay un √∫nico m√©todo que lo que hace es obtener todos los usuarios y devolverlos a una vista. Esta comunicaci√≥n se realiza a trav√©s del enlace de propiedades en el objeto del modelo (org.springframework.ui.Model). Para lanzar este invocaci√≥n basta con lanzar una petici√≥n GET a la p√°gina de administraci√≥n de usuarios, o, en otras palabras m√°s sencillas, acceder a dicha URL desde el navegador. Controlador API Define un API Rest y por lo tanto responde a diferentes tipos de peticiones. √ötil para comunicar e integrar nuestra aplicaci√≥n con otros sistemas como por ejemplo una aplicaci√≥n m√≥vil. Un ejemplo (an√°logo al anterior) ser√≠a el controlador API de administraci√≥n de usuarios. En √©l hay poco m√°s que un CRUD completo de Usuario, permitiendo, por lo tanto, crear, leer, actualizar y borrar usuarios. Algunas de sus caracter√≠sticas son: A diferencia de los controladores web, estos est√°n anotados por @RestController. Devuelven una objeto gen√©rico de respuesta (org.springframework.http.ResponseEntity) que contiene, a su vez, m√°s informaci√≥n propia de la petici√≥n. Admite diferentes tipos de par√°metros: @RequestParam: por ejemplo, el par√°metro page en /api/admin/users?page=1 @PathVariable: por ejemplo, el identificador de usuario 3 en /api/admin/users/3/sendwelcomeemail @RequestBody: por ejemplo, el cuerpo de la petici√≥n POST de creaci√≥n de usuario /api/admin/users Para explotar/visualizar estos datos es bueno verlo con un ejemplo. Podemos verlo con Postman o directamente con una petici√≥n cURL. Podemos importar la petici√≥n cURL directamente en Postman o ejecutar en la consola la siguiente petici√≥n para obtener los usuarios: curl --location --request GET 'http://localhost:8080/application-4.0.5/api/admin/users'  --header 'Content-Type: application/json'  --header 'Accept: '  --header 'Authorization: Bearer <my_token>' </my_token> Otro ejemplo de petici√≥n, esta sin autenticaci√≥n, ser√≠a, por ejemplo, esta: curl --location --request GET 'http://localhost:8080/application-4.0.5/api/version'  --header 'Content-Type: application/json'"
    },

    {
        "id": 82,
        "autor": "Cecilio √Ålvarez Caules",
        "pagina": "arquitecturajava",
        "fecha": "24/07/2015",
        "titulo": "Spring REST Service con @RestController",
        "link": "https://www.arquitecturajava.com/spring-rest-service-con-restcontroller/",
        "contenido": "Crear un Spring REST Service es ahora muy sencillo a trav√©s del uso de la anotaci√≥n @RestController que Spring 4 soporta. En primer lugar se configura el fichero de pom.xml de Maven con las siguientes dependencias. <dependency> <groupId>org.springframework</groupId> <artifactId>spring-webmvc</artifactId> <version>4.1.7.RELEASE</version> </dependency> <dependency> <groupId>javax.servlet</groupId> <artifactId>jstl</artifactId> <version>1.2</version> <scope>provided</scope> </dependency> <dependency> <groupId>javax.servlet</groupId> <artifactId>servlet-api</artifactId> <version>2.5</version> <scope>provided</scope> </dependency> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-validator</artifactId> <version>5.1.3.Final</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-core</artifactId> <version>2.4.2</version> </dependency> <dependency> <groupId>com.fasterxml.jackson.core</groupId> <artifactId>jackson-databind</artifactId> <version>2.4.2</version> </dependency> </dependencies> El siguiente paso es configurar el Servlet Dispatcher en el web.xml que es el que nos permite mapear todas las urls de los controladores de Spring. <web-app xmlns= http://java.sun.com/xml/ns/javaee  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation= http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd version= 3.0 > <servlet> <servlet-name>ServletSpring</servlet-name> <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> <init-param> <param-name>contextConfigLocation</param-name> <param-value>/WEB-INF/config/applicationContext.xml</param-value> </init-param> </servlet> <servlet-mapping> <servlet-name>ServletSpring</servlet-name> <url-pattern>*.html</url-pattern> <url-pattern>*.json</url-pattern> </servlet-mapping> </web-app> El √∫ltimo paso a nivel de configuraci√≥n es definir el fichero applicationContext.xml: <beans xmlns= http://www.springframework.org/schema/beans xmlns:context= http://www.springframework.org/schema/context xmlns:mvc= http://www.springframework.org/schema/mvc  xmlns:xsi= http://www.w3.org/2001/XMLSchema-instance xmlns:p= http://www.springframework.org/schema/p xsi:schemaLocation= http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc12 http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd > <mvc:annotation-driven /> <context:component-scan base-package= com.arquitecturajava.controller  /> </beans> Realizada la configuraci√≥n ser√° suficiente con crear una clase que use la anotaci√≥n @RestController y automaticamente se publicara como un  Spring REST Service. springrestservicepublicacion package com.arquitecturajava.controller; import java.util.ArrayList; import java.util.List; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; import com.arquitecturajava.negocio.Persona; @RestController public class ControladorREST { @RequestMapping(value =  /personas , method = RequestMethod.GET) public List < Persona > listaPersonas() { List < Persona > lista = new ArrayList < Persona > (); Persona p = new Persona(); p.setNombre( angel ); p.setEdad(20); lista.add(p); Persona p1 = new Persona(); p1.setNombre( gema ); p1.setEdad(30); lista.add(p1); return lista; } } Acabamos de crear un servicio REST que nos devuelve una Persona en una url determinada , concretamente en /personas recordemos que para las url REST normalmente se utilizan los plurales. Cursos asociados Curso de Spring Boot Curso de Spring WebFlux Curso de Java 8 Ya solo queda realizar una petici√≥n web a la URL en donde se ha mapeado el Spring REST Service: spring rest service Conclusiones Spring 4 introduce novedades que hacen la vida m√°s sencilla a los desarrolladores"
    },

    {
        "id": 83,
        "autor": "Cristian Ruiz",
        "pagina": "cristianruizblog",
        "fecha": "29/09/2018",
        "titulo": "Spring Boot 2 + MVC Parte 1| Usando JSP?",
        "link": "http://cristianruizblog.com/spring-boot-mvc-parte-1-usando-jsp/",
        "contenido": "Que es MVC? Es la solucion al problema de como conectar el CLIENTE con el SERVIDOR, en este caso en una aplicacion web de manera rapida, organizada y sencilla. Con Spring Boot Framework se puede implementar el patron de dise√±o Modelo ‚Äì Vista ‚Äì Controlador mejor conovido como MVC, donde la capa llamada vista (archivos HTML o JSP) que normalmente es el cliente en nuestra aplicacion web se comunica con la capa de negocio (Archivos Java llamados Controladores) que seria el servidor, por medio de Modelos (Archivos Java mejor conocidos como Plain Old Java Object). Para comprender como se comunica una aplicacion web que implementa el patron de dise√±o MVC analisa la siguiente imagen: El cliente hace un request al despachador de servlets y este llama al encargado de mapeo url, identifica a que controller y que metodo estas queriendo acceder y le devuelve esa informacion al despachador para invocar ese metodo. En la declaracion del metodo puedes poner tu model(POJO) Y si los atributos del request son iguales a los atributos de tu POJO, la implementacion de Spring Boot MVC asignara esos valores automaticamente, permitiendote utilizar esa informacion para tu logica de negocio y persistencia. Una vez terminado el proceso anterior vas a querer mostrar algun tipo de mensaje o pagina web, aqui es donde entra el view. Debes indicarle a Spring Boot cual es la siguiente pagina y que informacion deseas enviar. Spring Boot creara un view(response) en base a esa informacion y se lo devolvera al cliente. Manos a la obra. Paso a Paso: En el siguiente video te mostrare paso a paso como crear una aplicacion WEB, con arquitectura MVC, ademas podras encontrar el codigo en github para poder compararlo con el tuyo. github: Repositorio github Crear Proyecto: Asegurate de utilizar el initializr de spring boot Selecciona el tipo de packaging war Selecciona la dependencia WEB Finish (Si necesitas ayuda creando proyecto con SpringBoot revisa mi tutorial Spring Boot ‚Äì Que es? y como se come? Configuracion para que interprete archivos JSP: Crear la estructura de carpetas src/main/webapp/WEB-INF/jsp Crear los archivos jsp que necesite tu proyecto Agrega estas dos atributos en el archivos application.properties : spring.mvc.view.prefix: /WEB-INF/jsp/ spring.mvc.view.suffix: .jsp Alterar ruta de ubicacion para JSP Agrega la siguiente dendencia al archivo application.properties Dependencia necesaria para compilar JSP en Spring Boot Ok, ya tu proyecto esta listo para ejecutar archivos JSP, procede a crear los puntos de acceso o controladores: crea una clase Java y en la declaracion de la clase agrega la notacion @Controller hay diferentes maneras de crear metodos dependiendo del proposito: Para renderizar un JSP, declara un metodo que retorne un String (el nombre del jsp) Agrega la anotacion @GetMapping y dentro de su constructor agrega la ruta en la url por la cualquieras acceder a ese JSP Ejemplo de un Controller simple donde redireccionas a otra pagina. Si quieres mas ejemplo de como enviar y recibir datos desde y hacia un jsp mira el video que hay mas arriba. No uses mas JSP y da un paso alfrente y se mas productivo creando codigo mas limpio y entendible para otros, usando Thymeleaf. No olvides de ver la segunda parte de este tutorial. Spring Boot + MVC Parte 2| Usando Thymeleaf Para cerrar : Spring Boot es muy popular para la creacion de Paginas y Servicios Web, poco a poco explicare mas a fondo las capacidades y caracteristicas unicas de SPRING BOOT. Espero este post responda tus dudas y si tienes alguna sugerencia y/o aporte por favor dejalo en los comentarios."
    },

    {
        "id": 84,
        "autor": "Gary Brice√±o",
        "pagina": "clubdetecnologia",
        "fecha": "30/10/2018",
        "titulo": "10 Conceptos de POO en Java",
        "link": "https://www.clubdetecnologia.net/blog/2018/10-conceptos-de-poo-en-java/",
        "contenido": "C√≥mo probablemente sepa, los conceptos de programaci√≥n orientada a objetos son muy importantes. Sin una idea de los conceptos de la POO, no estar√° en la capacidad de dise√±ar sistemas utilizando el modelo de POO ya que este simplifica el desarrollo de software y mantenimiento. En este art√≠culo, se van a explicar 10 conceptos importantes de la POO con ejemplos.[/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 1. Abstracci√≥n Intenci√≥n: La abstracci√≥n significa ocultar detalles de nivel interior o exponer solo los detalles esenciales y relevantes a los usuarios. Ejemplo real: Un autom√≥vil abstrae los detalles internos y expone al conductor solo a detalles que son relevantes para la interacci√≥n del conductor con el autom√≥vil. Por ejemplo, cuando recibimos una llamada telef√≥nica, no conocemos el proceso interno. En Java, se usa la clase abstracta y la interfaz para lograr la abstracci√≥n. Nunca compramos un ‚Äúdispositivo‚Äù, pero siempre compramos algo m√°s espec√≠fico: iPhone, Nokia 3310, etc. Aqu√≠ estos ejemplos son concretos, el dispositivo es algo abstracto. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 2. Encapsulaci√≥n Intenci√≥n: La encapsulaci√≥n se refiere a la combinaci√≥n de datos y funciones asociadas como una sola unidad. En la POO, los datos y las funciones que operan con estos datos se combinan para tomar una sola unidad, lo que se conoce como una clase. Ejemplo: C√°psula: Se envuelven diferentes medicamentos. Una clase de Java es el ejemplo de una encapsulaci√≥n. Un bean Java es la clase totalmente encapsulada porque todos los miembros de datos son privados aqu√≠. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 3. Herencia Intenci√≥n: La herencia es una relaci√≥n entre una super clase y sus sub clases. En consecuencia, este es un proceso donde un objeto adquiere los miembros de otro; adem√°s, el mismo puede formar parte de √©l. Explicaci√≥n: La herencia es un mecanismo de reutilizaci√≥n en la programaci√≥n orientada a objetos en el que se explotan las propiedades comunes de varios objetos para establecer relaciones entre s√≠. Las propiedades abstractas y comunes se proporcionan en la superclase, que esta disponible para las subclases m√°s especializadas. Cuando decimos que la clase B se hereda de otra clase A, se hace referencia a la clase B como una clase derivada (o subclase), y la clase A se llama una clase base (o superclase). Por herencia, la clase derivada recibe el comportamiento de la clase base para que todos los m√©todos y variables de miembros visibles de la clase base est√©n disponibles en la clase derivada. Aparte del comportamiento heredado, la clase derivada especializa su comportamiento al agregar o anular el comportamiento de la clase base.[/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 4. Polimorfismo Intenci√≥n: El polimorfismo nos permite realizar una misma acci√≥n de diferentes maneras El polimorfismo le permite definir una interfaz y tener m√∫ltiples implementaciones Podemos crear funciones o variables de referencia que se comportan de manera diferente en diferentes contextos program√°ticos. El polimorfismo significa muchas formas. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 5. Asociaci√≥n Intenci√≥n Representa una relaci√≥n entre dos o m√°s objetos donde todos los objetos tienen su propio ciclo de vida y no hay ning√∫n propietario. El nombre de una asociaci√≥n especifica la naturaleza de la relaci√≥n entre los objetos. La asociaci√≥n es una relaci√≥n entre dos clases separadas que se establece a trav√©s de sus objetos. La asociaci√≥n puede ser uno a uno, uno a muchos, muchos a uno y muchos a muchos. En la programaci√≥n orientada a objetos, un objeto se comunica con otro objeto para usar la funcionalidad y los servicios proporcionados por ese objeto. Hay dos formas de asociaci√≥n: Composici√≥n Agregaci√≥n [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 6. Composici√≥n Intenci√≥n La composici√≥n es una asociaci√≥n que representa una parte de una relaci√≥n completa donde una parte no puede existir sin un todo. Si se elimina un entero, entonces se eliminan todas las partes. Tiene una relaci√≥n m√°s fuerte. Puntos clave: Representa una parte de la relaci√≥n. En composici√≥n, ambas entidades dependen una de la otra. Cuando hay una composici√≥n entre dos entidades, el objeto compuesto no puede existir sin la otra entidad. Por ejemplo, si el pedido tiene art√≠culos de l√≠nea A-A, un pedido es un art√≠culo completo y los art√≠culos de l√≠nea son partes. Si se elimina un pedido, se deben eliminar todas las l√≠neas correspondientes a ese pedido. Favorecer la composici√≥n sobre la herencia. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 7. Agregaci√≥n Intenci√≥n La agregaci√≥n es una asociaci√≥n que representa parte de una relaci√≥n completa donde una parte puede existir sin un todo. Tiene una relaci√≥n m√°s d√©bil. Es una forma especializada de asociaci√≥n donde todos los objetos tienen su propio ciclo de vida, pero existe la propiedad. Esto representa una relaci√≥n de ‚Äúparte completa‚Äù o ‚Äúparte de parte‚Äù. Tomemos un ejemplo de la relaci√≥n entre el Departamento y el Maestro. Un profesor puede pertenecer a m√∫ltiples departamentos. Por lo tanto, el profesor es parte de m√∫ltiples departamentos. Pero si eliminamos un Departamento, el objeto Maestro no ser√° destruido. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 8. Delegaci√≥n Intenci√≥n: Entregar la responsabilidad de una tarea particular a otra clase o m√©todo. Es una t√©cnica en la que un objeto expresa cierto comportamiento hacia el exterior, pero en realidad, es responsabilidad de los delegados implementar ese comportamiento en un objeto asociado. Aplicabilidad: Utilice la delegaci√≥n para lograr lo siguiente: Reducir el acoplamiento de m√©todos a su clase. Componentes que se comportan de manera id√©ntica pero se dan cuenta de que esta situaci√≥n puede cambiar en el futuro. Si necesita utilizar la funcionalidad en otra clase pero no desea cambiar esa funcionalidad, utilice la delegaci√≥n en lugar de la herencia. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 9. Acoplamiento Intenci√≥n: Acoplamiento se refiere al grado en que una clase sabe acerca de otra clase. Si una clase usa otra clase, eso es acoplamiento. Esto incluye bajas dependencias entre ‚Äúartefactos‚Äù (clases, m√≥dulos, componentes). No debe haber una dependencia demasiado grande entre los m√≥dulos; incluso si hay una dependencia, deber√≠a ser a trav√©s de las interfaces y deber√≠a ser m√≠nima. Puntos clave: Al crear una aplicaci√≥n compleja en Java, la l√≥gica de una clase llamar√° a la l√≥gica de otra clase para proporcionar el mismo servicio a los clientes. Si una clase est√° llamando a otra l√≥gica de clase, entonces se llama colaboraci√≥n. Cuando una clase est√° colaborando con otra clase, entonces existe un acoplamiento estrecho entre las dos clases. Si una clase quiere llamar a la l√≥gica de una segunda clase, entonces la primera clase necesita un objeto de una segunda clase. Significa que la primera clase crea un objeto de una segunda clase. [/vc_column_text][/vc_column][/vc_row][vc_row][vc_column][vc_column_text] 10. Cohesi√≥n Intenci√≥n: El t√©rmino cohesi√≥n se usa para indicar el grado en que una clase tiene una responsabilidad √∫nica y bien enfocada. La cohesi√≥n es una medida de c√≥mo los m√©todos de una clase o un m√≥dulo est√°n relacionados de manera significativa y significativa, y de cu√°n enfocados est√°n en proporcionar un prop√≥sito bien definido al sistema. Explicaci√≥n: En el dise√±o orientado a objetos, la cohesi√≥n se refiere a c√≥mo se dise√±a una sola clase. La cohesi√≥n es el principio orientado a objetos que est√° m√°s estrechamente asociado con asegurarse de que una clase est√© dise√±ada con un prop√≥sito √∫nico y bien enfocado. Cuanto m√°s enfocada est√° una clase, m√°s cohesiva es esa clase. Las ventajas de la alta cohesi√≥n son que estas clases son mucho m√°s f√°ciles de mantener (y cambian con menos frecuencia) que las clases con baja cohesi√≥n. Otro beneficio de la alta cohesi√≥n es que las clases con un prop√≥sito bien enfocado tienden a ser m√°s reutilizables que otras clases."
    },

    {
        "id": 85,
        "autor": "Eduardo Ismael Garc√≠a P√©rez",
        "pagina": "codigofacilito",
        "fecha": "27/01/2020",
        "titulo": "Diferencia Entre Clases Abstractas E Interfaces En Java",
        "link": "https://codigofacilito.com/articulos/clases-abstractas-interfaces-java",
        "contenido": "Hace un par de d√≠as en C√≥digoFacilito nos lleg√≥ una pregunta muy puntual acerca de Java, una pregunta que muy probablemente en alg√∫n momento te hayas hecho ¬øC√∫al es la diferencia entre una clases abstracta y una interfaz? ü§î Al ser conceptos muy parecidos de programaci√≥n orientada a objetos sin duda estos temas pueden ser dif√≠ciles de comprender y puede que a m√°s de uno le haya causado uno que otro dolor de cabeza, üò≤es por ello que en esta ocasi√≥n me gustar√≠a que explicaremos en detalle qu√© es una clase abstracta, qu√© es una interfaz, en qu√© caso son buenos utilizarlos y por su puesto, cual es la diferencia entre uno y otro. Bien, una vez dicho todo esto comencemos. source: imgur.com CLASES ABSTRACTAS Comencemos hablando de clases abstractas. Habr√° ocasiones en las cuales necesitemos crear una clase padre donde √∫nicamente coloquemos la estructura de una abstracci√≥n, una estructura muy general, dejando que sean las clases hijas quienes definan los detalles. En estos casos haremos uso de las clases abstractas. Una clase abstracta es practicamente identica a una clase convencional; las clases abstractas pueden poseer atributos, m√©todos, constructores, etc ... La principal diferencia entre una clases convencional y una clase abstracta es que la clase abstracta debe poseer por lo menos un m√©todo abstracto. Ok, pero ahora, ¬ø Qu√© es un m√©todo abstracto? Ver√°s, un m√©todo abstracto no es m√°s que un m√©todo vac√≠o, un m√©todo el cual no posee cuerpo, por ende no puede realizar ninguna acci√≥n. La utilidad de un m√©todo abstracto es definir qu√© se debe hacer pero no el c√≥mo se debe hacer. Veamos un ejemplo para que nos quede m√°s en claro. public class Figura { private int numeroLados; public Figura() { this.numeroLados = 0; } public float area() { return 0f; } } En este caso la clase posee una atributo, un constructor y un m√©todo, a partir de esta clase podr√© generar la n cantidad de figuras que necesite, ya sean cuadrados, rectangulos, triangulos, circulos etc... Dentro de la clase encontramos el m√©todo √°rea, m√©todo que se encuentra pensado para obtener el √°rea de cualquier figura, sin embargo c√≥mo sabemos todas las figuras poseen su propia f√≥rmula matem√°tica para calcular su √°rea. Si yo comienzo a heredar de la clase Figura todas las clases hijas tendr√≠an que sobre escribir el m√©todo √°rea e implementar su propia formula para as√≠ poder calcular su √°rea. En estos casos, en los casos la clase hija siempre deba que sobreescribir el m√©todo lo que podemos hacer es convertir al m√©todo convencional en un m√©todo abstracto, un m√©todo que defina qu√© hacer, pero no c√≥mo se deba hacer. üòÉ public abstract float area(); Ahora que el m√©todo √°rea es un m√©todo abstracto la clase se convierte en una clase abstracta. public abstract class Figura { Es importante mencionar que las clases abstractas pueden ser heredadas por la n cantidad de clases que necesitemos, pero no pueden ser instanciadas. Para heredar de una clase abstracta basta con utilizar la palabra reservada extends. public class Triangulo extends Figura { Al nosotros heredar de una clase abstracta es obligatorio implementar todos sus m√©todos abstractos, es decir debemos definir comportamiento, definir c√≥mo se va a realizar la tarea. INTERFACES Ahora hablaremos de interfaces. A pesar que es un tema un poco complejo si nosotros hemos comprendido el tema de clases abstractas y el por que de ellas, el tema de interfaces ser√° un tema muy sencillo. Veamos. A diferencia de otros lenguajes de programaci√≥n, en Java no es posible la herencia m√∫ltiple, nuestras clases √∫nicamente podr√°n heredar de una y solo una clase. Si conceptualizamos esto una representaci√≥n pudiese ser la siguiente. source: imgur.com El nivel de jerarqu√≠a es descendente. Esto sin duda funciona, sin embargo, si queremos representar conceptos de la vida real necesitaremos una jerarqu√≠a mucho m√°s compleja, algo como esto. source: imgur.com Para que podamos diagramar nuestro proyecto de esta forma, teniendo en cuenta que √∫nicamente es posible heredar de una clase, entonces haremos uso de interfaces. Podemos definir a una interfaz como una colecci√≥n de m√©todos abstractos y propiedades constantes en las que se especifica que se debe de hacer pero no como, ser√°n las clases hijas quienes definan el comportamiento. A diferencia de una clase abstracta, una interface no puede hacer nada por s√≠ sola, es pr√°cticamente un contrato, en donde las clases que la implementen deben, obligatoriamente, definir el comportamiento de todos los m√©todos abstractos, contestando a la pregunta ¬øC√≥mo se debe hacer? Veamos un ejemplo de una interfaz. public interface Canino { public abstract void aullar(); public abstract void ladrar(); } C√≥mo podemos observar en la interfaz solo encontraremos m√©todos abstractos, m√©todo vac√≠os. Para poder implementar la interfaz basta con utilizar la palabra reservada implements. public class Perro implements Canino { Si bien es cierto que en versiones actuales de Java podemos encontrar los m√©todos default en las interfaces, m√©todos que nos permite definir comportamientos, en esencia las interfaces ser√°n contratos que indicar√°n que es lo que se debe hacer sin proveer ninguna funcionalidad. Otra diferencia entre una clase abstracta y una interface recae en su implementaci√≥n ya que una clase hija solo podr√° heredar de una clase abstracta, por otro lado podr√° hacer uso de la n cantidad de interfaces que necesite. public class Perro extends Canino implementes Mascota CONCLUSI√ìN En conclusi√≥n un m√©todo abstracto no es m√°s que un m√©todo vac√≠o el cual resuelve la pregunta ¬øQu√© se debe hacer? pero no el ¬øC√≥mo se deba hacer? ya que ser√°n las clases hijas quienes definan el comportamiento. Los m√©todos abstractos podemos encontrarlos en dos entidades, las clases abstractas y las interfaces. Una clase abstracta no es m√°s que una clase com√∫n la cual posee atributos, m√©todos, constructores y por lo menos un m√©todo abstracto. Una clase abstracta no puede ser instanciada, solo heredada. C√≥mo Java no permite la herencia m√∫ltiple habr√° ocasiones en las cuales debamos utilizar interfaces, las cuales podemos verlas como contratos, contratos donde est√° muy bien establecido que debe hacer la clase que la implementa."
    },

    {
        "id": 86,
        "autor": "Alex Rodr√≠guez",
        "pagina": "aprenderaprogramar",
        "fecha": "0/0/0",
        "titulo": "Clases y m√©todos abstractos en Java. Abstract class. Clases del api. Ejemplos c√≥digo y ejercicios. ",
        "link": "https://www.aprenderaprogramar.com/index.php?option=com_content&view=article&id=668:clases-y-metodos-abstractos-en-java-abstract-class-clases-del-api-ejemplos-codigo-y-ejercicios-cu00695b&catid=68&Itemid=188",
        "contenido": "CLASES Y M√âTODOS ABSTRACTOS EN JAVA. Supongamos un esquema de herencia que consta de la clase Profesor de la que heredan ProfesorInterino y ProfesorTitular. Es posible que todo profesor haya de ser o bien ProfesorInterino o bien ProfesorTitular, es decir, que no vayan a existir instancias de la clase Profesor. Entonces, ¬øqu√© sentido tendr√≠a tener una clase Profesor? El sentido est√° en que una superclase permite unificar campos y m√©todos de las subclases, evitando la repetici√≥n de c√≥digo y unificando procesos. Ahora bien, una clase de la que no se tiene intenci√≥n de crear objetos, sino que √∫nicamente sirve para unificar datos u operaciones de subclases, puede declararse de forma especial en Java: como clase abstracta. La declaraci√≥n de que una clase es abstracta se hace con la sintaxis public abstract class NombreDeLaClase { ‚Ä¶ }. Por ejemplo public abstract class Profesor. Cuando utilizamos esta sintaxis, no resulta posible instanciar la clase, es decir, no resulta posible crear objetos de ese tipo. Sin embargo, sigue funcionando como superclase de forma similar a como lo har√≠a una superclase ‚Äúnormal‚Äù. La diferencia principal radica en que no se pueden crear objetos de esta clase. Declarar una clase abstracta es distinto a tener una clase de la que no se crean objetos. En una clase abstracta, no existe la posibilidad. En una clase normal, existe la posibilidad de crearlos aunque no lo hagamos. El hecho de que no creemos instancias de una clase no es suficiente para que Java considere que una clase es abstracta. Para lograr esto hemos de declarar expl√≠citamente la clase como abstracta mediante la sintaxis que hemos indicado. Si una clase no se declara usando abstract se cataloga como ‚Äúclase concreta‚Äù. En ingl√©s abstract significa ‚Äúresumen‚Äù, por eso en algunos textos en castellano a las clases abstractas se les llama res√∫menes. Una clase abstracta para Java es una clase de la que nunca se van a crear instancias: simplemente va a servir como superclase a otras clases. No se puede usar la palabra clave new aplicada a clases abstractas. En el men√∫ contextual de la clase en BlueJ simplemente no aparece, y si intentamos crear objetos en el c√≥digo nos saltar√° un error. A su vez, las clases abstractas suelen contener m√©todos abstractos: la situaci√≥n es la misma. Para que un m√©todo se considere abstracto ha de incluir en su signatura la palabra clave abstract. Adem√°s un m√©todo abstracto tiene estas peculiaridades: a) No tiene cuerpo (llaves): s√≥lo consta de signatura con par√©ntesis. b) Su signatura termina con un punto y coma. c) S√≥lo puede existir dentro de una clase abstracta. De esta forma se evita que haya m√©todos que no se puedan ejecutar dentro de clases concretas. Visto de otra manera, si una clase incluye un m√©todo abstracto, forzosamente la clase ser√° una clase abstracta. d) Los m√©todos abstractos forzosamente habr√°n de estar sobreescritos en las subclases. Si una subclase no implementa un m√©todo abstracto de la superclase tiene un m√©todo no ejecutable, lo que la fuerza a ser una subclase abstracta. Para que la subclase sea concreta habr√° de implementar m√©todos sobreescritos para todos los m√©todos abstractos de sus superclases. Un m√©todo abstracto para Java es un m√©todo que nunca va a ser ejecutado porque no tiene cuerpo. Simplemente, un m√©todo abstracto referencia a otros m√©todos de las subclases. ¬øQu√© utilidad tiene un m√©todo abstracto? Podemos ver un m√©todo abstracto como una palanca que fuerza dos cosas: la primera, que no se puedan crear objetos de una clase. La segunda, que todas las subclases sobreescriban el m√©todo declarado como abstracto. Sintaxis tipo: abstract public/private/protected TipodeRetorno/void ( par√°metros        ‚Ä¶   ); Por ejemplo: abstract public void generarNomina (int diasCotizados, boolean plusAntiguedad); Que un m√©todo sea abstracto tiene otra implicaci√≥n adicional: que podamos invocar el m√©todo abstracto sobre una variable de la superclase que apunta a un objeto de una subclase de modo que el m√©todo que se ejecute sea el correspondiente al tipo din√°mico de la variable. En cierta manera, podr√≠amos verlo como un m√©todo sobreescrito para que Java comprenda que debe buscar din√°micamente el m√©todo adecuado seg√∫n la subclase a la que apunte la variable. ¬øEs necesario que una clase que tiene uno o m√°s m√©todos abstractos se defina como abstracta? S√≠, si declaramos un m√©todo abstracto el compilador nos obliga a declarar la clase como abstracta porque si no lo hici√©ramos as√≠ tendr√≠amos un m√©todo de una clase concreta no ejecutable, y eso no es admitido por Java. ¬øUna clase se puede declarar como abstracta y no contener m√©todos abstractos? S√≠, una clase puede ser declarada como abstracta y no contener m√©todos abstractos. En algunos casos la clase abstracta simplemente sirve para efectuar operaciones comunes a subclases sin necesidad de m√©todos abstractos. En otros casos s√≠ se usar√°n los m√©todos abstractos para referenciar operaciones en la clase abstracta al contenido de la sobreescritura en las subclases. ¬øUna clase que hereda de una clase abstracta puede ser no abstracta? S√≠, de hecho esta es una de las razones de ser de las clases abstractas. Una clase abstracta no puede ser instanciada, pero pueden crearse subclases concretas sobre la base de una clase abstracta, y crear instancias de estas subclases. Para ello hay que heredar de la clase abstracta y anular los m√©todos abstractos, es decir, implementarlos. Vamos a ver un ejemplo basado en el siguiente esquema: clase abstracta java En este diagrama de clases vemos c√≥mo hemos definido una clase abstracta denominada Profesor. BlueJ la identifica se√±alando <<abstract>> en la parte superior del icono de la clase. Sin embargo, hereda de la clase Persona que no es abstracta, lo cual significa que puede haber instancias de Persona pero no de Profesor. El test que hemos dise√±ado se basa en lo siguiente: ProfesorTitular y ProfesorInterino son subclases de la clase abstracta Profesor. ListinProfesores sirve para crear un ArrayList de profesores que pueden ser tanto interinos como titulares y realizar operaciones con esos conjuntos. El list√≠n se basa en el tipo est√°tico Profesor, pero su contenido din√°mico siempre ser√° a base de instancias de ProfesorTitular o de ProfesorInterino ya que Profesor es una clase abstracta, no instanciable. En la clase de test creamos profesores interinos y profesores titulares y los vamos a√±adiendo a un list√≠n. Posteriormente, invocamos el m√©todo imprimirListin, que se basa en los m√©todos toString de las subclases y de sus superclases mediante invocaciones sucesivas a super. Por otro lado, en la clase ListinProfesores hemos definido el m√©todo importeTotalNominaProfesorado() que se basa en un bucle que calcula la n√≥mina de todos los profesores que haya en el list√≠n (sean interinos o titulares) mediante el uso de un m√©todo abstracto: importeNomina(). Este m√©todo est√° definido como abstract public float importeNomina (); dentro de la clase abstracta profesor, e implementado en las clases ProfesorInterino y ProfesorTitular. El aspecto central de este ejemplo es comprobar c√≥mo una clase abstracta como Profesor nos permite realizar operaciones conjuntas sobre varias clases, ahorrando c√≥digo y ganando en claridad para nuestros programas. Escribe este c√≥digo: public class Persona { //C√≥digo de la clase Persona ejemplo aprenderaprogramar.com private String nombre; private String apellidos; private int edad; public Persona() { nombre =   ; apellidos =   ; edad = 0; } public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad; } public String getNombre() { return nombre;  } public String getApellidos() { return apellidos;  } public int getEdad() { return edad;  } public String toString() {   Integer datoEdad = edad; return  -Nombre:  .concat(nombre).concat(  -Apellidos:  ).concat(apellidos).concat(  -Edad:  ).concat(datoEdad.toString() ); } } //Cierre de la clase En la clase Persona transformamos edad en un Integer para poder aplicarle el m√©todo toString(). De otra manera no podemos hacerlo por ser edad un tipo primitivo. Escribe este c√≥digo: public abstract class Profesor extends Persona { // Campo de la clase ejemplo aprenderaprogramar.com private String IdProfesor; // Constructores public Profesor () { super();         IdProfesor =  Unknown ;   } public Profesor (String nombre, String apellidos, int edad, String id) { super(nombre, apellidos, edad);   IdProfesor = id; } // M√©todos public void setIdProfesor (String IdProfesor) { this.IdProfesor = IdProfesor;   } public String getIdProfesor () { return IdProfesor;   } public void mostrarDatos() { System.out.println ( Datos Profesor. Profesor de nombre:   + getNombre() +     + getApellidos() +   con Id de profesor:   + getIdProfesor() );   } public String toString () { return super.toString().concat(  -IdProfesor:  ).concat(IdProfesor); } abstract public float importeNomina ();  // M√©todo abstracto } //Cierre de la clase Hemos declarado la clase Profesor como abstracta. De hecho, tenemos un m√©todo abstracto (definido como abstract y sin cuerpo), lo cual de facto nos obliga a declarar la clase como abstracta. El m√©todo sobreescrito toString llama al m√©todo toString de la superclase y lo concatena con nuevas cadenas. Como clases que heredan de Profesor tenemos a ProfesorTitular y ProfesorInterino: public class ProfesorTitular extends Profesor { // Constructor ejemplo aprenderaprogramar.com public ProfesorTitular(String nombre, String apellidos, int edad, String id) { super(nombre, apellidos, edad, id); } public float importeNomina () { return 30f * 43.20f; }  //M√©todo abstracto sobreescrito en esta clase } //Cierre de la clase import java.util.Calendar; public class ProfesorInterino extends Profesor { // Campo de la clase ejemplo aprenderaprogramar.com private Calendar fechaComienzoInterinidad; // Constructores public ProfesorInterino (Calendar fechaInicioInterinidad) { super();      fechaComienzoInterinidad = fechaInicioInterinidad; } public ProfesorInterino (String nombre, String apellidos, int edad, String id, Calendar fechaInicioInterinidad) { super(nombre, apellidos, edad, id); fechaComienzoInterinidad = fechaInicioInterinidad; } public Calendar getFechaComienzoInterinidad () { return fechaComienzoInterinidad; } //M√©todo public String toString () { // Sobreescritura del m√©todo return super.toString().concat (  Fecha comienzo interinidad:  ).concat (fechaComienzoInterinidad.getTime().toString()); } public float importeNomina () { return 30f * 35.60f ; } //M√©todo abstracto sobreescrito en esta clase } //Cierre de la clase import java.util.ArrayList; import java.util.Iterator; public class ListinProfesores { private ArrayList <Profesor> listinProfesores; //Campo de la clase public ListinProfesores () {  listinProfesores = new ArrayList <Profesor> ();  } //Constructor public void addProfesor (Profesor profesor) {  listinProfesores.add(profesor);  } //M√©todo public void imprimirListin() {  //M√©todo String tmpStr1 =   ; //String temporal que usamos como auxiliar System.out.println ( Se procede a mostrar los datos de los profesores existentes en el list√≠n \n ); for (Profesor tmp: listinProfesores) {          System.out.println (tmp.toString () ); if (tmp instanceof ProfesorInterino) { tmpStr1 =  Interino ;} else { tmpStr1 =  Titular ; } System.out.println( -Tipo de este profesor: +tmpStr1+  -N√≥mina de este profesor:  +(tmp.importeNomina())+  \n );} } //Cierre m√©todo imprimirListin public float importeTotalNominaProfesorado() { float importeTotal = 0f; //Variable temporal que usamos como auxiliar Iterator<Profesor> it = listinProfesores.iterator(); while (it.hasNext() ) { importeTotal = importeTotal + it.next().importeNomina(); } return importeTotal; } //Cierre del m√©todo importeTotalNominaProfesorado } //Cierre de la clase ejemplo aprenderaprogramar.com ProfesorTitular y ProfesorInterino se han definido como clases concretas que heredan de la clase abstracta Profesor. Ambas clases redefinen (obligatoriamente han de hacerlo) el m√©todo abstracto importeNomina() de la superclase. El m√©todo sobreescrito toString() de la clase ProfesorInterino llama al m√©todo toString() de la superclase y lo concatena con nuevas cadenas. El c√°lculo de importeNomina en ambas clases es una trivialidad: hemos incluido un c√°lculo sin mayor inter√©s excepto que el de ver el funcionamiento de la implementaci√≥n de m√©todos abstractos. ProfesorTitular lo hemos dejado con escaso contenido porque aqu√≠ lo usamos solo a modo de ejemplo de uso de clases abstractas y herencia. Su √∫nico cometido es mostrar que existe otra subclase de Profesor. Por otro lado, en la clase ListinProfesores tenemos un ejemplo de uso de instanceof para determinar qu√© tipo (ProfesorInterino o ProfesorTitular) es el que porta una variable Profesor. Iteramos con clase declarada Profesor y clases din√°micas ProfesorTitular y ProfesorInterino. Din√°micamente se determina de qu√© tipo es cada objeto y al invocar el m√©todo abstracto importeNomina() Java determina si debe utilizar el m√©todo propio de un subtipo u otro. En imprimirListin llegamos incluso a mostrar por pantalla de qu√© tipo es cada objeto usando la sentencia instanceof para determinarlo. Escribe y ejecuta el c√≥digo del test: import java.util.Calendar; //Ejemplo aprenderaprogramar.com public class TestAbstract { public static void main (String [ ] Args) { Calendar fecha1 = Calendar.getInstance(); fecha1.set(2019,10,22); //Los meses van de 0 a 11, luego 10 representa noviembre ProfesorInterino pi1 = new ProfesorInterino( Jos√© ,  Hern√°ndez L√≥pez , 45,  45221887-K , fecha1); ProfesorInterino pi2 = new ProfesorInterino( Andr√©s ,  Molt√≥ Parra , 87,  72332634-L , fecha1); ProfesorInterino pi3 = new ProfesorInterino ( Jos√© ,  R√≠os Mesa , 76,  34998128-M , fecha1); ProfesorTitular pt1 = new ProfesorTitular ( Juan ,  P√©rez P√©rez , 23,  73-K ); ProfesorTitular pt2 = new ProfesorTitular ( Alberto ,  Centa Mota , 49,  88-L ); ProfesorTitular pt3 = new ProfesorTitular ( Alberto ,  Centa Mota , 49,  81-F ); ListinProfesores listinProfesorado = new ListinProfesores (); listinProfesorado.addProfesor (pi1); listinProfesorado.addProfesor(pi2); listinProfesorado.addProfesor (pi3); listinProfesorado.addProfesor (pt1); listinProfesorado.addProfesor(pt2); listinProfesorado.addProfesor (pt3); listinProfesorado.imprimirListin(); System.out.println ( El importe de las n√≥minas del profesorado que consta en el list√≠n es   + listinProfesorado.importeTotalNominaProfesorado()+   euros ); }  }   //Cierre del main y cierre de la clase Comprueba el resultado de ejecuci√≥n. El resultado del test nos muestra que operamos exitosamente sobre las dos clases usando abstracci√≥n: Se procede a mostrar los datos de los profesores existentes en el list√≠n -Nombre: Jos√© -Apellidos: Hdez L√≥pez -Edad: 45 -IdProfesor: 45221887-K Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -N√≥mina de este profesor: 1068.0 -Nombre: Andr√©s -Apellidos: Mlt√≥ Parra -Edad: 87 -IdProfesor: 72332634-L Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -N√≥mina de este profesor: 1068.0 -Nombre: Jos√© -Apellidos: R√≠os Mesa -Edad: 76 -IdProfesor: 34998128-M Fecha czo interinidad: Fri Nov 22 11:55:28 CET 2019 -Tipo de este profesor: Interino -N√≥mina de este profesor: 1068.0 -Nombre: Juan -Apellidos: P√©rez P√©rez -Edad: 23 -IdProfesor: 73-K -Tipo de este profesor: Titular -N√≥mina de este profesor: 1296.0 -Nombre: Alberto -Apellidos: Centa Mota -Edad: 49 -IdProfesor: 88-L -Tipo de este profesor: Titular -N√≥mina de este profesor: 1296.0 -Nombre: Alberto -Apellidos: Centa Mota -Edad: 49 -IdProfesor: 81-F -Tipo de este profesor: Titular -N√≥mina de este profesor: 1296.0 El importe de las n√≥minas del profesorado que consta en el list√≠n es 7092.0 euros CLASES ABSTRACTAS EN EL API DE JAVA Java utiliza clases abstractas en el API de la misma forma que podemos nosotros usarlas en nuestros programas. Por ejemplo, la clase AbstractList del paquete java.util es una clase abstracta con tres subclases: clases abstractas api java Como vemos, entre las subclases dos de ellas son concretas mientras que una todav√≠a es abstracta. En una clase como AbstractList algunos m√©todos son abstractos, lo que obliga a que el m√©todo est√© sobreescrito en las subclases, mientras que otros m√©todos no son abstractos. Sobre un objeto de una subclase, llamar a un m√©todo puede dar lugar a: a) La ejecuci√≥n del m√©todo tal y como est√© definido en la subclase. b) La b√∫squeda del m√©todo ascendiendo por las superclases hasta que se encuentra y puede ser ejecutado. Es lo que ocurrir√° por ejemplo con toString() si no est√° definido en la subclase."
    },

    {
        "id": 87,
        "autor": "arkaitzgarro",
        "pagina": "arkaitzgarro",
        "fecha": "0/0/0",
        "titulo": "CAP√çTULO 18 INTERFACES",
        "link": "https://www.arkaitzgarro.com/java/capitulo-18.html",
        "contenido": "Una interfaz es una especie de plantilla para la construcci√≥n de clases. Normalmente una interfaz se compone de un conjunto de declaraciones de cabeceras de m√©todos (sin implementar, de forma similar a un m√©todo abstracto) que especifican un protocolo de comportamiento para una o varias clases. Adem√°s, una clase puede implementar una o varias interfaces: en ese caso, la clase debe proporcionar la declaraci√≥n y definici√≥n de todos los m√©todos de cada una de las interfaces o bien declararse como clase abstract. Por otro lado, una interfaz puede emplearse tambi√©n para declarar constantes que luego puedan ser utilizadas por otras clases. Una interfaz puede parecer similar a una clase abstracta, pero existen una serie de diferencias entre una interfaz y una clase abstracta: Todos los m√©todos de una interfaz se declaran impl√≠citamente como abstractos y p√∫blicos. Una clase abstracta no puede implementar los m√©todos declarados como abstractos, una interfaz no puede implementar ning√∫n m√©todo (ya que todos son abstractos). Una interfaz no declara variables de instancia. Una clase puede implementar varias interfaces, pero s√≥lo puede tener una clase ascendiente directa. Una clase abstracta pertenece a una jerarqu√≠a de clases mientras que una interfaz no pertenece a una jerarqu√≠a de clases. En consecuencia, clases sin relaci√≥n de herencia pueden implementar la misma interfaz. 18.1 DECLARACI√ìN DE UNA INTERFAZ La declaraci√≥n de una interfaz es similar a una clase, aunque emplea la palabra reservada interface en lugar de class y no incluye ni la declaraci√≥n de variables de instancia ni la implementaci√≥n del cuerpo de los m√©todos (s√≥lo las cabeceras). La sintaxis de declaraci√≥n de una interfaz es la siguiente: public interface IdentificadorInterfaz { // Cuerpo de la interfaz ... } Una interfaz declarada como public debe ser definida en un archivo con el mismo nombre de la interfaz y con extensi√≥n .java. Las cabeceras de los m√©todos declarados en el cuerpo de la interfaz se separan entre s√≠ por caracteres de punto y coma y todos son declarados impl√≠citamente como public y abstract (se pueden omitir). Por su parte, todas las constantes incluidas en una interfaz se declaran impl√≠citamente como public, static y final (tambi√©n se pueden omitir) y es necesario inicializarlas en la misma sentencia de declaraci√≥n. Por ejemplo, la interfaz Modificacion declara la cabecera de un √∫nico m√©todo: /** * Declaracion de la interfaz Modificacion */ public interface Modificacion { void incremento(int a); } que se almacena en el archivo fuente Modificacion.java y que, al compilarse: $>javac Modificacion.java genera un archivo Modificacion.class. Al no corresponder a una clase que implementa un m√©todo main, este archivo no puede ejecutarse con el int√©rprete de Java. Segundo ejemplo: la interfaz constantes declara dos constantes reales con el siguiente c√≥digo fuente: /** * Declaracion de la interfaz Constantes */ public interface Constantes { double VALOR_MAXIMO = 10000000.0; double VALOR_MINIMO = -0.01; } que se almacena en el archivo fuente Constantes.java y que, al compilarse, genera un archivo Constantes.class Tercer ejemplo: la interfaz Numerico declara una constante real y dos cabeceras de m√©todos con el siguiente c√≥digo fuente: /** * Declaracion de la interfaz Numerico */ public interface Numerico { double EPSILON = 0.000001; void establecePrecision(float p); void estableceMaximo(float m); } que se almacena en el archivo fuente Numerico.java y que, al compilarse, genera un archivo Numerico.class. 18.2 IMPLEMENTACI√ìN DE UNA INTERFAZ EN UNA CLASE Para declarar una clase que implemente una interfaz es necesario utilizar la palabra reservada implements en la cabecera de declaraci√≥n de la clase. Las cabeceras de los m√©todos (identificador y n√∫mero y tipo de par√°metros) deben aparecer en la clase tal y como aparecen en la interfaz implementada. Por ejemplo, la clase Acumulador implementa la interfaz Modificacion y por lo tanto debe declarar un m√©todo incremento: /** * Declaracion de la clase Acumulador */ public class Acumulador implements Modificacion { private int valor; public Acumulador (int i) { this.valor = i; } public int daValor () { return this.valor; } public void incremento (int a) { this.valor += a; } } Esta cabecera con la palabra implements... implica la obligaci√≥n de la clase Acumulador de definir el m√©todo incremento declarado en la interfaz Modificacion. El siguiente c√≥digo muestra un ejemplo de uso de la clase Acumulador. /** * Demostracion de la clase Acumulador */ public class PruebaAcumulador { public static void main (String [] args) { Acumulador p = new Acumulador(25); p.incremento(12); System.out.println(p.daValor()); } } La compilaci√≥n y posterior ejecuci√≥n del c√≥digo anterior origina la siguiente salida por pantalla: $>javac PruebaAcumulador.java $>java PruebaAcumulador 37 La clase Acumulador tendr√≠a tambi√©n la posibilidad de utilizar directamente las constantes declaradas en la interfaz si las hubiera. Para poder emplear una constante declarada en una interfaz, las clases que no implementen esa interfaz deben anteponer el identificador de la interfaz al de la constante. 18.3 JERARQU√çA ENTRE INTERFACES La jerarqu√≠a entre interfaces permite la herencia simple y m√∫ltiple. Es decir, tanto la declaraci√≥n de una clase, como la de una interfaz pueden incluir la implementaci√≥n de otras interfaces. Los identificadores de las interfaces se separan por comas. Por ejemplo, la interfaz Una implementa otras dos interfaces: Dos y Tres. public interface Una implements Dos, Tres { // Cuerpo de la interfaz ... } Las clases que implementan la interfaz Una tambi√©n lo hacen con Dos y Tres. Otro ejemplo: pueden construirse dos interfaces, Constantes y Variaciones, y una clase, Factura, que las implementa: // Declaracion de la interfaz Constantes public interface Constantes { double valorMaximo = 10000000.0; double valorMinimo = -0.01; } // Declaracion de la interfaz Variaciones public interface Variaciones { void asignaValor(double x); void rebaja(double t); } // Declaracion de la clase Factura public class Factura implements Constantes, Variaciones { private double totalSinIVA; public final static double IVA = 0.16; public double sinIVA() { return this.totalSinIVA; } public double conIVA() { return this.totalSinIVA * (1+IVA); } public void asignaValor(double x) { if (this.valorMinimo<x) this.totalSinIVA=x; else this.totalSinIVA=0; } public void rebaja(double t) { this.totalSinIVA *= (1-t/100); } public static void main (String [] args) { factura a = new Factura(); a.asignaValor(250.0); System.out.println( El precio sin IVA es:   + a.sinIVA()); System.out.println( El precio con IVA es:   + a.conIVA()); System.out.println( Rebajado durante el mes de mayo un 20% ); a.rebaja(20); System.out.println( Rebajado sin IVA es:   + a.sinIVA()); System.out.println( Rebajado con IVA es:   + a.conIVA()); } } Si una interfaz implementa otra, incluye todas sus constantes y declaraciones de m√©todos, aunque puede redefinir tanto constantes como m√©todos. Importante: Es peligroso modificar una interfaz ya que las clases dependientes dejan de funcionar hasta que √©stas implementen los nuevos m√©todos. Una clase puede simult√°neamente descender de otra clase e implementar una o varias interfaces. En este caso la seccion implements se coloca a continuaci√≥n de extends en la cabecera de declaraci√≥n de la clase. Por ejemplo: public class ClaseDescendiente extends ClaseAscendiente implements Interfaz { ... } 18.4 UTILIZACI√ìN DE UNA INTERFAZ COMO UN TIPO DE DATO Al declarar una interfaz, se declara un nuevo tipo de referencia. Pueden emplearse identificadores de interfaz en cualquier lugar donde se pueda utilizar el identificador de un tipo de dato (o de una clase). El objetivo es garantizar la sustituibilidad por cualquier instancia de una clase que la implemente. Por ejemplo, puede emplearse como tipo de un par√°metro de un m√©todo: public class Calculos { public void asignacion(Variaciones x); { ... } } S√≥lo una instancia de una clase que implemente la interfaz puede asignarse al par√°metro cuyo tipo corresponde al identificador de la interfaz. Esta facultad se puede aprovechar dentro la propia interfaz. Por ejemplo: public interface Comparable { // La instancia que llama a esMayor (this) y el parametro otra // deben ser de la misma clase o de clases que implementen esta interfaz // La funcion devuelve 1, 0, -1 si this es mayor, igual o menor que otra public int esMayor(Comparable otra); } En alg√∫n caso puede ser √∫til declarar una interfaz vac√≠a como, por ejemplo: public interface Marcador { } Esta declaraci√≥n es totalmente v√°lida ya que no es obligatorio incluir dentro de una interfaz la declaraci√≥n de una constante o la cabecera de un m√©todo. La utilidad de estas interfaces reside en la posibilidad de ser empleadas como tipos de dato para especificar clases sin necesidad de obligar a √©stas a implementar alg√∫n m√©todo en concreto. Una interfaz no es una clase pero se considera un tipo en Java y puede ser utilizado como tal."
    },

    {
        "id": 88,
        "autor": "Alex Walton ",
        "pagina": "javadesdecero",
        "fecha": "7/05/2020",
        "titulo": "Interfaces en Java con Ejemplos",
        "link": "https://javadesdecero.es/intermedio/interfaces-ejemplos/",
        "contenido": "En la programaci√≥n orientada a objetos, a veces es √∫til definir qu√© debe hacer una clase, pero no c√≥mo lo har√°. Ya has visto un ejemplo de esto: el m√©todo abstract. Un m√©todo abstracto define la firma de un m√©todo pero no proporciona ninguna implementaci√≥n. Una subclase debe proporcionar su propia implementaci√≥n de cada m√©todo abstracto definido por su superclase. Por lo tanto, un m√©todo abstracto especifica la interfaz para el m√©todo pero no la implementaci√≥n. Si bien las clases y m√©todos abstractos son √∫tiles, es posible llevar este concepto un paso m√°s all√°. En Java, puede separar por completo la interfaz de una clase de su implementaci√≥n utilizando la palabra clave . Table de Contenido 1. Qu√© es una interface en Java 2. interface en el nuevo JDK 3. Implementaci√≥n de interfaces 4. Uso de referencias a interface 5. Variables en interfaces 6. Las interfaces pueden ser extendidas 1. Qu√© es una interface en Java Una interfaz () es sint√°cticamente similar a una clase abstracta, en la que puede especificar uno o m√°s m√©todos que no tienen cuerpo ({}). Esos m√©todos deben ser implementados por una clase para que se definan sus acciones. Por lo tanto, una interfaz especifica qu√© se debe hacer, pero no c√≥mo hacerlo. Una vez que se define una interfaz, cualquier cantidad de clases puede implementarla. Adem√°s, una clase puede implementar cualquier cantidad de interfaces. Para implementar una interfaz, una clase debe proporcionar cuerpos (implementaciones) para los m√©todos descritos por la interfaz. Cada clase es libre de determinar los detalles de su propia implementaci√≥n. Dos clases pueden implementar la misma interfaz de diferentes maneras, pero cada clase a√∫n admite el mismo conjunto de m√©todos. Por lo tanto, el c√≥digo que tiene conocimiento de la interfaz puede usar objetos de cualquier clase, ya que la interfaz con esos objetos es la misma. √óAl proporcionar la palabra clave interface, Java le permite utilizar completamente el aspecto de ‚Äúuna interfaz, m√∫ltiples m√©todos‚Äù del polimorfismo. 2. interface en el nuevo JDK Antes de continuar, se necesita hacer un punto importante. JDK 8 agreg√≥ una funci√≥n a interface que hizo un cambio significativo en sus capacidades. Antes de JDK 8, una interfaz no pod√≠a definir ninguna implementaci√≥n de ning√∫n tipo. Por lo tanto, antes de JDK 8, una interfaz podr√≠a definir solo el qu√©, pero no el c√≥mo, como se acaba de describir. JDK 8 cambi√≥ esto. Hoy, es posible agregar una implementaci√≥n predeterminada a un m√©todo de interfaz. Adem√°s, ahora se admiten los m√©todos de interfaz est√°tica y, a partir de JDK 9, una interfaz tambi√©n puede incluir m√©todos privados. Por lo tanto, ahora es posible que la interfaz especifique alg√∫n comportamiento. Sin embargo, tales m√©todos constituyen lo que son, en esencia, caracter√≠sticas de uso especial, y la intenci√≥n original detr√°s de la interfaz a√∫n permanece. Por lo tanto, como regla general, con frecuencia crear√° y utilizar√° interfaces en las que no se utilizar√°n estas nuevas funciones. Por esta raz√≥n, comenzaremos discutiendo la interfaz en su forma tradicional. Las nuevas funciones de la interfaz se describen m√°s adelante. Aqu√≠ hay una forma general simplificada de una interfaz tradicional: acceso interface nombre { tipo-retorno metodo-nombre1(lista-parametros); tipo-retorno metodo-nombre2(lista-parametros); tipo var1 = valor; tipo var2 = valor; // ... tipo-retorno metodo-nombreN(lista-parametros); tipo varN = valor; } Para una interfaz de nivel superior, acceso es public o no se usa. Cuando no se incluye ning√∫n modificador de acceso, los resultados de acceso predeterminados y la interfaz solo est√°n disponibles para otros miembros de su paquete. Si se declara como public, la interfaz puede ser utilizada por cualquier otro c√≥digo. (Cuando una interfaz se declara public,, debe estar en un archivo del mismo nombre.) nombre es el nombre de la interfaz y puede ser cualquier identificador v√°lido. En la forma tradicional de una interfaz, los m√©todos se declaran utilizando solo su tipo de devoluci√≥n y firma. Son, esencialmente, m√©todos abstractos. Por lo tanto, cada clase que incluye dicha interfaz debe implementar todos sus m√©todos. En una interfaz, los m√©todos son impl√≠citamente p√∫blicos. Las variables declaradas en una interfaz no son variables de instancia. En cambio, son impl√≠citamente public, final, y static, y deben inicializarse. Por lo tanto, son esencialmente constantes. Aqu√≠ hay un ejemplo de una definici√≥n de interfaz. Especifica la interfaz a una clase que genera una serie de n√∫meros. public interface Series { int getSiguiente(); //Retorna el siguiente n√∫mero de la serie void reiniciar(); //Reinicia void setComenzar(int x); //Establece un valor inicial } Esta interfaz se declara p√∫blica para que pueda ser implementada por c√≥digo en cualquier paquete. 3. Implementaci√≥n de interfaces Una vez que se ha definido una interfaz, una o m√°s clases pueden implementar esa interfaz. Para implementar una interfaz, incluya la cl√°usula  en una definici√≥n de clase y luego cree los m√©todos requeridos por la interfaz. La forma general de una clase que incluye la cl√°usula de implements se ve as√≠: class nombreclase extends superclase implements interface { // cuerpo-clase } Para implementar m√°s de una interfaz, las interfaces se separan con una coma. √óPor supuesto, la cl√°usula extends es opcional. Los m√©todos que implementan una interfaz deben declararse p√∫blicos. Adem√°s, la firma de tipo del m√©todo de implementaci√≥n debe coincidir exactamente con la firma de tipo especificada en la definici√≥n de la interfaz. Aqu√≠ hay un ejemplo que implementa la interfaz de Series mostrada anteriormente. Crea una clase llamada DeDos, que genera una serie de n√∫meros, cada uno mayor que el anterior. class DeDos implements Series { int iniciar; int valor; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=2; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } Observe que los m√©todos getSiguiente(), reiniciar() y setComenzar() se declaran utilizando el especificador de acceso p√∫blico (). Esto es necesario. Siempre que implemente un m√©todo definido por una interfaz, debe implementarse como p√∫blico porque todos los miembros de una interfaz son impl√≠citamente p√∫blicos. Aqu√≠ hay una clase que demuestra DeDos: class SeriesDemo { public static void main(String[] args) { DeDos ob=new DeDos(); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); System.out.println( \nReiniciando ); ob.reiniciar(); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); System.out.println( \nIniciando en 100 ); ob.setComenzar(100); for (int i=0;i<5;i++) System.out.println( Siguiente valor es:  +ob.getSiguiente()); } } Salida: Siguiente valor es: 2 Siguiente valor es: 4 Siguiente valor es: 6 Siguiente valor es: 8 Siguiente valor es: 10 Reiniciando Siguiente valor es: 2 Siguiente valor es: 4 Siguiente valor es: 6 Siguiente valor es: 8 Siguiente valor es: 10 Iniciando en 100 Siguiente valor es: 102 Siguiente valor es: 104 Siguiente valor es: 106 Siguiente valor es: 108 Siguiente valor es: 110 Es permitido y com√∫n para las clases que implementan interfaces definir miembros adicionales propios. Por ejemplo, la siguiente versi√≥n de DeDos agrega el m√©todo getAnterior(), que devuelve el valor anterior: class DeDos implements Series { int iniciar; int valor; int anterior; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { anterior=valor; valor+=2; return valor; } public void reiniciar() { valor=iniciar; anterior=valor-2; } public void setComenzar(int x) { iniciar=x; valor=x; anterior=x-2; } //A√±adiendo un m√©todo que no est√° definido en Series int getAnterior(){ return anterior; } } Observe que la adici√≥n de getAnterior() requiri√≥ un cambio en las implementaciones de los m√©todos definidos por Series. Sin embargo, dado que la interfaz con esos m√©todos permanece igual, el cambio es continuo y no rompe el c√≥digo preexistente. Esta es una de las ventajas de las interfaces. Como se explic√≥, cualquier cantidad de clases puede implementar una interfaz. Por ejemplo, aqu√≠ hay una clase llamada DeTres que genera una serie que consta de m√∫ltiplos de tres: public class DeTres implements Series{ int iniciar; int valor; DeTres(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=3; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } Un punto m√°s: si una clase incluye una interfaz pero no implementa completamente los m√©todos definidos por esa interfaz, esa clase debe declararse como abstracta (). No se pueden crear objetos de dicha clase, pero se puede usar como una superclase abstracta, lo que permite que las subclases proporcionen la implementaci√≥n completa. 4. Uso de referencias a interface Es posible que se sorprenda al descubrir que puede declarar una variable de referencia de un tipo de interfaz. En otras palabras, puede crear una variable de referencia de interfaz. Dicha variable puede referirse a cualquier objeto que implemente su interfaz. Cuando llama a un m√©todo en un objeto a trav√©s de una referencia de interfaz, es la versi√≥n del m√©todo implementado por el objeto que se ejecuta. Este proceso es similar al uso de una referencia de superclase para acceder a un objeto de subclase. El siguiente ejemplo ilustra este proceso. Utiliza la misma variable de referencia de interfaz para llamar a m√©todos en objetos de DeDos y DeTres. //Demostraci√≥n de referencia de interface class DeDos implements Series { int iniciar; int valor; DeDos(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=2; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } public class DeTres implements Series{ int iniciar; int valor; DeTres(){ iniciar=0; valor=0; } public int getSiguiente() { valor+=3; return valor; } public void reiniciar() { valor=iniciar; } public void setComenzar(int x) { iniciar=x; valor=x; } } class SeriesDemo { public static void main(String[] args) { DeDos dosOb=new DeDos(); DeTres tresOb=new DeTres(); Series ob; for (int i=0;i<5;i++) { ob = dosOb; System.out.println( Siguiente valor DeDos es:   + ob.getSiguiente()); ob = tresOb; System.out.println( Siguiente valor DeTres es:   + ob.getSiguiente()); } } } Salida: Siguiente valor DeDos es: 2 Siguiente valor DeTres es: 3 Siguiente valor DeDos es: 4 Siguiente valor DeTres es: 6 [...] En main(), ob se declara como una referencia a una interfaz de Series. Esto significa que se puede usar para almacenar referencias a cualquier objeto que implemente Series. En este caso, se utiliza para referirse a dosOb y tresOb, que son objetos de tipo DeDos y DeTres, respectivamente, que implementan Series. Una variable de referencia de interfaz solo tiene conocimiento de los m√©todos declarados por su declaraci√≥n de interfaz. Por lo tanto, ob no se podr√≠a usar para acceder a otras variables o m√©todos que puedan ser compatibles con el objeto. 5. Variables en interfaces Como se mencion√≥, las variables se pueden declarar en una interfaz, pero son impl√≠citamente p√∫blicas, est√°ticas y finales (public, static, y final). A primera vista, podr√≠a pensar que habr√≠a un uso muy limitado para tales variables, pero ocurre lo contrario. Los programas grandes normalmente hacen uso de varios valores constantes que describen cosas como el tama√±o de la matriz, diversos l√≠mites, valores especiales y similares. Dado que un programa grande generalmente se mantiene en una cantidad de archivos fuente separados, debe haber una forma conveniente de hacer que estas constantes est√©n disponibles para cada archivo. En Java, las variables de interfaz ofrecen una soluci√≥n. Para definir un conjunto de constantes compartidas, cree una interfaz que contenga solo estas constantes, sin ning√∫n m√©todo. Cada archivo que necesita acceso a las constantes simplemente ‚Äúimplementa‚Äù la interfaz. Esto trae las constantes a la vista. Aqu√≠ hay un ejemplo: //Una interfaz que contiene constantes interface Constante { //Definiendo 3 constantes int MIN=0; int MAX=10; String MSJERROR= LIMITE ERROR ; } class ConstanteD implements Constante{ public static void main(String[] args) { int numeros[]=new int; for (int i=MIN; i<11; i++){ if (i>=MAX) System.out.println(MSJERROR); else { numeros=i; System.out.println(numeros+    ); } } } } La t√©cnica de usar una interfaz para definir constantes compartidas es controvertida. Veremos m√°s ejemplos m√°s adelante. 6. Las interfaces pueden ser extendidas Una interfaz puede heredar otra mediante el uso de la palabra clave extends. La sintaxis es la misma que para heredar clases. Cuando una clase implementa una interfaz que hereda otra interfaz, debe proporcionar implementaciones para todos los m√©todos requeridos por la cadena de herencia de la interfaz. Lo siguiente es un ejemplo: //Una interface puede extender de otra interface A{ void metodo1(); void metodo2(); } //B ahora incluye metodo1() y metodo2() - y a√±ade metodo3() interface B extends A{ void metodo3(); } //Esta clase debe implementar los m√©todos de A y B class MiClase implements B{ public void metodo1() { System.out.println( Implementaci√≥n de metodo1(). ); } public void metodo2() { System.out.println( Implementaci√≥n de metodo2(). ); } public void metodo3() { System.out.println( Implementaci√≥n de metodo3(). ); } } public class Extender { public static void main(String[] args) { MiClase mc=new MiClase(); mc.metodo1(); mc.metodo2(); mc.metodo3(); } } Salida: Implementaci√≥n de metodo1(). Implementaci√≥n de metodo2(). Implementaci√≥n de metodo3(). Como experimento, puede intentar eliminar la implementaci√≥n de metodo1() en MiClase. Esto causar√° un error en tiempo de compilaci√≥n. Como se dijo anteriormente, cualquier clase que implemente una interfaz debe implementar todos los m√©todos requeridos por esa interfaz, incluidos los heredados de otras interfaces."
    },

    {
        "id": 89,
        "autor": "Ricardo Moya",
        "pagina": "jarroba",
        "fecha": "8/04/2014",
        "titulo": "Herencia en Java, con ejemplos",
        "link": "https://jarroba.com/herencia-en-la-programacion-orientada-a-objetos-ejemplo-en-java/",
        "contenido": "La Herencia es uno de los 4 pilares de la programaci√≥n orientada a objetos (POO) junto con la Abstracci√≥n, Encapsulaci√≥n y Polimorfismo. Al principio cuesta un poco entender estos conceptos caracter√≠sticos del paradigma de la POO porque solemos venir de otro paradigma de programaci√≥n como el paradigma de la programaci√≥n estructurada (ver la entrada Paradigmas de Programaci√≥n), pero se ha de decir que la complejidad est√° en entender este nuevo paradigma y no en otra cosa. En esta entrada vamos a explicar de la mejor manera posible que es la herencia y lo vamos a explicar con un ejemplo. Respecto a la herencia se han dado muchas definiciones como por ejemplo la siguiente:  La herencia es un mecanismo que permite la definici√≥n de una clase a partir de la definici√≥n de otra ya existente. La herencia permite compartir autom√°ticamente m√©todos y datos entre clases, subclases y objetos. . As√≠ de primeras esta definici√≥n es un poco dif√≠cil de digerir para aquellos que est√©is empezando con la POO, as√≠ que vamos a intentar digerir esta definici√≥n con un ejemplo en el que veremos que la herencia no es m√°s que un  Copy-Paste Din√°mico  o una forma de  sacar factor com√∫n  al c√≥digo que escribimos. El ejemplo que proponemos es un caso en el que vamos a simular el comportamiento que tendr√≠an los diferentes integrantes de la selecci√≥n espa√±ola de futbol; tanto los Futbolistas como el cuerpo t√©cnico (Entrenadores, Masajistas, etc‚Ä¶). Para simular este comportamiento vamos a definir tres clases que van a representaran a objetos Futbolista, Entrenador y Masajista. De cada unos de ellos vamos a necesitar algunos datos que reflejaremos en los atributos y una serie de acciones que reflejaremos en sus m√©todos. Estos atributos y m√©todos los mostramos en el siguiente diagrama de clases: NoHerencia_jarroba NOTA: en este diagrama y en adelante no vamos a poner los constructores y m√©todos getter y setter con el fin de que el diagrama nos quede grande e  intendible  aunque en un buen diagrama de clases deber√≠an aparecer para respetar el principio de encapsulaci√≥n de la POO Como se puede observar, vemos que en las tres clases tenemos atributos y m√©todos que son iguales ya que los tres tienen los atributos id, Nombre, Apellidos y Edad; y los tres tienen los m√©todos de Viajar y Concentrarse: Herencia_jarroba A nivel de c√≥digo tenemos lo siguiente tras ver el diagrama de clases: public class Futbolista { private int id; private String Nombre; private String Apellidos; private int Edad; private int dorsal; private String demarcacion; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void jugarPartido() { ... } public void entrenar() { ... } } public class Entrenador { private int id; private String Nombre; private String Apellidos; private int Edad; private String idFederacion; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void dirigirPartido() { ... } public void dirigirEntreno() { ... } } public class Masajista { private int id; private String Nombre; private String Apellidos; private int Edad; private String Titulacion; private int aniosExperiencia; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } public void darMasaje() { ... } } Lo que podemos ver en este punto es que estamos escribiendo mucho c√≥digo repetido ya que las tres clases tienen m√©todos y atributos comunes, de ahi y como veremos enseguida, decimos que la herencia consiste en  sacar factor com√∫n  para no escribir c√≥digo de m√°s, por tanto lo que haremos sera crearnos una clase con el  c√≥digo que es com√∫n a las tres clases  (a esta clase se le denomina en la herencia como  Clase Padre o SuperClase ) y el c√≥digo que es  especifico de cada clase, lo dejaremos en ella, siendo denominadas estas clases como  Clases Hijas , las cuales heredan de la clase padre todos los atributos y m√©todos p√∫blicos o protegidos. Es muy importante decir que las clases hijas no van a heredar nunca los atributos y m√©todos privados de la clase padre, as√≠ que mucho cuidado con esto. En resumen para que ve√°is la ventaja de la herencia, tenemos ahora una clase padre con 'n' lineas de c√≥digo y tres clases hijas con 'a', 'b' y 'c' lineas de c√≥digos respectivamente, por tanto si hech√°is cuentas, hemos reducido nuestro c√≥digo en '2n' l√≠neas menos ya que antes ten√≠amos '(n+a)+(n+b)+(n+c)' l√≠neas de c√≥digo y ahora tras aplicar herencia tenemos 'n+a+b+c' l√≠neas, aunque tambi√©n es cierto que tenemos una clase m√°s, pero veremos un poco m√°s adelante la ventaja de tener esa clase padre. En resumen, al  sacar factor com√∫n  y aplicar herencia, tenemos las siguientes clases: HerenciaV2_jarroba A nivel de c√≥digo, las clases quedar√≠an implementadas de la siguiente forma: public class SeleccionFutbol { protected int id; protected String Nombre; protected String Apellidos; protected int Edad; // constructor, getter y setter public void Concentrarse() { ... } public void Viajar() { ... } } public class Futbolista extends SeleccionFutbol { private int dorsal; private String demarcacion; public Futbolista() { super(); } // getter y setter public void jugarPartido() { ... } public void entrenar() { ... } } public class Entrenador extends SeleccionFutbol { private String idFederacion; public Entrenador() { super(); } // getter y setter public void dirigirPartido() { ... } public void dirigirEntreno() { ... } } public class Masajista extends SeleccionFutbol { private String Titulacion; private int aniosExperiencia; public Masajista() { super(); } // getter y setter public void darMasaje() { ... } } Como pod√©is observar ahora queda un c√≥digo mucho m√°s limpio, estructurado y con menos l√≠neas de c√≥digo, lo que lo hace m√°s legible, cosa que es muy importante y lo que todav√≠a lo hace m√°s importante es que es un c√≥digo reutilizable, lo que significa que ahora si queremos a√±adir m√°s clases a nuestra aplicaci√≥n como por ejemplo una clase M√©dico, Utiller@, Jefe/a de prensa etc. que pertenezcan tambi√©n al equipo t√©cnico de la selecci√≥n Espa√±ola, lo podemos hacer de forma muy sencilla ya que en la clase padre (SeleccionFutbol) tenemos implementado parte de sus datos y de su comportamiento y solo habr√° que implementar los atributos y m√©todos propios de esa clase. ¬øEmpez√°is a ver la utilidad de la herencia?. Ahora si os hab√©is fijado bien en el c√≥digo que se ha escrito y sino hab√©is tenido experiencia con la herencia en Java, habr√©is podido observar dos palabras reservadas  nuevas  como son  extends ,  protected  y  super . Pues bien, ahora vamos a explicar el significado de ellas: extends: Esta palabra reservada, indica a la clase hija cual va a ser su clase padre, es decir que por ejemplo en la clase Futbolista al poner  public class Futbolista extends SeleccionFutbol  le estamos indicando a la clase 'Futbolista' que su clase padre es la clase 'SeleccionFutbol' o dicho de otra manera para que se entienda mejor, al poner esto estamos haciendo un  copy-paste din√°mico  diciendo a la clase 'Futbolista' que se 'copie' todos los atributos y m√©todos p√∫blicos o protegidos de la clase 'SeleccionFutbol'. De aqu√≠ viene esa 'definici√≥n' que dimos de que la herencia en un 'copy-paste din√°mico'. protected:  sirve para indicar un tipo de visibilidad de los atributos y m√©todos de la clase padre y significa que cuando un atributo es 'protected' o protegido, solo es visible ese atributo o m√©todo desde una de las clases hijas y no desde otra clase. super: sirve para llamar al constructor de la clase padre. Quiz√°s en el c√≥digo que hemos puesto no se ha visto muy bien, pero a continuaci√≥n lo mostramos de formas m√°s clara, viendo el constructor de los objetos pas√°ndole los atributos: public class SeleccionFutbol { ...... public SeleccionFutbol() { } public SeleccionFutbol(int id, String nombre, String apellidos, int edad) { this.id = id; this.Nombre = nombre; this.Apellidos = apellidos; this.Edad = edad; } ...... public class Futbolista extends SeleccionFutbol { ...... public Futbolista() { super(); } public Futbolista(int id, String nombre, String apellidos, int edad, int dorsal, String demarcacion) { super(id, nombre, apellidos, edad); this.dorsal = dorsal; this.demarcacion = demarcacion; } ...... Hasta aqu√≠ todo correcto, pero ahora vamos a ver como trabajamos con estas clases. Para ver este funcionamiento de forma clara y sencilla vamos a trabajar con un objeto de cada clase y vamos a ver como se crean y de que forma ejecutan sus m√©todo. Para ello empecemos mostrando el siguiente fragmento de c√≥digo: public class Main { // ArrayList de objetos SeleccionFutbol. Idenpendientemente de la clase hija a la que pertenezca el objeto public static ArrayList<SeleccionFutbol> integrantes = new ArrayList<SeleccionFutbol>(); public static void main(String[] args) { Entrenador delBosque = new Entrenador(1,  Vicente ,  Del Bosque , 60,  284EZ89 ); Futbolista iniesta = new Futbolista(2,  Andres ,  Iniesta , 29, 6,  Interior Derecho ); Masajista raulMartinez = new Masajista(3,  Ra√∫l ,  Martinez , 41,  Licenciado en Fisioterapia , 18); integrantes.add(delBosque); integrantes.add(iniesta); integrantes.add(raulMartinez); // CONCENTRACION System.out.println( Todos los integrantes comienzan una concentracion. (Todos ejecutan el mismo m√©todo) ); for (SeleccionFutbol integrante : integrantes) { System.out.print(integrante.getNombre()+   +integrante.getApellidos()+  ->  ); integrante.Concentrarse(); } // VIAJE System.out.println( nTodos los integrantes viajan para jugar un partido. (Todos ejecutan el mismo m√©todo) ); for (SeleccionFutbol integrante : integrantes) { System.out.print(integrante.getNombre()+   +integrante.getApellidos()+  ->  ); integrante.Viajar(); } ...... Lo primero que vemos es que nos creamos un objeto de cada clase, pas√°ndole los atributos al constructor como par√°metro y despu√©s  sorprendentemente  los metemos en un  ArrayList  de objetos de la clase  SeleccionFutbol  que es la clase padre. Esto evidentemente te lo permite hacer ya que todos los objetos son hijos de la misma clase padre. Luego como veis, recorremos el ArrayList y ejecutamos sus m√©todos  comunes  como son el 'Concentrarse' y el 'Viajar'. Este c√≥digo da como salida lo siguiente: Todos los integrantes comienzan una concentracion. (Todos ejecutan el mismo m√©todo) Vicente Del Bosque -> Concentrarse Andres Iniesta -> Concentrarse Ra√∫l Martinez -> Concentrarse Todos los integrantes viajan para jugar un partido. (Todos ejecutan el mismo m√©todo) Vicente Del Bosque -> Viajar Andres Iniesta -> Viajar Ra√∫l Martinez -> Viajar Como veis al ejecutar todos el mismo m√©todo de la clase padre el c√≥digo puesto funciona correctamente. Posteriormente vamos a ejecutar c√≥digo especifico de las clases hijas, de ahi que ahora no podamos recorrer el ArrayList y ejecutar el mismo m√©todo para todos los objetos ya que ahora esos objetos son √∫nicos de la clases hijas. El c√≥digo es el siguiente: // ENTRENAMIENTO System.out.println( nEntrenamiento: Solamente el entrenador y el futbolista tiene metodos para entrenar: ); System.out.print(delBosque.getNombre()+   +delBosque.getApellidos()+  ->  ); delBosque.dirigirEntrenamiento(); System.out.print(iniesta.getNombre()+   +iniesta.getApellidos()+  ->  ); iniesta.entrenar(); // MASAJE System.out.println( nMasaje: Solo el masajista tiene el m√©todo para dar un masaje: ); System.out.print(raulMartinez.getNombre()+   +raulMartinez.getApellidos()+  ->  ); raulMartinez.darMasaje(); // PARTIDO DE FUTBOL System.out.println( nPartido de F√∫tbol: Solamente el entrenador y el futbolista tiene metodos para el partido de f√∫tbol: ); System.out.print(delBosque.getNombre()+   +delBosque.getApellidos()+  ->  ); delBosque.dirigirPartido(); System.out.print(iniesta.getNombre()+   +iniesta.getApellidos()+  ->  ); iniesta.jugarPartido(); Como vemos aunque el entrenador y los futbolistas asistan a un entrenamiento, los dos hacen una funci√≥n diferente en el mismo, por tanto hay que hacer m√©todos diferente para cada una de las clases. Ya veremos cuando hablemos del polimorfismo que podremos ejecutar el mismo m√©todo para clases diferentes y que esos m√©todos hagan cosas distintas. Como resultado al c√≥digo mostrado tenemos lo siguiente: Entrenamiento: Solamente el entrenador y el futbolista tiene metodos para entrenar: Vicente Del Bosque -> Dirige un entrenamiento Andres Iniesta -> Entrena Masaje: Solo el masajista tiene el m√©todo para dar un masaje: Ra√∫l Martinez -> Da un masaje Partido de F√∫tbol: Solamente el entrenador y el futbolista tiene metodos para el partido de f√∫tbol: Vicente Del Bosque -> Dirige un partido Andres Iniesta -> Juega un partido CONCLUSIONES Y ACLARACIONES: Esto ha sido todo lo que hemos contado sobre la herencia en esta entrada. El tema de la herencia es un tema que puede ser un poco m√°s complejo de lo que lo hemos contado aqu√≠, ya que solo hemos contado lo que es la herencia simple (ya que Java por el momento es el √∫nico tipo de herencia que soporta) y no la herencia m√∫ltiple, que es un tipo de herencia en la que una clase hija puede tener varios padres, aunque por el momento si est√°is empezando a aprender el concepto de la herencia, con la herencia simple ten√©is m√°s que suficiente. Para los que os est√©is iniciando en el mundo de la ingenier√≠a inform√°tica, habr√©is podido ver que hemos puesto unos ejemplo mostrando unos diagramas  un poco raros ; pues bien, estos diagramas se llaman diagramas de clases (que los hemos realizado con la herramienta web de www.genmymodel.com) y sirven para representar de forma gr√°fica los atributos y m√©todos de las clases y las relaciones entre ellos, utilizando el lenguaje UML del cual intentaremos hablar m√°s adelante en otros tutoriales. Por √∫ltimo decir y aclarar que en esta entrada quiz√°s no hemos utilizado una terminolog√≠a correcta para explicar la herencia, pero lo hemos explicadode una forma algo distinta a como esta explicada por ahi para que los que empeceis podais entender la herencia desde otro punto de vista."
    },

    {
        "id": 90,
        "autor": "arkaitzgarro",
        "pagina": "arkaitzgarro",
        "fecha": "0/0/0",
        "titulo": "CAP√çTULO 16 HERENCIA",
        "link": "https://www.arkaitzgarro.com/java/capitulo-16.html",
        "contenido": "16.1 DEFINICI√ìN DE HERENCIA La herencia es una propiedad que permite la declaraci√≥n de nuevas clases a partir de otras ya existentes. Esto proporciona una de las ventajas principales de la Programaci√≥n Orientada a Objetos: la reutilizaci√≥n de c√≥digo previamente desarrollado ya que permite a una clase m√°s espec√≠fica incorporar la estructura y comportamiento de una clase m√°s general. Cuando una clase B se construye a partir de otra A mediante la herencia, la clase B hereda todos los atributos, m√©todos y clases internas de la clase A. Adem√°s la clase B puede redefinir los componentes heredados y a√±adir atributos, m√©todos y clases internas espec√≠ficas. Para indicar que la clase B (clase descendiente, derivada, hija o subclase) hereda de la clase A (clase ascendiente, heredada, padre, base o superclase) se emplea la palabra reservada extends en la cabecera de la declaraci√≥n de la clase descendiente. La sintaxis es la siguiente: public class ClaseB extends ClaseA { // Declaracion de atributos y metodos especificos de ClaseB // y/o redeclaracion de componentes heredados } Por ejemplo, a partir de la clase Precio: /** * Ejemplo de declaracion de la clase Precio */ public class Precio { // Variable de instancia public double euros; // Metodos publicos public double da() { return this.euros; } public void pone(double x) { this.euros = x; } } se construye la clase Producto como descendiente de la clase Precio de la siguiente forma: /** * Ejemplo de declaracion de la clase Producto * clase producto desciende de Precio */ public class Producto extends Precio { // Variable de instancia public int codigo; // Metodos publicos public int daCodigo() { return this.codigo; } public void asignaCodigo(int x) { this.codigo=x; } public void asignaProducto(int cod, double p) { this.asignaCodigo(cod); this.pone(p); } public String toString() { return  Codigo:   + codigo +   ; precio:   + euros +   euros ; } } La clase PruebaClaseProducto trabaja con dos instancias de la clase Producto: /** *  Demostracion de la clase Producto */ public class PruebaClaseProducto { public static void main (String [] args){ Producto p = new Producto(); p.asignaProducto(200201, 15.8); System.out.println(p.toString()); Producto q = new Producto(); q.asignaCodigo(200202); q.pone(34.3); System.out.println(q.toString()); } } Durante la ejecuci√≥n del c√≥digo anterior, se generan las instancias, referenciadas por p y q, cada una de las cuales est√° compuesta por dos atributos: euros, variable de instancia heredada de la clase Precio y codigo, variable de instancia espec√≠fica de la clase Producto. Representaci√≥n grafica de las instancias de la clase <code>Producto</code> Figura 16.1 Representaci√≥n grafica de las instancias de la clase Producto Por otro lado, la ejecuci√≥n de PruebaClaseProducto produce la siguiente salida por pantalla: $>javac PruebaClaseProducto.java $>java PruebaClaseProductoCodigo: 200201 ; precio: 15.8 euros Codigo: 200202 ; precio: 34.3 euros 16.2 JERARQU√çA DE CLASES Java permite m√∫ltiples niveles de herencia pero no la herencia multiple, es decir una clase s√≥lo puede heredar directamente de una clase ascendiente. Por otro lado, una clase puede ser ascendiente de tantas clases descendiente como se desee (un unico padre, multitud de hijos). En la siguiente figura se muestra gr√°ficamente un ejemplo de jerarqu√≠a entre diferentes clases relacionadas mediante la herencia. Representaci√≥n de una jerarqu√≠a de clases relacionadas mediante la herencia Figura 16.2 Representaci√≥n de una jerarqu√≠a de clases relacionadas mediante la herencia 16.3 REDEFINICI√ìN DE ELEMENTOS HEREDADOS Como se ha comentado anteriormente la clase descendiente puede a√±adir sus propios atributos y m√©todos pero tambi√©n puede sustituir u ocultar los heredados. En concreto: Se puede declarar un nuevo atributo con el mismo identificador que uno heredado, quedando este atributo oculto. Esta t√©cnica no es recomendable. Se puede declarar un nuevo m√©todo de instancia con la misma cabecera que el de la clase ascendiente, lo que supone su sobreescritura. Por lo tanto, la sobreescritura o redefinici√≥n consiste en que m√©todos adicionales declarados en la clase descendiente con el mismo nombre, tipo de dato devuelto y n√∫mero y tipo de par√°metros sustituyen a los heredados. Se puede declarar un nuevo m√©todo de clase con la misma cabecera que el de la clase ascendiente, lo que hace que √©ste quede oculto. Por lo tanto, los m√©todos de clase o est√°ticos (declarados como static) no pueden ser redefinidos. Un m√©todo declarado con el modificador final tampoco puede ser redefinido por una clase derivada. Se puede declarar un constructor de la subclase que llame al de la superclase de forma impl√≠cita o de mediante la palabra reservada super. En general puede accederse a los m√©todos de la clase ascendiente que han sido redefinidos empleando la palabra reservada super delante del identificador del m√©todo. Este mecanismo s√≥lo permite acceder al metodo perteneciente a la clase en el nivel inmediatamente superior de la jerarqu√≠a de clases. 16.4 LA CLASE OBJECT Independientemente de utilizar la palabra reservada extends en su declaraci√≥n, todas las clases derivan de una superclase llamada Object. √âsta es la clase ra√≠z de toda la jerarqu√≠a de clases de Java. El hecho de que todas las clases deriven impl√≠citamente de la clase Object no se considera herencia m√∫ltiple. Jerarqu√≠a de clases predefinidas en Java Figura 16.3 Jerarqu√≠a de clases predefinidas en Java Como consecuencia de ello, todas las clases tienen algunos m√©todos heredados de la clase Object. Algunos de los m√©todos de la clase predefinida <code>Object</code> Figura 16.4 Algunos de los m√©todos de la clase predefinida Object Es bastante frecuente tener que sobreescribir algunos de estos m√©todos. Por ejemplo, para verificar si dos instancias son iguales en el sentido de contener la misma informaci√≥n en sus atributos se deber√≠a sobreescribir el m√©todo equals(). El siguiente c√≥digo muestra un ejemplo de m√≥dificaci√≥n de la clase Producto para incluir una sobreescritura del m√©todo equals(): public class Producto extends Precio { ... public boolean equals(Object a) { if (a instanceof Producto) return (codigo==a.daCodigo()); else return false; } } Tambi√©n es bastante habitual sobreescribir el m√©todo toString(). 16.5 HERENCIA Y CONSTRUCTORES La subclase necesita normalmente que se ejecute el constructor de la superclase antes que su propio constructor para inicializar las variables de instancia heredadas. La soluci√≥n consiste en utilizar la palabra reservada super seguida entre par√©ntesis de los par√°metros correspondiente en el cuerpo del constructor de la subclase. Es decir, incluir la siguiente sentencia como primera l√≠nea de c√≥digo: super(argumentos opcionales); De esta forma la implementaci√≥n de un constructor de la clase descendiente s√≥lo necesita inicializar directamente las variables de instancia no heredadas. Si no aparece como primera sentencia, el compilador inserta una llamada impl√≠cita super(); que inicializa las variables de instancia a cero, false, car√°cter nulo o null dependiendo de su tipo. Esta llamada en cadena a los constructores de las clases ascendientes llega hasta el origen de la jerarqu√≠a de clases, es decir, hasta el constructor de la clase Object. En cualquier caso, la creaci√≥n de una nueva instancia mediante un constructor debe tener tres fases: Llamada al constructor de la clase ascendiente. Se asignan valores a los atributos. Se ejecuta el resto del constructor. 16.6 CASTING O MOLDES ENTRE OBJETOS CON RELACI√ìN DE HERENCIA El casting o moldeo permite el uso de un objeto de una clase en lugar de otro de otras clase con el que haya una relaci√≥n de herencia. Por ejemplo: Object a = new Producto(); Entonces a es moment√°neamente tanto una instancia de la clase Object como Producto (hasta que m√°s adelante se le asigne un objeto que no sea un Producto). A esto se le llama moldeo impl√≠cito. Por otro lado, si se escribe: Producto b = a; se obtendr√° un error de compilaci√≥n porque el objeto referenciado por a no es considerado por el compilador como un Producto. Sin embargo se le puede indicar al compilador que a la referencia a se le va a asignar obligatoriamente un Producto. Producto b = (Producto)a; Este moldeo expl√≠cito introduce la verificaci√≥n durante la ejecuci√≥n de que a la referencia a se le ha asignado un Producto as√≠ que el compilador no genera un error. En el caso que durante la ejecuci√≥n la referencia a no fuera a un Producto, se generar√≠a una excepci√≥n. Para asegurar esta situaci√≥n y evitar el error de ejecuci√≥n se podr√≠a emplear el operador instanceof: if (a instanceof Producto) { Producto b = (Producto)a; } 16.7 CLASES Y M√âTODOS ABSTRACTOS Una clase abstracta es una clase de la que no se pueden crear instancias. Su utilidad consiste en permitir que otras clases deriven de ella. De esta forma, proporciona un modelo de referencia a seguir a la vez que una serie de m√©todos de utilidad general. Las clases abstractas se declaran empleando la palabra reservada abstract como se muestra a continuaci√≥n: public abstract class IdClase . . . Una clase abstracta puede componerse de varios atributos y m√©todos pero debe tener, al menos, un m√©todo abstracto (declarado tambi√©n con la palabra reservada abstract en la cabecera). Los m√©todos abstractos no se implementan en el c√≥digo de la clase abstracta pero las clases descendientes de √©sta han de implementarlos o volver a declararlos como abstractos (en cuyo caso la subclase tambi√©n debe declararse como abstracta). En cualquier caso, ha de indicarse el tipo de dato que devuelve y el n√∫mero y tipo de par√°metros. La sintaxis de declaraci√≥n de un m√©todo abstracto es: abstract modificador tipo_retorno idClase(lista_parametros); Si una clase tiene m√©todos abstractos, entonces tambi√©n la clase debe declararse como abstracta. Como los m√©todos de clase (static) no pueden ser redefinidos, un m√©todo abstracto no puede ser est√°tico. Tampoco tiene sentido que declarar constructores abstractos ya que un constructor se emplea siempre al crear una instancia (y con las clases abstractas no se crean instancias). Ejemplo de c√≥digo con la declaraci√≥n de clase abstracta: /** * Declaracion de la clase abstracta FiguraGeometrica */ public abstract class FiguraGeometrica { // Declaracion de atributos private String nombre; // Declaracion de metodos abstract public double area(); public figuraGeometrica (String nombreFigura ) { this.nombre = nombreFigura; } final public boolean mayorQue (FiguraGeometrica otra) { return this.area()>otra.area(); } final public String toString() return this.nombre +   con area   + this.area(); } } Como ejemplo de utilizaci√≥n de Rectangulo se construye a partir de la clase abstracta FiguraGeometrica: /** * Ejemplo de uso de la declaracion de una clase abstracta * Declaracion de la clase Rectangulo */ public class Rectangulo extends FiguraGeometrica { private double base; private double altura; public Rectangulo (double largo, double ancho) { super( Rectangulo ); this.base = largo; this.altura = ancho; } public double area () { return this.base * this.altura; } } Ejemplo de uso de la clase Rectangulo: /** * Ejemplo de uso de la clase Rectangulo */ public class pruebaRectangulo { public static void main (String [] args ) { Rectangulo r1; r1 = new Rectangulo(12.5, 23.7); System.out.println( Area de r1 =   + r1.area()); Rectangulo r2 = new Rectangulo(8.6, 33.1); System.out.println( Area de r2 =   + r2.toString()); if (r1.mayorQue(r2)) System.out.println( El rectangulo de mayor area es r1 ); else System.out.println( El rectangulo de mayor area es r2 ); } } Salida por pantalla de la ejecuci√≥n del c√≥digo anterior: $>java PruebaRectangulo Area de r1 = 296.25 Area de r2 = Rectangulo con area 284.66 El rectangulo de mayor area es r1 16.8 CLASES Y M√âTODOS FINALES Una clase declarada con la palabra reservada final no puede tener clases descendientes. Por ejemplo, la clase predefinida de Java Math est√° declarada como final. A modo de ejemplo, se desarrolla una clase final MathBis (de operatividad similar a la clase Math est√°ndar de Java) que incluye la declaraci√≥n de dos m√©todos que calculan y devuelven respectivamente las siguientes funciones trigonom√©tricas: El c√≥digo fuente de la clase es: /** * Ejemplo de declaracion de una clase final * Declaracion de la clase MathBis */ public final class MathBis { public static double asinh(double x) { return Math.log(x+Math.sqrt(x*x+1)); } public static double acosh(double x) { return Math.log(x+Math.sqrt(x*x-1)); } } Ejemplo de uso de la clase MathBis: /** * Ejemplo de uso de una clase final * Declaracion de la clase pruebaMathBis */ public class PruebaMathBis { public static void main (String [] args) { for (int i=-5; i<10; i++) { double x = i/5.0; System.out.print( Para x =   + x); System.out.print( : asinh(x) =   +MathBis.asinh(x)); System.out.println( , acosh(x) =   +MathBis.acosh(x)); } } } Por otro lado, un m√©todo declarado como final no puede ser redefinido por una clase descendiente. Los m√©todos que son llamados desde los constructores deber√≠an declararse como final, ya que si un constructor llama a un m√©todo que no lo sea, la subclase podr√≠a haberla redefinido con resultados indeseables."
    },

    {
        "id": 91,
        "autor": "Alex Rodr√≠guez",
        "pagina": "aprenderaprogramar",
        "fecha": "0/0/0",
        "titulo": "Ejemplo de herencia en Java. Uso de palabras clave extends y super. Constructores con herencia.",
        "link": "https://www.aprenderaprogramar.com/index.php?option=com_content&view=article&id=653:ejemplo-de-herencia-en-java-uso-de-palabras-clave-extends-y-super-constructores-con-herencia-cu00686b&catid=68&Itemid=188#:~:text=Para%20declarar%20la%20herencia%20en,clases%20que%20mostramos%20a%20continuaci%C3%B3n.",
        "contenido": "EJEMPLO DE HERENCIA EN JAVA. EXTENDS Y SUPER. Para declarar la herencia en Java usamos la palabra clave extends. Ejemplo: public class MiClase2 extends Miclase1. Para familiarizarte con la herencia te proponemos que escribas y estudies un peque√±o programa donde se hace uso de ella. Escribe el c√≥digo de las clases que mostramos a continuaci√≥n. //C√≥digo de la clase Persona ejemplo aprenderaprogramar.com public class Persona { private String nombre; private String apellidos; private int edad; //Constructor public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad;                   } //M√©todos public String getNombre () { return nombre;  } public String getApellidos () { return apellidos;  } public int getEdad () { return edad;   } } //Cierre de la clase //C√≥digo de la clase profesor, subclase de la clase Persona ejemplo aprenderaprogramar.com public class Profesor extends Persona { //Campos espec√≠ficos de la subclase. private String IdProfesor; //Constructor de la subclase: incluimos como par√°metros al menos los del constructor de la superclase public Profesor (String nombre, String apellidos, int edad) { super(nombre, apellidos, edad); IdProfesor =  Unknown ;   } //Cierre del constructor //M√©todos espec√≠ficos de la subclase public void setIdProfesor (String IdProfesor) { this.IdProfesor = IdProfesor;   } public String getIdProfesor () { return IdProfesor;   } public void mostrarNombreApellidosYCarnet() { // nombre =  Paco ; Si trat√°ramos de acceder directamente a un campo privado de la superclase, salta un error // S√≠ podemos acceder a variables de instancia a trav√©s de los m√©todos de acceso p√∫blicos de la superclase System.out.println ( Profesor de nombre:   + getNombre() +     +  getApellidos() + con Id de profesor:   + getIdProfesor() ); } } //Cierre de la clase //C√≥digo de test aprenderaprogramar.com public class TestHerencia1 { public static void main (String [ ] Args) { Profesor profesor1 = new Profesor ( Juan ,  Hern√°ndez Garc√≠a , 33); profesor1.setIdProfesor( Prof 22-387-11 ); profesor1.mostrarNombreApellidosYCarnet();} } //Cierre de la clase El diagrama de clases y el resultado del test son del tipo que mostramos a continuaci√≥n: herencia, java Profesor de nombre: Juan Hern√°ndez Garc√≠a con Id de profesor: Prof 22-387-11 Los aspectos a destacar del c√≥digo son: a) La clase persona es una clase ‚Äúnormal‚Äù definida tal y como lo venimos haciendo habitualmente mientras que la clase Profesor es una subclase de Persona con ciertas peculiaridades. b) Los objetos de la subclase van a tener campos nombre, apellidos y edad (heredados de Persona) y un campo espec√≠fico IdProfesor. El constructor de una subclase ha de llevar obligatoriamente como par√°metros al menos los mismos par√°metros que el constructor de la superclase. c) El constructor de la subclase invoca al constructor de la superclase. Para ello se incluye, obligatoriamente, la palabra clave super como primera l√≠nea del constructor de la subclase. La palabra super ir√° seguida de par√©ntesis dentro de los cuales pondremos los par√°metros que requiera el constructor de la superclase al que queramos invocar. En este caso solo ten√≠amos un constructor de superclase que requer√≠a tres par√°metros. Si p.ej. hubi√©ramos tenido otro constructor que no requiriera ning√∫n par√°metro podr√≠amos haber usado uno u otro, es decir, super(nombre, apellidos, edad) √≥ super(), o bien ambos teniendo dos constructores para la superclase y dos constructores para la subclase. Ejemplo: En la superclase:                                public Persona() { nombre =   ; apellidos =   ; edad = 0; } public Persona (String nombre, String apellidos, int edad) { this.nombre = nombre; this.apellidos = apellidos; this.edad = edad;                   } En la subclase:                                   public Profesor () { super(); IdProfesor =  Unknown ;} public Profesor (String nombre, String apellidos, int edad) { super(nombre, apellidos, edad); IdProfesor =  Unknown ;   } Modifica el c√≥digo de las clases Persona y Profesor para que queden con dos constructores tal y como hemos mostrado aqu√≠. Crea objetos de ambos tipos en BlueJ y prueba sus m√©todos. ¬øQu√© ocurre si olvidamos poner super como primera l√≠nea de la subclase? Hay dos posibilidades: si la superclase tiene un constructor sin par√°metros, el compilador incluir√° en segundo plano super de forma autom√°tica y no saltar√° un error. De cualquier manera se considera contrario al buen estilo de programaci√≥n, ya que no queda claro si se trata de un olvido. Por ello incluiremos siempre la palabra clave super. La otra posibilidad es que no haya un constructor sin par√°metros, en cuyo caso saltar√° un error. A modo de resumen: la inicializaci√≥n de un objeto de una subclase comprende dos pasos. La invocaci√≥n al constructor de la superclase (primera l√≠nea del constructor: super‚Ä¶) y el resto de instrucciones propias del constructor de la subclase."
    }
]